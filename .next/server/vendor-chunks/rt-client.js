"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rt-client";
exports.ids = ["vendor-chunks/rt-client"];
exports.modules = {

/***/ "(ssr)/./node_modules/rt-client/dist/esm/index.js":
/*!**************************************************!*\
  !*** ./node_modules/rt-client/dist/esm/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LowLevelRTClient: () => (/* binding */ LowLevelRTClient),\n/* harmony export */   MessageItemType: () => (/* binding */ MessageItemType),\n/* harmony export */   RTClient: () => (/* binding */ RTClient),\n/* harmony export */   RTError: () => (/* binding */ RTError),\n/* harmony export */   isFunctionCallItem: () => (/* binding */ isFunctionCallItem),\n/* harmony export */   isMessageItem: () => (/* binding */ isMessageItem)\n/* harmony export */ });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zlib */ \"zlib\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var net__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! net */ \"net\");\n/* harmony import */ var tls__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! tls */ \"tls\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! url */ \"url\");\n\n\n\n\n\n\n\n\n\n\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nvar MessageItemType = \"message\";\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __generator(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);\n    } catch (error) {\n        e = {\n            error: error\n        };\n    } finally{\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally{\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n}\nfunction __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function awaitReturn(f) {\n        return function(v) {\n            return Promise.resolve(v).then(f, reject);\n        };\n    }\n    function verb(n, f) {\n        if (g[n]) {\n            i[n] = function(v) {\n                return new Promise(function(a, b) {\n                    q.push([\n                        n,\n                        v,\n                        a,\n                        b\n                    ]) > 1 || resume(n, v);\n                });\n            };\n            if (f) i[n] = f(i[n]);\n        }\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nvar isRealtimeEvent = function(message) {\n    return typeof message === \"object\" && message !== null && \"type\" in message;\n};\nvar isServerMessageType = function(message) {\n    return isRealtimeEvent(message) && [\n        \"error\",\n        \"session.created\",\n        \"session.updated\",\n        \"input_audio_buffer.committed\",\n        \"input_audio_buffer.cleared\",\n        \"input_audio_buffer.speech_started\",\n        \"input_audio_buffer.speech_stopped\",\n        \"conversation.item.created\",\n        \"conversation.item.truncated\",\n        \"conversation.item.deleted\",\n        \"conversation.item.input_audio_transcription.completed\",\n        \"conversation.item.input_audio_transcription.failed\",\n        \"response.created\",\n        \"response.done\",\n        \"response.output_item.added\",\n        \"response.output_item.done\",\n        \"response.content_part.added\",\n        \"response.content_part.done\",\n        \"response.text.delta\",\n        \"response.text.done\",\n        \"response.audio_transcript.delta\",\n        \"response.audio_transcript.done\",\n        \"response.audio.delta\",\n        \"response.audio.done\",\n        \"response.function_call_arguments.delta\",\n        \"response.function_call_arguments.done\",\n        \"rate_limits.updated\",\n        \"session.avatar.connecting\",\n        \"session.avatar.connected\",\n        \"response.animation.blendshapes\"\n    ].includes(message.type);\n};\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\nvar bufferUtil = {\n    exports: {}\n};\nvar constants;\nvar hasRequiredConstants;\nfunction requireConstants() {\n    if (hasRequiredConstants) return constants;\n    hasRequiredConstants = 1;\n    const BINARY_TYPES = [\n        'nodebuffer',\n        'arraybuffer',\n        'fragments'\n    ];\n    const hasBlob = typeof Blob !== 'undefined';\n    if (hasBlob) BINARY_TYPES.push('blob');\n    constants = {\n        BINARY_TYPES,\n        EMPTY_BUFFER: Buffer.alloc(0),\n        GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n        hasBlob,\n        kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n        kListener: Symbol('kListener'),\n        kStatusCode: Symbol('status-code'),\n        kWebSocket: Symbol('websocket'),\n        NOOP: ()=>{}\n    };\n    return constants;\n}\nvar hasRequiredBufferUtil;\nfunction requireBufferUtil() {\n    if (hasRequiredBufferUtil) return bufferUtil.exports;\n    hasRequiredBufferUtil = 1;\n    const { EMPTY_BUFFER } = requireConstants();\n    const FastBuffer = Buffer[Symbol.species];\n    /**\n\t * Merges an array of buffers into a new buffer.\n\t *\n\t * @param {Buffer[]} list The array of buffers to concat\n\t * @param {Number} totalLength The total length of buffers in the list\n\t * @return {Buffer} The resulting buffer\n\t * @public\n\t */ function concat(list, totalLength) {\n        if (list.length === 0) return EMPTY_BUFFER;\n        if (list.length === 1) return list[0];\n        const target = Buffer.allocUnsafe(totalLength);\n        let offset = 0;\n        for(let i = 0; i < list.length; i++){\n            const buf = list[i];\n            target.set(buf, offset);\n            offset += buf.length;\n        }\n        if (offset < totalLength) {\n            return new FastBuffer(target.buffer, target.byteOffset, offset);\n        }\n        return target;\n    }\n    /**\n\t * Masks a buffer using the given mask.\n\t *\n\t * @param {Buffer} source The buffer to mask\n\t * @param {Buffer} mask The mask to use\n\t * @param {Buffer} output The buffer where to store the result\n\t * @param {Number} offset The offset at which to start writing\n\t * @param {Number} length The number of bytes to mask.\n\t * @public\n\t */ function _mask(source, mask, output, offset, length) {\n        for(let i = 0; i < length; i++){\n            output[offset + i] = source[i] ^ mask[i & 3];\n        }\n    }\n    /**\n\t * Unmasks a buffer using the given mask.\n\t *\n\t * @param {Buffer} buffer The buffer to unmask\n\t * @param {Buffer} mask The mask to use\n\t * @public\n\t */ function _unmask(buffer, mask) {\n        for(let i = 0; i < buffer.length; i++){\n            buffer[i] ^= mask[i & 3];\n        }\n    }\n    /**\n\t * Converts a buffer to an `ArrayBuffer`.\n\t *\n\t * @param {Buffer} buf The buffer to convert\n\t * @return {ArrayBuffer} Converted buffer\n\t * @public\n\t */ function toArrayBuffer(buf) {\n        if (buf.length === buf.buffer.byteLength) {\n            return buf.buffer;\n        }\n        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n    }\n    /**\n\t * Converts `data` to a `Buffer`.\n\t *\n\t * @param {*} data The data to convert\n\t * @return {Buffer} The buffer\n\t * @throws {TypeError}\n\t * @public\n\t */ function toBuffer(data) {\n        toBuffer.readOnly = true;\n        if (Buffer.isBuffer(data)) return data;\n        let buf;\n        if (data instanceof ArrayBuffer) {\n            buf = new FastBuffer(data);\n        } else if (ArrayBuffer.isView(data)) {\n            buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n        } else {\n            buf = Buffer.from(data);\n            toBuffer.readOnly = false;\n        }\n        return buf;\n    }\n    bufferUtil.exports = {\n        concat,\n        mask: _mask,\n        toArrayBuffer,\n        toBuffer,\n        unmask: _unmask\n    };\n    /* istanbul ignore else  */ if (!process.env.WS_NO_BUFFER_UTIL) {\n        try {\n            const bufferUtil$1 = require('bufferutil');\n            bufferUtil.exports.mask = function(source, mask, output, offset, length) {\n                if (length < 48) _mask(source, mask, output, offset, length);\n                else bufferUtil$1.mask(source, mask, output, offset, length);\n            };\n            bufferUtil.exports.unmask = function(buffer, mask) {\n                if (buffer.length < 32) _unmask(buffer, mask);\n                else bufferUtil$1.unmask(buffer, mask);\n            };\n        } catch (e) {\n        // Continue regardless of the error.\n        }\n    }\n    return bufferUtil.exports;\n}\nvar limiter;\nvar hasRequiredLimiter;\nfunction requireLimiter() {\n    if (hasRequiredLimiter) return limiter;\n    hasRequiredLimiter = 1;\n    const kDone = Symbol('kDone');\n    const kRun = Symbol('kRun');\n    /**\n\t * A very simple job queue with adjustable concurrency. Adapted from\n\t * https://github.com/STRML/async-limiter\n\t */ class Limiter {\n        /**\n\t   * Creates a new `Limiter`.\n\t   *\n\t   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n\t   *     to run concurrently\n\t   */ constructor(concurrency){\n            this[kDone] = ()=>{\n                this.pending--;\n                this[kRun]();\n            };\n            this.concurrency = concurrency || Infinity;\n            this.jobs = [];\n            this.pending = 0;\n        }\n        /**\n\t   * Adds a job to the queue.\n\t   *\n\t   * @param {Function} job The job to run\n\t   * @public\n\t   */ add(job) {\n            this.jobs.push(job);\n            this[kRun]();\n        }\n        /**\n\t   * Removes a job from the queue and runs it if possible.\n\t   *\n\t   * @private\n\t   */ [kRun]() {\n            if (this.pending === this.concurrency) return;\n            if (this.jobs.length) {\n                const job = this.jobs.shift();\n                this.pending++;\n                job(this[kDone]);\n            }\n        }\n    }\n    limiter = Limiter;\n    return limiter;\n}\nvar permessageDeflate;\nvar hasRequiredPermessageDeflate;\nfunction requirePermessageDeflate() {\n    if (hasRequiredPermessageDeflate) return permessageDeflate;\n    hasRequiredPermessageDeflate = 1;\n    const zlib = zlib__WEBPACK_IMPORTED_MODULE_1__;\n    const bufferUtil = requireBufferUtil();\n    const Limiter = requireLimiter();\n    const { kStatusCode } = requireConstants();\n    const FastBuffer = Buffer[Symbol.species];\n    const TRAILER = Buffer.from([\n        0x00,\n        0x00,\n        0xff,\n        0xff\n    ]);\n    const kPerMessageDeflate = Symbol('permessage-deflate');\n    const kTotalLength = Symbol('total-length');\n    const kCallback = Symbol('callback');\n    const kBuffers = Symbol('buffers');\n    const kError = Symbol('error');\n    //\n    // We limit zlib concurrency, which prevents severe memory fragmentation\n    // as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n    // and https://github.com/websockets/ws/issues/1202\n    //\n    // Intentionally global; it's the global thread pool that's an issue.\n    //\n    let zlibLimiter;\n    /**\n\t * permessage-deflate implementation.\n\t */ class PerMessageDeflate {\n        /**\n\t   * Creates a PerMessageDeflate instance.\n\t   *\n\t   * @param {Object} [options] Configuration options\n\t   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n\t   *     for, or request, a custom client window size\n\t   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n\t   *     acknowledge disabling of client context takeover\n\t   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n\t   *     calls to zlib\n\t   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n\t   *     use of a custom server window size\n\t   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n\t   *     disabling of server context takeover\n\t   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n\t   *     messages should not be compressed if context takeover is disabled\n\t   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n\t   *     deflate\n\t   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n\t   *     inflate\n\t   * @param {Boolean} [isServer=false] Create the instance in either server or\n\t   *     client mode\n\t   * @param {Number} [maxPayload=0] The maximum allowed message length\n\t   */ constructor(options, isServer, maxPayload){\n            this._maxPayload = maxPayload | 0;\n            this._options = options || {};\n            this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;\n            this._isServer = !!isServer;\n            this._deflate = null;\n            this._inflate = null;\n            this.params = null;\n            if (!zlibLimiter) {\n                const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;\n                zlibLimiter = new Limiter(concurrency);\n            }\n        }\n        /**\n\t   * @type {String}\n\t   */ static get extensionName() {\n            return 'permessage-deflate';\n        }\n        /**\n\t   * Create an extension negotiation offer.\n\t   *\n\t   * @return {Object} Extension parameters\n\t   * @public\n\t   */ offer() {\n            const params = {};\n            if (this._options.serverNoContextTakeover) {\n                params.server_no_context_takeover = true;\n            }\n            if (this._options.clientNoContextTakeover) {\n                params.client_no_context_takeover = true;\n            }\n            if (this._options.serverMaxWindowBits) {\n                params.server_max_window_bits = this._options.serverMaxWindowBits;\n            }\n            if (this._options.clientMaxWindowBits) {\n                params.client_max_window_bits = this._options.clientMaxWindowBits;\n            } else if (this._options.clientMaxWindowBits == null) {\n                params.client_max_window_bits = true;\n            }\n            return params;\n        }\n        /**\n\t   * Accept an extension negotiation offer/response.\n\t   *\n\t   * @param {Array} configurations The extension negotiation offers/reponse\n\t   * @return {Object} Accepted configuration\n\t   * @public\n\t   */ accept(configurations) {\n            configurations = this.normalizeParams(configurations);\n            this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n            return this.params;\n        }\n        /**\n\t   * Releases all resources used by the extension.\n\t   *\n\t   * @public\n\t   */ cleanup() {\n            if (this._inflate) {\n                this._inflate.close();\n                this._inflate = null;\n            }\n            if (this._deflate) {\n                const callback = this._deflate[kCallback];\n                this._deflate.close();\n                this._deflate = null;\n                if (callback) {\n                    callback(new Error('The deflate stream was closed while data was being processed'));\n                }\n            }\n        }\n        /**\n\t   *  Accept an extension negotiation offer.\n\t   *\n\t   * @param {Array} offers The extension negotiation offers\n\t   * @return {Object} Accepted configuration\n\t   * @private\n\t   */ acceptAsServer(offers) {\n            const opts = this._options;\n            const accepted = offers.find((params)=>{\n                if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === 'number' && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {\n                    return false;\n                }\n                return true;\n            });\n            if (!accepted) {\n                throw new Error('None of the extension offers can be accepted');\n            }\n            if (opts.serverNoContextTakeover) {\n                accepted.server_no_context_takeover = true;\n            }\n            if (opts.clientNoContextTakeover) {\n                accepted.client_no_context_takeover = true;\n            }\n            if (typeof opts.serverMaxWindowBits === 'number') {\n                accepted.server_max_window_bits = opts.serverMaxWindowBits;\n            }\n            if (typeof opts.clientMaxWindowBits === 'number') {\n                accepted.client_max_window_bits = opts.clientMaxWindowBits;\n            } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n                delete accepted.client_max_window_bits;\n            }\n            return accepted;\n        }\n        /**\n\t   * Accept the extension negotiation response.\n\t   *\n\t   * @param {Array} response The extension negotiation response\n\t   * @return {Object} Accepted configuration\n\t   * @private\n\t   */ acceptAsClient(response) {\n            const params = response[0];\n            if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n                throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n            }\n            if (!params.client_max_window_bits) {\n                if (typeof this._options.clientMaxWindowBits === 'number') {\n                    params.client_max_window_bits = this._options.clientMaxWindowBits;\n                }\n            } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === 'number' && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n                throw new Error('Unexpected or invalid parameter \"client_max_window_bits\"');\n            }\n            return params;\n        }\n        /**\n\t   * Normalize parameters.\n\t   *\n\t   * @param {Array} configurations The extension negotiation offers/reponse\n\t   * @return {Array} The offers/response with normalized parameters\n\t   * @private\n\t   */ normalizeParams(configurations) {\n            configurations.forEach((params)=>{\n                Object.keys(params).forEach((key)=>{\n                    let value = params[key];\n                    if (value.length > 1) {\n                        throw new Error(`Parameter \"${key}\" must have only a single value`);\n                    }\n                    value = value[0];\n                    if (key === 'client_max_window_bits') {\n                        if (value !== true) {\n                            const num = +value;\n                            if (!Number.isInteger(num) || num < 8 || num > 15) {\n                                throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                            }\n                            value = num;\n                        } else if (!this._isServer) {\n                            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                        }\n                    } else if (key === 'server_max_window_bits') {\n                        const num = +value;\n                        if (!Number.isInteger(num) || num < 8 || num > 15) {\n                            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                        }\n                        value = num;\n                    } else if (key === 'client_no_context_takeover' || key === 'server_no_context_takeover') {\n                        if (value !== true) {\n                            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                        }\n                    } else {\n                        throw new Error(`Unknown parameter \"${key}\"`);\n                    }\n                    params[key] = value;\n                });\n            });\n            return configurations;\n        }\n        /**\n\t   * Decompress data. Concurrency limited.\n\t   *\n\t   * @param {Buffer} data Compressed data\n\t   * @param {Boolean} fin Specifies whether or not this is the last fragment\n\t   * @param {Function} callback Callback\n\t   * @public\n\t   */ decompress(data, fin, callback) {\n            zlibLimiter.add((done)=>{\n                this._decompress(data, fin, (err, result)=>{\n                    done();\n                    callback(err, result);\n                });\n            });\n        }\n        /**\n\t   * Compress data. Concurrency limited.\n\t   *\n\t   * @param {(Buffer|String)} data Data to compress\n\t   * @param {Boolean} fin Specifies whether or not this is the last fragment\n\t   * @param {Function} callback Callback\n\t   * @public\n\t   */ compress(data, fin, callback) {\n            zlibLimiter.add((done)=>{\n                this._compress(data, fin, (err, result)=>{\n                    done();\n                    callback(err, result);\n                });\n            });\n        }\n        /**\n\t   * Decompress data.\n\t   *\n\t   * @param {Buffer} data Compressed data\n\t   * @param {Boolean} fin Specifies whether or not this is the last fragment\n\t   * @param {Function} callback Callback\n\t   * @private\n\t   */ _decompress(data, fin, callback) {\n            const endpoint = this._isServer ? 'client' : 'server';\n            if (!this._inflate) {\n                const key = `${endpoint}_max_window_bits`;\n                const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n                this._inflate = zlib.createInflateRaw({\n                    ...this._options.zlibInflateOptions,\n                    windowBits\n                });\n                this._inflate[kPerMessageDeflate] = this;\n                this._inflate[kTotalLength] = 0;\n                this._inflate[kBuffers] = [];\n                this._inflate.on('error', inflateOnError);\n                this._inflate.on('data', inflateOnData);\n            }\n            this._inflate[kCallback] = callback;\n            this._inflate.write(data);\n            if (fin) this._inflate.write(TRAILER);\n            this._inflate.flush(()=>{\n                const err = this._inflate[kError];\n                if (err) {\n                    this._inflate.close();\n                    this._inflate = null;\n                    callback(err);\n                    return;\n                }\n                const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);\n                if (this._inflate._readableState.endEmitted) {\n                    this._inflate.close();\n                    this._inflate = null;\n                } else {\n                    this._inflate[kTotalLength] = 0;\n                    this._inflate[kBuffers] = [];\n                    if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n                        this._inflate.reset();\n                    }\n                }\n                callback(null, data);\n            });\n        }\n        /**\n\t   * Compress data.\n\t   *\n\t   * @param {(Buffer|String)} data Data to compress\n\t   * @param {Boolean} fin Specifies whether or not this is the last fragment\n\t   * @param {Function} callback Callback\n\t   * @private\n\t   */ _compress(data, fin, callback) {\n            const endpoint = this._isServer ? 'server' : 'client';\n            if (!this._deflate) {\n                const key = `${endpoint}_max_window_bits`;\n                const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n                this._deflate = zlib.createDeflateRaw({\n                    ...this._options.zlibDeflateOptions,\n                    windowBits\n                });\n                this._deflate[kTotalLength] = 0;\n                this._deflate[kBuffers] = [];\n                this._deflate.on('data', deflateOnData);\n            }\n            this._deflate[kCallback] = callback;\n            this._deflate.write(data);\n            this._deflate.flush(zlib.Z_SYNC_FLUSH, ()=>{\n                if (!this._deflate) {\n                    //\n                    // The deflate stream was closed while data was being processed.\n                    //\n                    return;\n                }\n                let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);\n                if (fin) {\n                    data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\n                }\n                //\n                // Ensure that the callback will not be called again in\n                // `PerMessageDeflate#cleanup()`.\n                //\n                this._deflate[kCallback] = null;\n                this._deflate[kTotalLength] = 0;\n                this._deflate[kBuffers] = [];\n                if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n                    this._deflate.reset();\n                }\n                callback(null, data);\n            });\n        }\n    }\n    permessageDeflate = PerMessageDeflate;\n    /**\n\t * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n\t *\n\t * @param {Buffer} chunk A chunk of data\n\t * @private\n\t */ function deflateOnData(chunk) {\n        this[kBuffers].push(chunk);\n        this[kTotalLength] += chunk.length;\n    }\n    /**\n\t * The listener of the `zlib.InflateRaw` stream `'data'` event.\n\t *\n\t * @param {Buffer} chunk A chunk of data\n\t * @private\n\t */ function inflateOnData(chunk) {\n        this[kTotalLength] += chunk.length;\n        if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n            this[kBuffers].push(chunk);\n            return;\n        }\n        this[kError] = new RangeError('Max payload size exceeded');\n        this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n        this[kError][kStatusCode] = 1009;\n        this.removeListener('data', inflateOnData);\n        this.reset();\n    }\n    /**\n\t * The listener of the `zlib.InflateRaw` stream `'error'` event.\n\t *\n\t * @param {Error} err The emitted error\n\t * @private\n\t */ function inflateOnError(err) {\n        //\n        // There is no need to call `Zlib#close()` as the handle is automatically\n        // closed when an error is emitted.\n        //\n        this[kPerMessageDeflate]._inflate = null;\n        err[kStatusCode] = 1007;\n        this[kCallback](err);\n    }\n    return permessageDeflate;\n}\nvar validation = {\n    exports: {}\n};\nvar hasRequiredValidation;\nfunction requireValidation() {\n    if (hasRequiredValidation) return validation.exports;\n    hasRequiredValidation = 1;\n    const { isUtf8 } = buffer__WEBPACK_IMPORTED_MODULE_2__;\n    const { hasBlob } = requireConstants();\n    //\n    // Allowed token characters:\n    //\n    // '!', '#', '$', '%', '&', ''', '*', '+', '-',\n    // '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n    //\n    // tokenChars[32] === 0 // ' '\n    // tokenChars[33] === 1 // '!'\n    // tokenChars[34] === 0 // '\"'\n    // ...\n    //\n    // prettier-ignore\n    const tokenChars = [\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        0,\n        0,\n        1,\n        1,\n        0,\n        1,\n        1,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        0,\n        0,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        0,\n        1,\n        0,\n        1,\n        0 // 112 - 127\n    ];\n    /**\n\t * Checks if a status code is allowed in a close frame.\n\t *\n\t * @param {Number} code The status code\n\t * @return {Boolean} `true` if the status code is valid, else `false`\n\t * @public\n\t */ function isValidStatusCode(code) {\n        return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;\n    }\n    /**\n\t * Checks if a given buffer contains only correct UTF-8.\n\t * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n\t * Markus Kuhn.\n\t *\n\t * @param {Buffer} buf The buffer to check\n\t * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n\t * @public\n\t */ function _isValidUTF8(buf) {\n        const len = buf.length;\n        let i = 0;\n        while(i < len){\n            if ((buf[i] & 0x80) === 0) {\n                // 0xxxxxxx\n                i++;\n            } else if ((buf[i] & 0xe0) === 0xc0) {\n                // 110xxxxx 10xxxxxx\n                if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong\n                ) {\n                    return false;\n                }\n                i += 2;\n            } else if ((buf[i] & 0xf0) === 0xe0) {\n                // 1110xxxx 10xxxxxx 10xxxxxx\n                if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || // Overlong\n                buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)\n                ) {\n                    return false;\n                }\n                i += 3;\n            } else if ((buf[i] & 0xf8) === 0xf0) {\n                // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n                if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || // Overlong\n                buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF\n                ) {\n                    return false;\n                }\n                i += 4;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n\t * Determines whether a value is a `Blob`.\n\t *\n\t * @param {*} value The value to be tested\n\t * @return {Boolean} `true` if `value` is a `Blob`, else `false`\n\t * @private\n\t */ function isBlob(value) {\n        return hasBlob && typeof value === 'object' && typeof value.arrayBuffer === 'function' && typeof value.type === 'string' && typeof value.stream === 'function' && (value[Symbol.toStringTag] === 'Blob' || value[Symbol.toStringTag] === 'File');\n    }\n    validation.exports = {\n        isBlob,\n        isValidStatusCode,\n        isValidUTF8: _isValidUTF8,\n        tokenChars\n    };\n    if (isUtf8) {\n        validation.exports.isValidUTF8 = function(buf) {\n            return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n        };\n    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n        try {\n            const isValidUTF8 = require('utf-8-validate');\n            validation.exports.isValidUTF8 = function(buf) {\n                return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n            };\n        } catch (e) {\n        // Continue regardless of the error.\n        }\n    }\n    return validation.exports;\n}\nvar receiver;\nvar hasRequiredReceiver;\nfunction requireReceiver() {\n    if (hasRequiredReceiver) return receiver;\n    hasRequiredReceiver = 1;\n    const { Writable } = stream__WEBPACK_IMPORTED_MODULE_0__;\n    const PerMessageDeflate = requirePermessageDeflate();\n    const { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = requireConstants();\n    const { concat, toArrayBuffer, unmask } = requireBufferUtil();\n    const { isValidStatusCode, isValidUTF8 } = requireValidation();\n    const FastBuffer = Buffer[Symbol.species];\n    const GET_INFO = 0;\n    const GET_PAYLOAD_LENGTH_16 = 1;\n    const GET_PAYLOAD_LENGTH_64 = 2;\n    const GET_MASK = 3;\n    const GET_DATA = 4;\n    const INFLATING = 5;\n    const DEFER_EVENT = 6;\n    /**\n\t * HyBi Receiver implementation.\n\t *\n\t * @extends Writable\n\t */ class Receiver extends Writable {\n        /**\n\t   * Creates a Receiver instance.\n\t   *\n\t   * @param {Object} [options] Options object\n\t   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n\t   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n\t   *     multiple times in the same tick\n\t   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n\t   * @param {Object} [options.extensions] An object containing the negotiated\n\t   *     extensions\n\t   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n\t   *     client or server mode\n\t   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n\t   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n\t   *     not to skip UTF-8 validation for text and close messages\n\t   */ constructor(options = {}){\n            super();\n            this._allowSynchronousEvents = options.allowSynchronousEvents !== undefined ? options.allowSynchronousEvents : true;\n            this._binaryType = options.binaryType || BINARY_TYPES[0];\n            this._extensions = options.extensions || {};\n            this._isServer = !!options.isServer;\n            this._maxPayload = options.maxPayload | 0;\n            this._skipUTF8Validation = !!options.skipUTF8Validation;\n            this[kWebSocket] = undefined;\n            this._bufferedBytes = 0;\n            this._buffers = [];\n            this._compressed = false;\n            this._payloadLength = 0;\n            this._mask = undefined;\n            this._fragmented = 0;\n            this._masked = false;\n            this._fin = false;\n            this._opcode = 0;\n            this._totalPayloadLength = 0;\n            this._messageLength = 0;\n            this._fragments = [];\n            this._errored = false;\n            this._loop = false;\n            this._state = GET_INFO;\n        }\n        /**\n\t   * Implements `Writable.prototype._write()`.\n\t   *\n\t   * @param {Buffer} chunk The chunk of data to write\n\t   * @param {String} encoding The character encoding of `chunk`\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ _write(chunk, encoding, cb) {\n            if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n            this._bufferedBytes += chunk.length;\n            this._buffers.push(chunk);\n            this.startLoop(cb);\n        }\n        /**\n\t   * Consumes `n` bytes from the buffered data.\n\t   *\n\t   * @param {Number} n The number of bytes to consume\n\t   * @return {Buffer} The consumed bytes\n\t   * @private\n\t   */ consume(n) {\n            this._bufferedBytes -= n;\n            if (n === this._buffers[0].length) return this._buffers.shift();\n            if (n < this._buffers[0].length) {\n                const buf = this._buffers[0];\n                this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n                return new FastBuffer(buf.buffer, buf.byteOffset, n);\n            }\n            const dst = Buffer.allocUnsafe(n);\n            do {\n                const buf = this._buffers[0];\n                const offset = dst.length - n;\n                if (n >= buf.length) {\n                    dst.set(this._buffers.shift(), offset);\n                } else {\n                    dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n                    this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n                }\n                n -= buf.length;\n            }while (n > 0);\n            return dst;\n        }\n        /**\n\t   * Starts the parsing loop.\n\t   *\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ startLoop(cb) {\n            this._loop = true;\n            do {\n                switch(this._state){\n                    case GET_INFO:\n                        this.getInfo(cb);\n                        break;\n                    case GET_PAYLOAD_LENGTH_16:\n                        this.getPayloadLength16(cb);\n                        break;\n                    case GET_PAYLOAD_LENGTH_64:\n                        this.getPayloadLength64(cb);\n                        break;\n                    case GET_MASK:\n                        this.getMask();\n                        break;\n                    case GET_DATA:\n                        this.getData(cb);\n                        break;\n                    case INFLATING:\n                    case DEFER_EVENT:\n                        this._loop = false;\n                        return;\n                }\n            }while (this._loop);\n            if (!this._errored) cb();\n        }\n        /**\n\t   * Reads the first two bytes of a frame.\n\t   *\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ getInfo(cb) {\n            if (this._bufferedBytes < 2) {\n                this._loop = false;\n                return;\n            }\n            const buf = this.consume(2);\n            if ((buf[0] & 0x30) !== 0x00) {\n                const error = this.createError(RangeError, 'RSV2 and RSV3 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_2_3');\n                cb(error);\n                return;\n            }\n            const compressed = (buf[0] & 0x40) === 0x40;\n            if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n                const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n                cb(error);\n                return;\n            }\n            this._fin = (buf[0] & 0x80) === 0x80;\n            this._opcode = buf[0] & 0x0f;\n            this._payloadLength = buf[1] & 0x7f;\n            if (this._opcode === 0x00) {\n                if (compressed) {\n                    const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n                    cb(error);\n                    return;\n                }\n                if (!this._fragmented) {\n                    const error = this.createError(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');\n                    cb(error);\n                    return;\n                }\n                this._opcode = this._fragmented;\n            } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n                if (this._fragmented) {\n                    const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');\n                    cb(error);\n                    return;\n                }\n                this._compressed = compressed;\n            } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n                if (!this._fin) {\n                    const error = this.createError(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');\n                    cb(error);\n                    return;\n                }\n                if (compressed) {\n                    const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n                    cb(error);\n                    return;\n                }\n                if (this._payloadLength > 0x7d || this._opcode === 0x08 && this._payloadLength === 1) {\n                    const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');\n                    cb(error);\n                    return;\n                }\n            } else {\n                const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');\n                cb(error);\n                return;\n            }\n            if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n            this._masked = (buf[1] & 0x80) === 0x80;\n            if (this._isServer) {\n                if (!this._masked) {\n                    const error = this.createError(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');\n                    cb(error);\n                    return;\n                }\n            } else if (this._masked) {\n                const error = this.createError(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');\n                cb(error);\n                return;\n            }\n            if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n            else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n            else this.haveLength(cb);\n        }\n        /**\n\t   * Gets extended payload length (7+16).\n\t   *\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ getPayloadLength16(cb) {\n            if (this._bufferedBytes < 2) {\n                this._loop = false;\n                return;\n            }\n            this._payloadLength = this.consume(2).readUInt16BE(0);\n            this.haveLength(cb);\n        }\n        /**\n\t   * Gets extended payload length (7+64).\n\t   *\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ getPayloadLength64(cb) {\n            if (this._bufferedBytes < 8) {\n                this._loop = false;\n                return;\n            }\n            const buf = this.consume(8);\n            const num = buf.readUInt32BE(0);\n            //\n            // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n            // if payload length is greater than this number.\n            //\n            if (num > Math.pow(2, 53 - 32) - 1) {\n                const error = this.createError(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');\n                cb(error);\n                return;\n            }\n            this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n            this.haveLength(cb);\n        }\n        /**\n\t   * Payload length has been read.\n\t   *\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ haveLength(cb) {\n            if (this._payloadLength && this._opcode < 0x08) {\n                this._totalPayloadLength += this._payloadLength;\n                if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n                    const error = this.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n                    cb(error);\n                    return;\n                }\n            }\n            if (this._masked) this._state = GET_MASK;\n            else this._state = GET_DATA;\n        }\n        /**\n\t   * Reads mask bytes.\n\t   *\n\t   * @private\n\t   */ getMask() {\n            if (this._bufferedBytes < 4) {\n                this._loop = false;\n                return;\n            }\n            this._mask = this.consume(4);\n            this._state = GET_DATA;\n        }\n        /**\n\t   * Reads data bytes.\n\t   *\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ getData(cb) {\n            let data = EMPTY_BUFFER;\n            if (this._payloadLength) {\n                if (this._bufferedBytes < this._payloadLength) {\n                    this._loop = false;\n                    return;\n                }\n                data = this.consume(this._payloadLength);\n                if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\n                    unmask(data, this._mask);\n                }\n            }\n            if (this._opcode > 0x07) {\n                this.controlMessage(data, cb);\n                return;\n            }\n            if (this._compressed) {\n                this._state = INFLATING;\n                this.decompress(data, cb);\n                return;\n            }\n            if (data.length) {\n                //\n                // This message is not compressed so its length is the sum of the payload\n                // length of all fragments.\n                //\n                this._messageLength = this._totalPayloadLength;\n                this._fragments.push(data);\n            }\n            this.dataMessage(cb);\n        }\n        /**\n\t   * Decompresses data.\n\t   *\n\t   * @param {Buffer} data Compressed data\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ decompress(data, cb) {\n            const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n            perMessageDeflate.decompress(data, this._fin, (err, buf)=>{\n                if (err) return cb(err);\n                if (buf.length) {\n                    this._messageLength += buf.length;\n                    if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n                        const error = this.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n                        cb(error);\n                        return;\n                    }\n                    this._fragments.push(buf);\n                }\n                this.dataMessage(cb);\n                if (this._state === GET_INFO) this.startLoop(cb);\n            });\n        }\n        /**\n\t   * Handles a data message.\n\t   *\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ dataMessage(cb) {\n            if (!this._fin) {\n                this._state = GET_INFO;\n                return;\n            }\n            const messageLength = this._messageLength;\n            const fragments = this._fragments;\n            this._totalPayloadLength = 0;\n            this._messageLength = 0;\n            this._fragmented = 0;\n            this._fragments = [];\n            if (this._opcode === 2) {\n                let data;\n                if (this._binaryType === 'nodebuffer') {\n                    data = concat(fragments, messageLength);\n                } else if (this._binaryType === 'arraybuffer') {\n                    data = toArrayBuffer(concat(fragments, messageLength));\n                } else if (this._binaryType === 'blob') {\n                    data = new Blob(fragments);\n                } else {\n                    data = fragments;\n                }\n                if (this._allowSynchronousEvents) {\n                    this.emit('message', data, true);\n                    this._state = GET_INFO;\n                } else {\n                    this._state = DEFER_EVENT;\n                    setImmediate(()=>{\n                        this.emit('message', data, true);\n                        this._state = GET_INFO;\n                        this.startLoop(cb);\n                    });\n                }\n            } else {\n                const buf = concat(fragments, messageLength);\n                if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n                    const error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');\n                    cb(error);\n                    return;\n                }\n                if (this._state === INFLATING || this._allowSynchronousEvents) {\n                    this.emit('message', buf, false);\n                    this._state = GET_INFO;\n                } else {\n                    this._state = DEFER_EVENT;\n                    setImmediate(()=>{\n                        this.emit('message', buf, false);\n                        this._state = GET_INFO;\n                        this.startLoop(cb);\n                    });\n                }\n            }\n        }\n        /**\n\t   * Handles a control message.\n\t   *\n\t   * @param {Buffer} data Data to handle\n\t   * @return {(Error|RangeError|undefined)} A possible error\n\t   * @private\n\t   */ controlMessage(data, cb) {\n            if (this._opcode === 0x08) {\n                if (data.length === 0) {\n                    this._loop = false;\n                    this.emit('conclude', 1005, EMPTY_BUFFER);\n                    this.end();\n                } else {\n                    const code = data.readUInt16BE(0);\n                    if (!isValidStatusCode(code)) {\n                        const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, 'WS_ERR_INVALID_CLOSE_CODE');\n                        cb(error);\n                        return;\n                    }\n                    const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);\n                    if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n                        const error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');\n                        cb(error);\n                        return;\n                    }\n                    this._loop = false;\n                    this.emit('conclude', code, buf);\n                    this.end();\n                }\n                this._state = GET_INFO;\n                return;\n            }\n            if (this._allowSynchronousEvents) {\n                this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n                this._state = GET_INFO;\n            } else {\n                this._state = DEFER_EVENT;\n                setImmediate(()=>{\n                    this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n                    this._state = GET_INFO;\n                    this.startLoop(cb);\n                });\n            }\n        }\n        /**\n\t   * Builds an error object.\n\t   *\n\t   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n\t   * @param {String} message The error message\n\t   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n\t   *     `message`\n\t   * @param {Number} statusCode The status code\n\t   * @param {String} errorCode The exposed error code\n\t   * @return {(Error|RangeError)} The error\n\t   * @private\n\t   */ createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n            this._loop = false;\n            this._errored = true;\n            const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);\n            Error.captureStackTrace(err, this.createError);\n            err.code = errorCode;\n            err[kStatusCode] = statusCode;\n            return err;\n        }\n    }\n    receiver = Receiver;\n    return receiver;\n}\nrequireReceiver();\n/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */ var sender;\nvar hasRequiredSender;\nfunction requireSender() {\n    if (hasRequiredSender) return sender;\n    hasRequiredSender = 1;\n    const { randomFillSync } = crypto__WEBPACK_IMPORTED_MODULE_3__;\n    const PerMessageDeflate = requirePermessageDeflate();\n    const { EMPTY_BUFFER, kWebSocket, NOOP } = requireConstants();\n    const { isBlob, isValidStatusCode } = requireValidation();\n    const { mask: applyMask, toBuffer } = requireBufferUtil();\n    const kByteLength = Symbol('kByteLength');\n    const maskBuffer = Buffer.alloc(4);\n    const RANDOM_POOL_SIZE = 8 * 1024;\n    let randomPool;\n    let randomPoolPointer = RANDOM_POOL_SIZE;\n    const DEFAULT = 0;\n    const DEFLATING = 1;\n    const GET_BLOB_DATA = 2;\n    /**\n\t * HyBi Sender implementation.\n\t */ class Sender {\n        /**\n\t   * Creates a Sender instance.\n\t   *\n\t   * @param {Duplex} socket The connection socket\n\t   * @param {Object} [extensions] An object containing the negotiated extensions\n\t   * @param {Function} [generateMask] The function used to generate the masking\n\t   *     key\n\t   */ constructor(socket, extensions, generateMask){\n            this._extensions = extensions || {};\n            if (generateMask) {\n                this._generateMask = generateMask;\n                this._maskBuffer = Buffer.alloc(4);\n            }\n            this._socket = socket;\n            this._firstFragment = true;\n            this._compress = false;\n            this._bufferedBytes = 0;\n            this._queue = [];\n            this._state = DEFAULT;\n            this.onerror = NOOP;\n            this[kWebSocket] = undefined;\n        }\n        /**\n\t   * Frames a piece of data according to the HyBi WebSocket protocol.\n\t   *\n\t   * @param {(Buffer|String)} data The data to frame\n\t   * @param {Object} options Options object\n\t   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n\t   *     FIN bit\n\t   * @param {Function} [options.generateMask] The function used to generate the\n\t   *     masking key\n\t   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n\t   *     `data`\n\t   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n\t   *     key\n\t   * @param {Number} options.opcode The opcode\n\t   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n\t   *     modified\n\t   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n\t   *     RSV1 bit\n\t   * @return {(Buffer|String)[]} The framed data\n\t   * @public\n\t   */ static frame(data, options) {\n            let mask;\n            let merge = false;\n            let offset = 2;\n            let skipMasking = false;\n            if (options.mask) {\n                mask = options.maskBuffer || maskBuffer;\n                if (options.generateMask) {\n                    options.generateMask(mask);\n                } else {\n                    if (randomPoolPointer === RANDOM_POOL_SIZE) {\n                        /* istanbul ignore else  */ if (randomPool === undefined) {\n                            //\n                            // This is lazily initialized because server-sent frames must not\n                            // be masked so it may never be used.\n                            //\n                            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n                        }\n                        randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n                        randomPoolPointer = 0;\n                    }\n                    mask[0] = randomPool[randomPoolPointer++];\n                    mask[1] = randomPool[randomPoolPointer++];\n                    mask[2] = randomPool[randomPoolPointer++];\n                    mask[3] = randomPool[randomPoolPointer++];\n                }\n                skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n                offset = 6;\n            }\n            let dataLength;\n            if (typeof data === 'string') {\n                if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n                    dataLength = options[kByteLength];\n                } else {\n                    data = Buffer.from(data);\n                    dataLength = data.length;\n                }\n            } else {\n                dataLength = data.length;\n                merge = options.mask && options.readOnly && !skipMasking;\n            }\n            let payloadLength = dataLength;\n            if (dataLength >= 65536) {\n                offset += 8;\n                payloadLength = 127;\n            } else if (dataLength > 125) {\n                offset += 2;\n                payloadLength = 126;\n            }\n            const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n            target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n            if (options.rsv1) target[0] |= 0x40;\n            target[1] = payloadLength;\n            if (payloadLength === 126) {\n                target.writeUInt16BE(dataLength, 2);\n            } else if (payloadLength === 127) {\n                target[2] = target[3] = 0;\n                target.writeUIntBE(dataLength, 4, 6);\n            }\n            if (!options.mask) return [\n                target,\n                data\n            ];\n            target[1] |= 0x80;\n            target[offset - 4] = mask[0];\n            target[offset - 3] = mask[1];\n            target[offset - 2] = mask[2];\n            target[offset - 1] = mask[3];\n            if (skipMasking) return [\n                target,\n                data\n            ];\n            if (merge) {\n                applyMask(data, mask, target, offset, dataLength);\n                return [\n                    target\n                ];\n            }\n            applyMask(data, mask, data, 0, dataLength);\n            return [\n                target,\n                data\n            ];\n        }\n        /**\n\t   * Sends a close message to the other peer.\n\t   *\n\t   * @param {Number} [code] The status code component of the body\n\t   * @param {(String|Buffer)} [data] The message component of the body\n\t   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n\t   * @param {Function} [cb] Callback\n\t   * @public\n\t   */ close(code, data, mask, cb) {\n            let buf;\n            if (code === undefined) {\n                buf = EMPTY_BUFFER;\n            } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n                throw new TypeError('First argument must be a valid error code number');\n            } else if (data === undefined || !data.length) {\n                buf = Buffer.allocUnsafe(2);\n                buf.writeUInt16BE(code, 0);\n            } else {\n                const length = Buffer.byteLength(data);\n                if (length > 123) {\n                    throw new RangeError('The message must not be greater than 123 bytes');\n                }\n                buf = Buffer.allocUnsafe(2 + length);\n                buf.writeUInt16BE(code, 0);\n                if (typeof data === 'string') {\n                    buf.write(data, 2);\n                } else {\n                    buf.set(data, 2);\n                }\n            }\n            const options = {\n                [kByteLength]: buf.length,\n                fin: true,\n                generateMask: this._generateMask,\n                mask,\n                maskBuffer: this._maskBuffer,\n                opcode: 0x08,\n                readOnly: false,\n                rsv1: false\n            };\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.dispatch,\n                    buf,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.sendFrame(Sender.frame(buf, options), cb);\n            }\n        }\n        /**\n\t   * Sends a ping message to the other peer.\n\t   *\n\t   * @param {*} data The message to send\n\t   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n\t   * @param {Function} [cb] Callback\n\t   * @public\n\t   */ ping(data, mask, cb) {\n            let byteLength;\n            let readOnly;\n            if (typeof data === 'string') {\n                byteLength = Buffer.byteLength(data);\n                readOnly = false;\n            } else if (isBlob(data)) {\n                byteLength = data.size;\n                readOnly = false;\n            } else {\n                data = toBuffer(data);\n                byteLength = data.length;\n                readOnly = toBuffer.readOnly;\n            }\n            if (byteLength > 125) {\n                throw new RangeError('The data size must not be greater than 125 bytes');\n            }\n            const options = {\n                [kByteLength]: byteLength,\n                fin: true,\n                generateMask: this._generateMask,\n                mask,\n                maskBuffer: this._maskBuffer,\n                opcode: 0x09,\n                readOnly,\n                rsv1: false\n            };\n            if (isBlob(data)) {\n                if (this._state !== DEFAULT) {\n                    this.enqueue([\n                        this.getBlobData,\n                        data,\n                        false,\n                        options,\n                        cb\n                    ]);\n                } else {\n                    this.getBlobData(data, false, options, cb);\n                }\n            } else if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.dispatch,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.sendFrame(Sender.frame(data, options), cb);\n            }\n        }\n        /**\n\t   * Sends a pong message to the other peer.\n\t   *\n\t   * @param {*} data The message to send\n\t   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n\t   * @param {Function} [cb] Callback\n\t   * @public\n\t   */ pong(data, mask, cb) {\n            let byteLength;\n            let readOnly;\n            if (typeof data === 'string') {\n                byteLength = Buffer.byteLength(data);\n                readOnly = false;\n            } else if (isBlob(data)) {\n                byteLength = data.size;\n                readOnly = false;\n            } else {\n                data = toBuffer(data);\n                byteLength = data.length;\n                readOnly = toBuffer.readOnly;\n            }\n            if (byteLength > 125) {\n                throw new RangeError('The data size must not be greater than 125 bytes');\n            }\n            const options = {\n                [kByteLength]: byteLength,\n                fin: true,\n                generateMask: this._generateMask,\n                mask,\n                maskBuffer: this._maskBuffer,\n                opcode: 0x0a,\n                readOnly,\n                rsv1: false\n            };\n            if (isBlob(data)) {\n                if (this._state !== DEFAULT) {\n                    this.enqueue([\n                        this.getBlobData,\n                        data,\n                        false,\n                        options,\n                        cb\n                    ]);\n                } else {\n                    this.getBlobData(data, false, options, cb);\n                }\n            } else if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.dispatch,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.sendFrame(Sender.frame(data, options), cb);\n            }\n        }\n        /**\n\t   * Sends a data message to the other peer.\n\t   *\n\t   * @param {*} data The message to send\n\t   * @param {Object} options Options object\n\t   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n\t   *     or text\n\t   * @param {Boolean} [options.compress=false] Specifies whether or not to\n\t   *     compress `data`\n\t   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n\t   *     last one\n\t   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n\t   *     `data`\n\t   * @param {Function} [cb] Callback\n\t   * @public\n\t   */ send(data, options, cb) {\n            const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n            let opcode = options.binary ? 2 : 1;\n            let rsv1 = options.compress;\n            let byteLength;\n            let readOnly;\n            if (typeof data === 'string') {\n                byteLength = Buffer.byteLength(data);\n                readOnly = false;\n            } else if (isBlob(data)) {\n                byteLength = data.size;\n                readOnly = false;\n            } else {\n                data = toBuffer(data);\n                byteLength = data.length;\n                readOnly = toBuffer.readOnly;\n            }\n            if (this._firstFragment) {\n                this._firstFragment = false;\n                if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) {\n                    rsv1 = byteLength >= perMessageDeflate._threshold;\n                }\n                this._compress = rsv1;\n            } else {\n                rsv1 = false;\n                opcode = 0;\n            }\n            if (options.fin) this._firstFragment = true;\n            const opts = {\n                [kByteLength]: byteLength,\n                fin: options.fin,\n                generateMask: this._generateMask,\n                mask: options.mask,\n                maskBuffer: this._maskBuffer,\n                opcode,\n                readOnly,\n                rsv1\n            };\n            if (isBlob(data)) {\n                if (this._state !== DEFAULT) {\n                    this.enqueue([\n                        this.getBlobData,\n                        data,\n                        this._compress,\n                        opts,\n                        cb\n                    ]);\n                } else {\n                    this.getBlobData(data, this._compress, opts, cb);\n                }\n            } else if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.dispatch,\n                    data,\n                    this._compress,\n                    opts,\n                    cb\n                ]);\n            } else {\n                this.dispatch(data, this._compress, opts, cb);\n            }\n        }\n        /**\n\t   * Gets the contents of a blob as binary data.\n\t   *\n\t   * @param {Blob} blob The blob\n\t   * @param {Boolean} [compress=false] Specifies whether or not to compress\n\t   *     the data\n\t   * @param {Object} options Options object\n\t   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n\t   *     FIN bit\n\t   * @param {Function} [options.generateMask] The function used to generate the\n\t   *     masking key\n\t   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n\t   *     `data`\n\t   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n\t   *     key\n\t   * @param {Number} options.opcode The opcode\n\t   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n\t   *     modified\n\t   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n\t   *     RSV1 bit\n\t   * @param {Function} [cb] Callback\n\t   * @private\n\t   */ getBlobData(blob, compress, options, cb) {\n            this._bufferedBytes += options[kByteLength];\n            this._state = GET_BLOB_DATA;\n            blob.arrayBuffer().then((arrayBuffer)=>{\n                if (this._socket.destroyed) {\n                    const err = new Error('The socket was closed while the blob was being read');\n                    //\n                    // `callCallbacks` is called in the next tick to ensure that errors\n                    // that might be thrown in the callbacks behave like errors thrown\n                    // outside the promise chain.\n                    //\n                    process.nextTick(callCallbacks, this, err, cb);\n                    return;\n                }\n                this._bufferedBytes -= options[kByteLength];\n                const data = toBuffer(arrayBuffer);\n                if (!compress) {\n                    this._state = DEFAULT;\n                    this.sendFrame(Sender.frame(data, options), cb);\n                    this.dequeue();\n                } else {\n                    this.dispatch(data, compress, options, cb);\n                }\n            }).catch((err)=>{\n                //\n                // `onError` is called in the next tick for the same reason that\n                // `callCallbacks` above is.\n                //\n                process.nextTick(onError, this, err, cb);\n            });\n        }\n        /**\n\t   * Dispatches a message.\n\t   *\n\t   * @param {(Buffer|String)} data The message to send\n\t   * @param {Boolean} [compress=false] Specifies whether or not to compress\n\t   *     `data`\n\t   * @param {Object} options Options object\n\t   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n\t   *     FIN bit\n\t   * @param {Function} [options.generateMask] The function used to generate the\n\t   *     masking key\n\t   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n\t   *     `data`\n\t   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n\t   *     key\n\t   * @param {Number} options.opcode The opcode\n\t   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n\t   *     modified\n\t   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n\t   *     RSV1 bit\n\t   * @param {Function} [cb] Callback\n\t   * @private\n\t   */ dispatch(data, compress, options, cb) {\n            if (!compress) {\n                this.sendFrame(Sender.frame(data, options), cb);\n                return;\n            }\n            const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n            this._bufferedBytes += options[kByteLength];\n            this._state = DEFLATING;\n            perMessageDeflate.compress(data, options.fin, (_, buf)=>{\n                if (this._socket.destroyed) {\n                    const err = new Error('The socket was closed while data was being compressed');\n                    callCallbacks(this, err, cb);\n                    return;\n                }\n                this._bufferedBytes -= options[kByteLength];\n                this._state = DEFAULT;\n                options.readOnly = false;\n                this.sendFrame(Sender.frame(buf, options), cb);\n                this.dequeue();\n            });\n        }\n        /**\n\t   * Executes queued send operations.\n\t   *\n\t   * @private\n\t   */ dequeue() {\n            while(this._state === DEFAULT && this._queue.length){\n                const params = this._queue.shift();\n                this._bufferedBytes -= params[3][kByteLength];\n                Reflect.apply(params[0], this, params.slice(1));\n            }\n        }\n        /**\n\t   * Enqueues a send operation.\n\t   *\n\t   * @param {Array} params Send operation parameters.\n\t   * @private\n\t   */ enqueue(params) {\n            this._bufferedBytes += params[3][kByteLength];\n            this._queue.push(params);\n        }\n        /**\n\t   * Sends a frame.\n\t   *\n\t   * @param {Buffer[]} list The frame to send\n\t   * @param {Function} [cb] Callback\n\t   * @private\n\t   */ sendFrame(list, cb) {\n            if (list.length === 2) {\n                this._socket.cork();\n                this._socket.write(list[0]);\n                this._socket.write(list[1], cb);\n                this._socket.uncork();\n            } else {\n                this._socket.write(list[0], cb);\n            }\n        }\n    }\n    sender = Sender;\n    /**\n\t * Calls queued callbacks with an error.\n\t *\n\t * @param {Sender} sender The `Sender` instance\n\t * @param {Error} err The error to call the callbacks with\n\t * @param {Function} [cb] The first callback\n\t * @private\n\t */ function callCallbacks(sender, err, cb) {\n        if (typeof cb === 'function') cb(err);\n        for(let i = 0; i < sender._queue.length; i++){\n            const params = sender._queue[i];\n            const callback = params[params.length - 1];\n            if (typeof callback === 'function') callback(err);\n        }\n    }\n    /**\n\t * Handles a `Sender` error.\n\t *\n\t * @param {Sender} sender The `Sender` instance\n\t * @param {Error} err The error\n\t * @param {Function} [cb] The first pending callback\n\t * @private\n\t */ function onError(sender, err, cb) {\n        callCallbacks(sender, err, cb);\n        sender.onerror(err);\n    }\n    return sender;\n}\nrequireSender();\nvar eventTarget;\nvar hasRequiredEventTarget;\nfunction requireEventTarget() {\n    if (hasRequiredEventTarget) return eventTarget;\n    hasRequiredEventTarget = 1;\n    const { kForOnEventAttribute, kListener } = requireConstants();\n    const kCode = Symbol('kCode');\n    const kData = Symbol('kData');\n    const kError = Symbol('kError');\n    const kMessage = Symbol('kMessage');\n    const kReason = Symbol('kReason');\n    const kTarget = Symbol('kTarget');\n    const kType = Symbol('kType');\n    const kWasClean = Symbol('kWasClean');\n    /**\n\t * Class representing an event.\n\t */ class Event {\n        /**\n\t   * Create a new `Event`.\n\t   *\n\t   * @param {String} type The name of the event\n\t   * @throws {TypeError} If the `type` argument is not specified\n\t   */ constructor(type){\n            this[kTarget] = null;\n            this[kType] = type;\n        }\n        /**\n\t   * @type {*}\n\t   */ get target() {\n            return this[kTarget];\n        }\n        /**\n\t   * @type {String}\n\t   */ get type() {\n            return this[kType];\n        }\n    }\n    Object.defineProperty(Event.prototype, 'target', {\n        enumerable: true\n    });\n    Object.defineProperty(Event.prototype, 'type', {\n        enumerable: true\n    });\n    /**\n\t * Class representing a close event.\n\t *\n\t * @extends Event\n\t */ class CloseEvent extends Event {\n        /**\n\t   * Create a new `CloseEvent`.\n\t   *\n\t   * @param {String} type The name of the event\n\t   * @param {Object} [options] A dictionary object that allows for setting\n\t   *     attributes via object members of the same name\n\t   * @param {Number} [options.code=0] The status code explaining why the\n\t   *     connection was closed\n\t   * @param {String} [options.reason=''] A human-readable string explaining why\n\t   *     the connection was closed\n\t   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n\t   *     connection was cleanly closed\n\t   */ constructor(type, options = {}){\n            super(type);\n            this[kCode] = options.code === undefined ? 0 : options.code;\n            this[kReason] = options.reason === undefined ? '' : options.reason;\n            this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n        }\n        /**\n\t   * @type {Number}\n\t   */ get code() {\n            return this[kCode];\n        }\n        /**\n\t   * @type {String}\n\t   */ get reason() {\n            return this[kReason];\n        }\n        /**\n\t   * @type {Boolean}\n\t   */ get wasClean() {\n            return this[kWasClean];\n        }\n    }\n    Object.defineProperty(CloseEvent.prototype, 'code', {\n        enumerable: true\n    });\n    Object.defineProperty(CloseEvent.prototype, 'reason', {\n        enumerable: true\n    });\n    Object.defineProperty(CloseEvent.prototype, 'wasClean', {\n        enumerable: true\n    });\n    /**\n\t * Class representing an error event.\n\t *\n\t * @extends Event\n\t */ class ErrorEvent extends Event {\n        /**\n\t   * Create a new `ErrorEvent`.\n\t   *\n\t   * @param {String} type The name of the event\n\t   * @param {Object} [options] A dictionary object that allows for setting\n\t   *     attributes via object members of the same name\n\t   * @param {*} [options.error=null] The error that generated this event\n\t   * @param {String} [options.message=''] The error message\n\t   */ constructor(type, options = {}){\n            super(type);\n            this[kError] = options.error === undefined ? null : options.error;\n            this[kMessage] = options.message === undefined ? '' : options.message;\n        }\n        /**\n\t   * @type {*}\n\t   */ get error() {\n            return this[kError];\n        }\n        /**\n\t   * @type {String}\n\t   */ get message() {\n            return this[kMessage];\n        }\n    }\n    Object.defineProperty(ErrorEvent.prototype, 'error', {\n        enumerable: true\n    });\n    Object.defineProperty(ErrorEvent.prototype, 'message', {\n        enumerable: true\n    });\n    /**\n\t * Class representing a message event.\n\t *\n\t * @extends Event\n\t */ class MessageEvent extends Event {\n        /**\n\t   * Create a new `MessageEvent`.\n\t   *\n\t   * @param {String} type The name of the event\n\t   * @param {Object} [options] A dictionary object that allows for setting\n\t   *     attributes via object members of the same name\n\t   * @param {*} [options.data=null] The message content\n\t   */ constructor(type, options = {}){\n            super(type);\n            this[kData] = options.data === undefined ? null : options.data;\n        }\n        /**\n\t   * @type {*}\n\t   */ get data() {\n            return this[kData];\n        }\n    }\n    Object.defineProperty(MessageEvent.prototype, 'data', {\n        enumerable: true\n    });\n    /**\n\t * This provides methods for emulating the `EventTarget` interface. It's not\n\t * meant to be used directly.\n\t *\n\t * @mixin\n\t */ const EventTarget = {\n        /**\n\t   * Register an event listener.\n\t   *\n\t   * @param {String} type A string representing the event type to listen for\n\t   * @param {(Function|Object)} handler The listener to add\n\t   * @param {Object} [options] An options object specifies characteristics about\n\t   *     the event listener\n\t   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n\t   *     listener should be invoked at most once after being added. If `true`,\n\t   *     the listener would be automatically removed when invoked.\n\t   * @public\n\t   */ addEventListener (type, handler, options = {}) {\n            for (const listener of this.listeners(type)){\n                if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n                    return;\n                }\n            }\n            let wrapper;\n            if (type === 'message') {\n                wrapper = function onMessage(data, isBinary) {\n                    const event = new MessageEvent('message', {\n                        data: isBinary ? data : data.toString()\n                    });\n                    event[kTarget] = this;\n                    callListener(handler, this, event);\n                };\n            } else if (type === 'close') {\n                wrapper = function onClose(code, message) {\n                    const event = new CloseEvent('close', {\n                        code,\n                        reason: message.toString(),\n                        wasClean: this._closeFrameReceived && this._closeFrameSent\n                    });\n                    event[kTarget] = this;\n                    callListener(handler, this, event);\n                };\n            } else if (type === 'error') {\n                wrapper = function onError(error) {\n                    const event = new ErrorEvent('error', {\n                        error,\n                        message: error.message\n                    });\n                    event[kTarget] = this;\n                    callListener(handler, this, event);\n                };\n            } else if (type === 'open') {\n                wrapper = function onOpen() {\n                    const event = new Event('open');\n                    event[kTarget] = this;\n                    callListener(handler, this, event);\n                };\n            } else {\n                return;\n            }\n            wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n            wrapper[kListener] = handler;\n            if (options.once) {\n                this.once(type, wrapper);\n            } else {\n                this.on(type, wrapper);\n            }\n        },\n        /**\n\t   * Remove an event listener.\n\t   *\n\t   * @param {String} type A string representing the event type to remove\n\t   * @param {(Function|Object)} handler The listener to remove\n\t   * @public\n\t   */ removeEventListener (type, handler) {\n            for (const listener of this.listeners(type)){\n                if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n                    this.removeListener(type, listener);\n                    break;\n                }\n            }\n        }\n    };\n    eventTarget = {\n        CloseEvent,\n        ErrorEvent,\n        Event,\n        EventTarget,\n        MessageEvent\n    };\n    /**\n\t * Call an event listener\n\t *\n\t * @param {(Function|Object)} listener The listener to call\n\t * @param {*} thisArg The value to use as `this`` when calling the listener\n\t * @param {Event} event The event to pass to the listener\n\t * @private\n\t */ function callListener(listener, thisArg, event) {\n        if (typeof listener === 'object' && listener.handleEvent) {\n            listener.handleEvent.call(listener, event);\n        } else {\n            listener.call(thisArg, event);\n        }\n    }\n    return eventTarget;\n}\nvar extension;\nvar hasRequiredExtension;\nfunction requireExtension() {\n    if (hasRequiredExtension) return extension;\n    hasRequiredExtension = 1;\n    const { tokenChars } = requireValidation();\n    /**\n\t * Adds an offer to the map of extension offers or a parameter to the map of\n\t * parameters.\n\t *\n\t * @param {Object} dest The map of extension offers or parameters\n\t * @param {String} name The extension or parameter name\n\t * @param {(Object|Boolean|String)} elem The extension parameters or the\n\t *     parameter value\n\t * @private\n\t */ function push(dest, name, elem) {\n        if (dest[name] === undefined) dest[name] = [\n            elem\n        ];\n        else dest[name].push(elem);\n    }\n    /**\n\t * Parses the `Sec-WebSocket-Extensions` header into an object.\n\t *\n\t * @param {String} header The field value of the header\n\t * @return {Object} The parsed object\n\t * @public\n\t */ function parse(header) {\n        const offers = Object.create(null);\n        let params = Object.create(null);\n        let mustUnescape = false;\n        let isEscaping = false;\n        let inQuotes = false;\n        let extensionName;\n        let paramName;\n        let start = -1;\n        let code = -1;\n        let end = -1;\n        let i = 0;\n        for(; i < header.length; i++){\n            code = header.charCodeAt(i);\n            if (extensionName === undefined) {\n                if (end === -1 && tokenChars[code] === 1) {\n                    if (start === -1) start = i;\n                } else if (i !== 0 && (code === 0x20 /* ' ' */  || code === 0x09)) {\n                    if (end === -1 && start !== -1) end = i;\n                } else if (code === 0x3b /* ';' */  || code === 0x2c /* ',' */ ) {\n                    if (start === -1) {\n                        throw new SyntaxError(`Unexpected character at index ${i}`);\n                    }\n                    if (end === -1) end = i;\n                    const name = header.slice(start, end);\n                    if (code === 0x2c) {\n                        push(offers, name, params);\n                        params = Object.create(null);\n                    } else {\n                        extensionName = name;\n                    }\n                    start = end = -1;\n                } else {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n            } else if (paramName === undefined) {\n                if (end === -1 && tokenChars[code] === 1) {\n                    if (start === -1) start = i;\n                } else if (code === 0x20 || code === 0x09) {\n                    if (end === -1 && start !== -1) end = i;\n                } else if (code === 0x3b || code === 0x2c) {\n                    if (start === -1) {\n                        throw new SyntaxError(`Unexpected character at index ${i}`);\n                    }\n                    if (end === -1) end = i;\n                    push(params, header.slice(start, end), true);\n                    if (code === 0x2c) {\n                        push(offers, extensionName, params);\n                        params = Object.create(null);\n                        extensionName = undefined;\n                    }\n                    start = end = -1;\n                } else if (code === 0x3d /* '=' */  && start !== -1 && end === -1) {\n                    paramName = header.slice(start, i);\n                    start = end = -1;\n                } else {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n            } else {\n                //\n                // The value of a quoted-string after unescaping must conform to the\n                // token ABNF, so only token characters are valid.\n                // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n                //\n                if (isEscaping) {\n                    if (tokenChars[code] !== 1) {\n                        throw new SyntaxError(`Unexpected character at index ${i}`);\n                    }\n                    if (start === -1) start = i;\n                    else if (!mustUnescape) mustUnescape = true;\n                    isEscaping = false;\n                } else if (inQuotes) {\n                    if (tokenChars[code] === 1) {\n                        if (start === -1) start = i;\n                    } else if (code === 0x22 /* '\"' */  && start !== -1) {\n                        inQuotes = false;\n                        end = i;\n                    } else if (code === 0x5c /* '\\' */ ) {\n                        isEscaping = true;\n                    } else {\n                        throw new SyntaxError(`Unexpected character at index ${i}`);\n                    }\n                } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n                    inQuotes = true;\n                } else if (end === -1 && tokenChars[code] === 1) {\n                    if (start === -1) start = i;\n                } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n                    if (end === -1) end = i;\n                } else if (code === 0x3b || code === 0x2c) {\n                    if (start === -1) {\n                        throw new SyntaxError(`Unexpected character at index ${i}`);\n                    }\n                    if (end === -1) end = i;\n                    let value = header.slice(start, end);\n                    if (mustUnescape) {\n                        value = value.replace(/\\\\/g, '');\n                        mustUnescape = false;\n                    }\n                    push(params, paramName, value);\n                    if (code === 0x2c) {\n                        push(offers, extensionName, params);\n                        params = Object.create(null);\n                        extensionName = undefined;\n                    }\n                    paramName = undefined;\n                    start = end = -1;\n                } else {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n            }\n        }\n        if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n            throw new SyntaxError('Unexpected end of input');\n        }\n        if (end === -1) end = i;\n        const token = header.slice(start, end);\n        if (extensionName === undefined) {\n            push(offers, token, params);\n        } else {\n            if (paramName === undefined) {\n                push(params, token, true);\n            } else if (mustUnescape) {\n                push(params, paramName, token.replace(/\\\\/g, ''));\n            } else {\n                push(params, paramName, token);\n            }\n            push(offers, extensionName, params);\n        }\n        return offers;\n    }\n    /**\n\t * Builds the `Sec-WebSocket-Extensions` header field value.\n\t *\n\t * @param {Object} extensions The map of extensions and parameters to format\n\t * @return {String} A string representing the given object\n\t * @public\n\t */ function format(extensions) {\n        return Object.keys(extensions).map((extension)=>{\n            let configurations = extensions[extension];\n            if (!Array.isArray(configurations)) configurations = [\n                configurations\n            ];\n            return configurations.map((params)=>{\n                return [\n                    extension\n                ].concat(Object.keys(params).map((k)=>{\n                    let values = params[k];\n                    if (!Array.isArray(values)) values = [\n                        values\n                    ];\n                    return values.map((v)=>v === true ? k : `${k}=${v}`).join('; ');\n                })).join('; ');\n            }).join(', ');\n        }).join(', ');\n    }\n    extension = {\n        format,\n        parse\n    };\n    return extension;\n}\n/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */ var websocket;\nvar hasRequiredWebsocket;\nfunction requireWebsocket() {\n    if (hasRequiredWebsocket) return websocket;\n    hasRequiredWebsocket = 1;\n    const EventEmitter = events__WEBPACK_IMPORTED_MODULE_4__;\n    const https = https__WEBPACK_IMPORTED_MODULE_5__;\n    const http = http__WEBPACK_IMPORTED_MODULE_6__;\n    const net = net__WEBPACK_IMPORTED_MODULE_7__;\n    const tls = tls__WEBPACK_IMPORTED_MODULE_8__;\n    const { randomBytes, createHash } = crypto__WEBPACK_IMPORTED_MODULE_3__;\n    const { URL: URL1 } = url__WEBPACK_IMPORTED_MODULE_9__;\n    const PerMessageDeflate = requirePermessageDeflate();\n    const Receiver = requireReceiver();\n    const Sender = requireSender();\n    const { isBlob } = requireValidation();\n    const { BINARY_TYPES, EMPTY_BUFFER, GUID, kForOnEventAttribute, kListener, kStatusCode, kWebSocket, NOOP } = requireConstants();\n    const { EventTarget: { addEventListener, removeEventListener } } = requireEventTarget();\n    const { format, parse } = requireExtension();\n    const { toBuffer } = requireBufferUtil();\n    const closeTimeout = 30 * 1000;\n    const kAborted = Symbol('kAborted');\n    const protocolVersions = [\n        8,\n        13\n    ];\n    const readyStates = [\n        'CONNECTING',\n        'OPEN',\n        'CLOSING',\n        'CLOSED'\n    ];\n    const subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n    /**\n\t * Class representing a WebSocket.\n\t *\n\t * @extends EventEmitter\n\t */ class WebSocket extends EventEmitter {\n        /**\n\t   * Create a new `WebSocket`.\n\t   *\n\t   * @param {(String|URL)} address The URL to which to connect\n\t   * @param {(String|String[])} [protocols] The subprotocols\n\t   * @param {Object} [options] Connection options\n\t   */ constructor(address, protocols, options){\n            super();\n            this._binaryType = BINARY_TYPES[0];\n            this._closeCode = 1006;\n            this._closeFrameReceived = false;\n            this._closeFrameSent = false;\n            this._closeMessage = EMPTY_BUFFER;\n            this._closeTimer = null;\n            this._errorEmitted = false;\n            this._extensions = {};\n            this._paused = false;\n            this._protocol = '';\n            this._readyState = WebSocket.CONNECTING;\n            this._receiver = null;\n            this._sender = null;\n            this._socket = null;\n            if (address !== null) {\n                this._bufferedAmount = 0;\n                this._isServer = false;\n                this._redirects = 0;\n                if (protocols === undefined) {\n                    protocols = [];\n                } else if (!Array.isArray(protocols)) {\n                    if (typeof protocols === 'object' && protocols !== null) {\n                        options = protocols;\n                        protocols = [];\n                    } else {\n                        protocols = [\n                            protocols\n                        ];\n                    }\n                }\n                initAsClient(this, address, protocols, options);\n            } else {\n                this._autoPong = options.autoPong;\n                this._isServer = true;\n            }\n        }\n        /**\n\t   * For historical reasons, the custom \"nodebuffer\" type is used by the default\n\t   * instead of \"blob\".\n\t   *\n\t   * @type {String}\n\t   */ get binaryType() {\n            return this._binaryType;\n        }\n        set binaryType(type) {\n            if (!BINARY_TYPES.includes(type)) return;\n            this._binaryType = type;\n            //\n            // Allow to change `binaryType` on the fly.\n            //\n            if (this._receiver) this._receiver._binaryType = type;\n        }\n        /**\n\t   * @type {Number}\n\t   */ get bufferedAmount() {\n            if (!this._socket) return this._bufferedAmount;\n            return this._socket._writableState.length + this._sender._bufferedBytes;\n        }\n        /**\n\t   * @type {String}\n\t   */ get extensions() {\n            return Object.keys(this._extensions).join();\n        }\n        /**\n\t   * @type {Boolean}\n\t   */ get isPaused() {\n            return this._paused;\n        }\n        /**\n\t   * @type {Function}\n\t   */ /* istanbul ignore next */ get onclose() {\n            return null;\n        }\n        /**\n\t   * @type {Function}\n\t   */ /* istanbul ignore next */ get onerror() {\n            return null;\n        }\n        /**\n\t   * @type {Function}\n\t   */ /* istanbul ignore next */ get onopen() {\n            return null;\n        }\n        /**\n\t   * @type {Function}\n\t   */ /* istanbul ignore next */ get onmessage() {\n            return null;\n        }\n        /**\n\t   * @type {String}\n\t   */ get protocol() {\n            return this._protocol;\n        }\n        /**\n\t   * @type {Number}\n\t   */ get readyState() {\n            return this._readyState;\n        }\n        /**\n\t   * @type {String}\n\t   */ get url() {\n            return this._url;\n        }\n        /**\n\t   * Set up the socket and the internal resources.\n\t   *\n\t   * @param {Duplex} socket The network socket between the server and client\n\t   * @param {Buffer} head The first packet of the upgraded stream\n\t   * @param {Object} options Options object\n\t   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n\t   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n\t   *     multiple times in the same tick\n\t   * @param {Function} [options.generateMask] The function used to generate the\n\t   *     masking key\n\t   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n\t   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n\t   *     not to skip UTF-8 validation for text and close messages\n\t   * @private\n\t   */ setSocket(socket, head, options) {\n            const receiver = new Receiver({\n                allowSynchronousEvents: options.allowSynchronousEvents,\n                binaryType: this.binaryType,\n                extensions: this._extensions,\n                isServer: this._isServer,\n                maxPayload: options.maxPayload,\n                skipUTF8Validation: options.skipUTF8Validation\n            });\n            const sender = new Sender(socket, this._extensions, options.generateMask);\n            this._receiver = receiver;\n            this._sender = sender;\n            this._socket = socket;\n            receiver[kWebSocket] = this;\n            sender[kWebSocket] = this;\n            socket[kWebSocket] = this;\n            receiver.on('conclude', receiverOnConclude);\n            receiver.on('drain', receiverOnDrain);\n            receiver.on('error', receiverOnError);\n            receiver.on('message', receiverOnMessage);\n            receiver.on('ping', receiverOnPing);\n            receiver.on('pong', receiverOnPong);\n            sender.onerror = senderOnError;\n            //\n            // These methods may not be available if `socket` is just a `Duplex`.\n            //\n            if (socket.setTimeout) socket.setTimeout(0);\n            if (socket.setNoDelay) socket.setNoDelay();\n            if (head.length > 0) socket.unshift(head);\n            socket.on('close', socketOnClose);\n            socket.on('data', socketOnData);\n            socket.on('end', socketOnEnd);\n            socket.on('error', socketOnError);\n            this._readyState = WebSocket.OPEN;\n            this.emit('open');\n        }\n        /**\n\t   * Emit the `'close'` event.\n\t   *\n\t   * @private\n\t   */ emitClose() {\n            if (!this._socket) {\n                this._readyState = WebSocket.CLOSED;\n                this.emit('close', this._closeCode, this._closeMessage);\n                return;\n            }\n            if (this._extensions[PerMessageDeflate.extensionName]) {\n                this._extensions[PerMessageDeflate.extensionName].cleanup();\n            }\n            this._receiver.removeAllListeners();\n            this._readyState = WebSocket.CLOSED;\n            this.emit('close', this._closeCode, this._closeMessage);\n        }\n        /**\n\t   * Start a closing handshake.\n\t   *\n\t   *          +----------+   +-----------+   +----------+\n\t   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n\t   *    |     +----------+   +-----------+   +----------+     |\n\t   *          +----------+   +-----------+         |\n\t   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n\t   *          +----------+   +-----------+   |\n\t   *    |           |                        |   +---+        |\n\t   *                +------------------------+-->|fin| - - - -\n\t   *    |         +---+                      |   +---+\n\t   *     - - - - -|fin|<---------------------+\n\t   *              +---+\n\t   *\n\t   * @param {Number} [code] Status code explaining why the connection is closing\n\t   * @param {(String|Buffer)} [data] The reason why the connection is\n\t   *     closing\n\t   * @public\n\t   */ close(code, data) {\n            if (this.readyState === WebSocket.CLOSED) return;\n            if (this.readyState === WebSocket.CONNECTING) {\n                const msg = 'WebSocket was closed before the connection was established';\n                abortHandshake(this, this._req, msg);\n                return;\n            }\n            if (this.readyState === WebSocket.CLOSING) {\n                if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n                    this._socket.end();\n                }\n                return;\n            }\n            this._readyState = WebSocket.CLOSING;\n            this._sender.close(code, data, !this._isServer, (err)=>{\n                //\n                // This error is handled by the `'error'` listener on the socket. We only\n                // want to know if the close frame has been sent here.\n                //\n                if (err) return;\n                this._closeFrameSent = true;\n                if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n                    this._socket.end();\n                }\n            });\n            setCloseTimer(this);\n        }\n        /**\n\t   * Pause the socket.\n\t   *\n\t   * @public\n\t   */ pause() {\n            if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n                return;\n            }\n            this._paused = true;\n            this._socket.pause();\n        }\n        /**\n\t   * Send a ping.\n\t   *\n\t   * @param {*} [data] The data to send\n\t   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n\t   * @param {Function} [cb] Callback which is executed when the ping is sent\n\t   * @public\n\t   */ ping(data, mask, cb) {\n            if (this.readyState === WebSocket.CONNECTING) {\n                throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n            }\n            if (typeof data === 'function') {\n                cb = data;\n                data = mask = undefined;\n            } else if (typeof mask === 'function') {\n                cb = mask;\n                mask = undefined;\n            }\n            if (typeof data === 'number') data = data.toString();\n            if (this.readyState !== WebSocket.OPEN) {\n                sendAfterClose(this, data, cb);\n                return;\n            }\n            if (mask === undefined) mask = !this._isServer;\n            this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n        }\n        /**\n\t   * Send a pong.\n\t   *\n\t   * @param {*} [data] The data to send\n\t   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n\t   * @param {Function} [cb] Callback which is executed when the pong is sent\n\t   * @public\n\t   */ pong(data, mask, cb) {\n            if (this.readyState === WebSocket.CONNECTING) {\n                throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n            }\n            if (typeof data === 'function') {\n                cb = data;\n                data = mask = undefined;\n            } else if (typeof mask === 'function') {\n                cb = mask;\n                mask = undefined;\n            }\n            if (typeof data === 'number') data = data.toString();\n            if (this.readyState !== WebSocket.OPEN) {\n                sendAfterClose(this, data, cb);\n                return;\n            }\n            if (mask === undefined) mask = !this._isServer;\n            this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n        }\n        /**\n\t   * Resume the socket.\n\t   *\n\t   * @public\n\t   */ resume() {\n            if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n                return;\n            }\n            this._paused = false;\n            if (!this._receiver._writableState.needDrain) this._socket.resume();\n        }\n        /**\n\t   * Send a data message.\n\t   *\n\t   * @param {*} data The message to send\n\t   * @param {Object} [options] Options object\n\t   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n\t   *     text\n\t   * @param {Boolean} [options.compress] Specifies whether or not to compress\n\t   *     `data`\n\t   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n\t   *     last one\n\t   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n\t   * @param {Function} [cb] Callback which is executed when data is written out\n\t   * @public\n\t   */ send(data, options, cb) {\n            if (this.readyState === WebSocket.CONNECTING) {\n                throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n            }\n            if (typeof options === 'function') {\n                cb = options;\n                options = {};\n            }\n            if (typeof data === 'number') data = data.toString();\n            if (this.readyState !== WebSocket.OPEN) {\n                sendAfterClose(this, data, cb);\n                return;\n            }\n            const opts = {\n                binary: typeof data !== 'string',\n                mask: !this._isServer,\n                compress: true,\n                fin: true,\n                ...options\n            };\n            if (!this._extensions[PerMessageDeflate.extensionName]) {\n                opts.compress = false;\n            }\n            this._sender.send(data || EMPTY_BUFFER, opts, cb);\n        }\n        /**\n\t   * Forcibly close the connection.\n\t   *\n\t   * @public\n\t   */ terminate() {\n            if (this.readyState === WebSocket.CLOSED) return;\n            if (this.readyState === WebSocket.CONNECTING) {\n                const msg = 'WebSocket was closed before the connection was established';\n                abortHandshake(this, this._req, msg);\n                return;\n            }\n            if (this._socket) {\n                this._readyState = WebSocket.CLOSING;\n                this._socket.destroy();\n            }\n        }\n    }\n    /**\n\t * @constant {Number} CONNECTING\n\t * @memberof WebSocket\n\t */ Object.defineProperty(WebSocket, 'CONNECTING', {\n        enumerable: true,\n        value: readyStates.indexOf('CONNECTING')\n    });\n    /**\n\t * @constant {Number} CONNECTING\n\t * @memberof WebSocket.prototype\n\t */ Object.defineProperty(WebSocket.prototype, 'CONNECTING', {\n        enumerable: true,\n        value: readyStates.indexOf('CONNECTING')\n    });\n    /**\n\t * @constant {Number} OPEN\n\t * @memberof WebSocket\n\t */ Object.defineProperty(WebSocket, 'OPEN', {\n        enumerable: true,\n        value: readyStates.indexOf('OPEN')\n    });\n    /**\n\t * @constant {Number} OPEN\n\t * @memberof WebSocket.prototype\n\t */ Object.defineProperty(WebSocket.prototype, 'OPEN', {\n        enumerable: true,\n        value: readyStates.indexOf('OPEN')\n    });\n    /**\n\t * @constant {Number} CLOSING\n\t * @memberof WebSocket\n\t */ Object.defineProperty(WebSocket, 'CLOSING', {\n        enumerable: true,\n        value: readyStates.indexOf('CLOSING')\n    });\n    /**\n\t * @constant {Number} CLOSING\n\t * @memberof WebSocket.prototype\n\t */ Object.defineProperty(WebSocket.prototype, 'CLOSING', {\n        enumerable: true,\n        value: readyStates.indexOf('CLOSING')\n    });\n    /**\n\t * @constant {Number} CLOSED\n\t * @memberof WebSocket\n\t */ Object.defineProperty(WebSocket, 'CLOSED', {\n        enumerable: true,\n        value: readyStates.indexOf('CLOSED')\n    });\n    /**\n\t * @constant {Number} CLOSED\n\t * @memberof WebSocket.prototype\n\t */ Object.defineProperty(WebSocket.prototype, 'CLOSED', {\n        enumerable: true,\n        value: readyStates.indexOf('CLOSED')\n    });\n    [\n        'binaryType',\n        'bufferedAmount',\n        'extensions',\n        'isPaused',\n        'protocol',\n        'readyState',\n        'url'\n    ].forEach((property)=>{\n        Object.defineProperty(WebSocket.prototype, property, {\n            enumerable: true\n        });\n    });\n    //\n    // Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n    // See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n    //\n    [\n        'open',\n        'error',\n        'close',\n        'message'\n    ].forEach((method)=>{\n        Object.defineProperty(WebSocket.prototype, `on${method}`, {\n            enumerable: true,\n            get () {\n                for (const listener of this.listeners(method)){\n                    if (listener[kForOnEventAttribute]) return listener[kListener];\n                }\n                return null;\n            },\n            set (handler) {\n                for (const listener of this.listeners(method)){\n                    if (listener[kForOnEventAttribute]) {\n                        this.removeListener(method, listener);\n                        break;\n                    }\n                }\n                if (typeof handler !== 'function') return;\n                this.addEventListener(method, handler, {\n                    [kForOnEventAttribute]: true\n                });\n            }\n        });\n    });\n    WebSocket.prototype.addEventListener = addEventListener;\n    WebSocket.prototype.removeEventListener = removeEventListener;\n    websocket = WebSocket;\n    /**\n\t * Initialize a WebSocket client.\n\t *\n\t * @param {WebSocket} websocket The client to initialize\n\t * @param {(String|URL)} address The URL to which to connect\n\t * @param {Array} protocols The subprotocols\n\t * @param {Object} [options] Connection options\n\t * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\n\t *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\n\t *     times in the same tick\n\t * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n\t *     automatically send a pong in response to a ping\n\t * @param {Function} [options.finishRequest] A function which can be used to\n\t *     customize the headers of each http request before it is sent\n\t * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n\t *     redirects\n\t * @param {Function} [options.generateMask] The function used to generate the\n\t *     masking key\n\t * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n\t *     handshake request\n\t * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n\t *     size\n\t * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n\t *     allowed\n\t * @param {String} [options.origin] Value of the `Origin` or\n\t *     `Sec-WebSocket-Origin` header\n\t * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n\t *     permessage-deflate\n\t * @param {Number} [options.protocolVersion=13] Value of the\n\t *     `Sec-WebSocket-Version` header\n\t * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n\t *     not to skip UTF-8 validation for text and close messages\n\t * @private\n\t */ function initAsClient(websocket, address, protocols, options) {\n        const opts = {\n            allowSynchronousEvents: true,\n            autoPong: true,\n            protocolVersion: protocolVersions[1],\n            maxPayload: 100 * 1024 * 1024,\n            skipUTF8Validation: false,\n            perMessageDeflate: true,\n            followRedirects: false,\n            maxRedirects: 10,\n            ...options,\n            socketPath: undefined,\n            hostname: undefined,\n            protocol: undefined,\n            timeout: undefined,\n            method: 'GET',\n            host: undefined,\n            path: undefined,\n            port: undefined\n        };\n        websocket._autoPong = opts.autoPong;\n        if (!protocolVersions.includes(opts.protocolVersion)) {\n            throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(', ')})`);\n        }\n        let parsedUrl;\n        if (address instanceof URL1) {\n            parsedUrl = address;\n        } else {\n            try {\n                parsedUrl = new URL1(address);\n            } catch (e) {\n                throw new SyntaxError(`Invalid URL: ${address}`);\n            }\n        }\n        if (parsedUrl.protocol === 'http:') {\n            parsedUrl.protocol = 'ws:';\n        } else if (parsedUrl.protocol === 'https:') {\n            parsedUrl.protocol = 'wss:';\n        }\n        websocket._url = parsedUrl.href;\n        const isSecure = parsedUrl.protocol === 'wss:';\n        const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\n        let invalidUrlMessage;\n        if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\n            invalidUrlMessage = 'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' + '\"http:\", \"https\", or \"ws+unix:\"';\n        } else if (isIpcUrl && !parsedUrl.pathname) {\n            invalidUrlMessage = \"The URL's pathname is empty\";\n        } else if (parsedUrl.hash) {\n            invalidUrlMessage = 'The URL contains a fragment identifier';\n        }\n        if (invalidUrlMessage) {\n            const err = new SyntaxError(invalidUrlMessage);\n            if (websocket._redirects === 0) {\n                throw err;\n            } else {\n                emitErrorAndClose(websocket, err);\n                return;\n            }\n        }\n        const defaultPort = isSecure ? 443 : 80;\n        const key = randomBytes(16).toString('base64');\n        const request = isSecure ? https.request : http.request;\n        const protocolSet = new Set();\n        let perMessageDeflate;\n        opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);\n        opts.defaultPort = opts.defaultPort || defaultPort;\n        opts.port = parsedUrl.port || defaultPort;\n        opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n        opts.headers = {\n            ...opts.headers,\n            'Sec-WebSocket-Version': opts.protocolVersion,\n            'Sec-WebSocket-Key': key,\n            Connection: 'Upgrade',\n            Upgrade: 'websocket'\n        };\n        opts.path = parsedUrl.pathname + parsedUrl.search;\n        opts.timeout = opts.handshakeTimeout;\n        if (opts.perMessageDeflate) {\n            perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n            opts.headers['Sec-WebSocket-Extensions'] = format({\n                [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n            });\n        }\n        if (protocols.length) {\n            for (const protocol of protocols){\n                if (typeof protocol !== 'string' || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n                    throw new SyntaxError('An invalid or duplicated subprotocol was specified');\n                }\n                protocolSet.add(protocol);\n            }\n            opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n        }\n        if (opts.origin) {\n            if (opts.protocolVersion < 13) {\n                opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n            } else {\n                opts.headers.Origin = opts.origin;\n            }\n        }\n        if (parsedUrl.username || parsedUrl.password) {\n            opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n        }\n        if (isIpcUrl) {\n            const parts = opts.path.split(':');\n            opts.socketPath = parts[0];\n            opts.path = parts[1];\n        }\n        let req;\n        if (opts.followRedirects) {\n            if (websocket._redirects === 0) {\n                websocket._originalIpc = isIpcUrl;\n                websocket._originalSecure = isSecure;\n                websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;\n                const headers = options && options.headers;\n                //\n                // Shallow copy the user provided options so that headers can be changed\n                // without mutating the original object.\n                //\n                options = {\n                    ...options,\n                    headers: {}\n                };\n                if (headers) {\n                    for (const [key, value] of Object.entries(headers)){\n                        options.headers[key.toLowerCase()] = value;\n                    }\n                }\n            } else if (websocket.listenerCount('redirect') === 0) {\n                const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;\n                if (!isSameHost || websocket._originalSecure && !isSecure) {\n                    //\n                    // Match curl 7.77.0 behavior and drop the following headers. These\n                    // headers are also dropped when following a redirect to a subdomain.\n                    //\n                    delete opts.headers.authorization;\n                    delete opts.headers.cookie;\n                    if (!isSameHost) delete opts.headers.host;\n                    opts.auth = undefined;\n                }\n            }\n            //\n            // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n            // If the `Authorization` header is set, then there is nothing to do as it\n            // will take precedence.\n            //\n            if (opts.auth && !options.headers.authorization) {\n                options.headers.authorization = 'Basic ' + Buffer.from(opts.auth).toString('base64');\n            }\n            req = websocket._req = request(opts);\n            if (websocket._redirects) {\n                //\n                // Unlike what is done for the `'upgrade'` event, no early exit is\n                // triggered here if the user calls `websocket.close()` or\n                // `websocket.terminate()` from a listener of the `'redirect'` event. This\n                // is because the user can also call `request.destroy()` with an error\n                // before calling `websocket.close()` or `websocket.terminate()` and this\n                // would result in an error being emitted on the `request` object with no\n                // `'error'` event listeners attached.\n                //\n                websocket.emit('redirect', websocket.url, req);\n            }\n        } else {\n            req = websocket._req = request(opts);\n        }\n        if (opts.timeout) {\n            req.on('timeout', ()=>{\n                abortHandshake(websocket, req, 'Opening handshake has timed out');\n            });\n        }\n        req.on('error', (err)=>{\n            if (req === null || req[kAborted]) return;\n            req = websocket._req = null;\n            emitErrorAndClose(websocket, err);\n        });\n        req.on('response', (res)=>{\n            const location = res.headers.location;\n            const statusCode = res.statusCode;\n            if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n                if (++websocket._redirects > opts.maxRedirects) {\n                    abortHandshake(websocket, req, 'Maximum redirects exceeded');\n                    return;\n                }\n                req.abort();\n                let addr;\n                try {\n                    addr = new URL1(location, address);\n                } catch (e) {\n                    const err = new SyntaxError(`Invalid URL: ${location}`);\n                    emitErrorAndClose(websocket, err);\n                    return;\n                }\n                initAsClient(websocket, addr, protocols, options);\n            } else if (!websocket.emit('unexpected-response', req, res)) {\n                abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);\n            }\n        });\n        req.on('upgrade', (res, socket, head)=>{\n            websocket.emit('upgrade', res);\n            //\n            // The user may have closed the connection from a listener of the\n            // `'upgrade'` event.\n            //\n            if (websocket.readyState !== WebSocket.CONNECTING) return;\n            req = websocket._req = null;\n            const upgrade = res.headers.upgrade;\n            if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n                abortHandshake(websocket, socket, 'Invalid Upgrade header');\n                return;\n            }\n            const digest = createHash('sha1').update(key + GUID).digest('base64');\n            if (res.headers['sec-websocket-accept'] !== digest) {\n                abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n                return;\n            }\n            const serverProt = res.headers['sec-websocket-protocol'];\n            let protError;\n            if (serverProt !== undefined) {\n                if (!protocolSet.size) {\n                    protError = 'Server sent a subprotocol but none was requested';\n                } else if (!protocolSet.has(serverProt)) {\n                    protError = 'Server sent an invalid subprotocol';\n                }\n            } else if (protocolSet.size) {\n                protError = 'Server sent no subprotocol';\n            }\n            if (protError) {\n                abortHandshake(websocket, socket, protError);\n                return;\n            }\n            if (serverProt) websocket._protocol = serverProt;\n            const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n            if (secWebSocketExtensions !== undefined) {\n                if (!perMessageDeflate) {\n                    const message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';\n                    abortHandshake(websocket, socket, message);\n                    return;\n                }\n                let extensions;\n                try {\n                    extensions = parse(secWebSocketExtensions);\n                } catch (err) {\n                    const message = 'Invalid Sec-WebSocket-Extensions header';\n                    abortHandshake(websocket, socket, message);\n                    return;\n                }\n                const extensionNames = Object.keys(extensions);\n                if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n                    const message = 'Server indicated an extension that was not requested';\n                    abortHandshake(websocket, socket, message);\n                    return;\n                }\n                try {\n                    perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n                } catch (err) {\n                    const message = 'Invalid Sec-WebSocket-Extensions header';\n                    abortHandshake(websocket, socket, message);\n                    return;\n                }\n                websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n            }\n            websocket.setSocket(socket, head, {\n                allowSynchronousEvents: opts.allowSynchronousEvents,\n                generateMask: opts.generateMask,\n                maxPayload: opts.maxPayload,\n                skipUTF8Validation: opts.skipUTF8Validation\n            });\n        });\n        if (opts.finishRequest) {\n            opts.finishRequest(req, websocket);\n        } else {\n            req.end();\n        }\n    }\n    /**\n\t * Emit the `'error'` and `'close'` events.\n\t *\n\t * @param {WebSocket} websocket The WebSocket instance\n\t * @param {Error} The error to emit\n\t * @private\n\t */ function emitErrorAndClose(websocket, err) {\n        websocket._readyState = WebSocket.CLOSING;\n        //\n        // The following assignment is practically useless and is done only for\n        // consistency.\n        //\n        websocket._errorEmitted = true;\n        websocket.emit('error', err);\n        websocket.emitClose();\n    }\n    /**\n\t * Create a `net.Socket` and initiate a connection.\n\t *\n\t * @param {Object} options Connection options\n\t * @return {net.Socket} The newly created socket used to start the connection\n\t * @private\n\t */ function netConnect(options) {\n        options.path = options.socketPath;\n        return net.connect(options);\n    }\n    /**\n\t * Create a `tls.TLSSocket` and initiate a connection.\n\t *\n\t * @param {Object} options Connection options\n\t * @return {tls.TLSSocket} The newly created socket used to start the connection\n\t * @private\n\t */ function tlsConnect(options) {\n        options.path = undefined;\n        if (!options.servername && options.servername !== '') {\n            options.servername = net.isIP(options.host) ? '' : options.host;\n        }\n        return tls.connect(options);\n    }\n    /**\n\t * Abort the handshake and emit an error.\n\t *\n\t * @param {WebSocket} websocket The WebSocket instance\n\t * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n\t *     abort or the socket to destroy\n\t * @param {String} message The error message\n\t * @private\n\t */ function abortHandshake(websocket, stream, message) {\n        websocket._readyState = WebSocket.CLOSING;\n        const err = new Error(message);\n        Error.captureStackTrace(err, abortHandshake);\n        if (stream.setHeader) {\n            stream[kAborted] = true;\n            stream.abort();\n            if (stream.socket && !stream.socket.destroyed) {\n                //\n                // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n                // called after the request completed. See\n                // https://github.com/websockets/ws/issues/1869.\n                //\n                stream.socket.destroy();\n            }\n            process.nextTick(emitErrorAndClose, websocket, err);\n        } else {\n            stream.destroy(err);\n            stream.once('error', websocket.emit.bind(websocket, 'error'));\n            stream.once('close', websocket.emitClose.bind(websocket));\n        }\n    }\n    /**\n\t * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n\t * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n\t *\n\t * @param {WebSocket} websocket The WebSocket instance\n\t * @param {*} [data] The data to send\n\t * @param {Function} [cb] Callback\n\t * @private\n\t */ function sendAfterClose(websocket, data, cb) {\n        if (data) {\n            const length = isBlob(data) ? data.size : toBuffer(data).length;\n            //\n            // The `_bufferedAmount` property is used only when the peer is a client and\n            // the opening handshake fails. Under these circumstances, in fact, the\n            // `setSocket()` method is not called, so the `_socket` and `_sender`\n            // properties are set to `null`.\n            //\n            if (websocket._socket) websocket._sender._bufferedBytes += length;\n            else websocket._bufferedAmount += length;\n        }\n        if (cb) {\n            const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);\n            process.nextTick(cb, err);\n        }\n    }\n    /**\n\t * The listener of the `Receiver` `'conclude'` event.\n\t *\n\t * @param {Number} code The status code\n\t * @param {Buffer} reason The reason for closing\n\t * @private\n\t */ function receiverOnConclude(code, reason) {\n        const websocket = this[kWebSocket];\n        websocket._closeFrameReceived = true;\n        websocket._closeMessage = reason;\n        websocket._closeCode = code;\n        if (websocket._socket[kWebSocket] === undefined) return;\n        websocket._socket.removeListener('data', socketOnData);\n        process.nextTick(resume, websocket._socket);\n        if (code === 1005) websocket.close();\n        else websocket.close(code, reason);\n    }\n    /**\n\t * The listener of the `Receiver` `'drain'` event.\n\t *\n\t * @private\n\t */ function receiverOnDrain() {\n        const websocket = this[kWebSocket];\n        if (!websocket.isPaused) websocket._socket.resume();\n    }\n    /**\n\t * The listener of the `Receiver` `'error'` event.\n\t *\n\t * @param {(RangeError|Error)} err The emitted error\n\t * @private\n\t */ function receiverOnError(err) {\n        const websocket = this[kWebSocket];\n        if (websocket._socket[kWebSocket] !== undefined) {\n            websocket._socket.removeListener('data', socketOnData);\n            //\n            // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n            // https://github.com/websockets/ws/issues/1940.\n            //\n            process.nextTick(resume, websocket._socket);\n            websocket.close(err[kStatusCode]);\n        }\n        if (!websocket._errorEmitted) {\n            websocket._errorEmitted = true;\n            websocket.emit('error', err);\n        }\n    }\n    /**\n\t * The listener of the `Receiver` `'finish'` event.\n\t *\n\t * @private\n\t */ function receiverOnFinish() {\n        this[kWebSocket].emitClose();\n    }\n    /**\n\t * The listener of the `Receiver` `'message'` event.\n\t *\n\t * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n\t * @param {Boolean} isBinary Specifies whether the message is binary or not\n\t * @private\n\t */ function receiverOnMessage(data, isBinary) {\n        this[kWebSocket].emit('message', data, isBinary);\n    }\n    /**\n\t * The listener of the `Receiver` `'ping'` event.\n\t *\n\t * @param {Buffer} data The data included in the ping frame\n\t * @private\n\t */ function receiverOnPing(data) {\n        const websocket = this[kWebSocket];\n        if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n        websocket.emit('ping', data);\n    }\n    /**\n\t * The listener of the `Receiver` `'pong'` event.\n\t *\n\t * @param {Buffer} data The data included in the pong frame\n\t * @private\n\t */ function receiverOnPong(data) {\n        this[kWebSocket].emit('pong', data);\n    }\n    /**\n\t * Resume a readable stream\n\t *\n\t * @param {Readable} stream The readable stream\n\t * @private\n\t */ function resume(stream) {\n        stream.resume();\n    }\n    /**\n\t * The `Sender` error event handler.\n\t *\n\t * @param {Error} The error\n\t * @private\n\t */ function senderOnError(err) {\n        const websocket = this[kWebSocket];\n        if (websocket.readyState === WebSocket.CLOSED) return;\n        if (websocket.readyState === WebSocket.OPEN) {\n            websocket._readyState = WebSocket.CLOSING;\n            setCloseTimer(websocket);\n        }\n        //\n        // `socket.end()` is used instead of `socket.destroy()` to allow the other\n        // peer to finish sending queued data. There is no need to set a timer here\n        // because `CLOSING` means that it is already set or not needed.\n        //\n        this._socket.end();\n        if (!websocket._errorEmitted) {\n            websocket._errorEmitted = true;\n            websocket.emit('error', err);\n        }\n    }\n    /**\n\t * Set a timer to destroy the underlying raw socket of a WebSocket.\n\t *\n\t * @param {WebSocket} websocket The WebSocket instance\n\t * @private\n\t */ function setCloseTimer(websocket) {\n        websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), closeTimeout);\n    }\n    /**\n\t * The listener of the socket `'close'` event.\n\t *\n\t * @private\n\t */ function socketOnClose() {\n        const websocket = this[kWebSocket];\n        this.removeListener('close', socketOnClose);\n        this.removeListener('data', socketOnData);\n        this.removeListener('end', socketOnEnd);\n        websocket._readyState = WebSocket.CLOSING;\n        let chunk;\n        //\n        // The close frame might not have been received or the `'end'` event emitted,\n        // for example, if the socket was destroyed due to an error. Ensure that the\n        // `receiver` stream is closed after writing any remaining buffered data to\n        // it. If the readable side of the socket is in flowing mode then there is no\n        // buffered data as everything has been already written and `readable.read()`\n        // will return `null`. If instead, the socket is paused, any possible buffered\n        // data will be read as a single chunk.\n        //\n        if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n            websocket._receiver.write(chunk);\n        }\n        websocket._receiver.end();\n        this[kWebSocket] = undefined;\n        clearTimeout(websocket._closeTimer);\n        if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n            websocket.emitClose();\n        } else {\n            websocket._receiver.on('error', receiverOnFinish);\n            websocket._receiver.on('finish', receiverOnFinish);\n        }\n    }\n    /**\n\t * The listener of the socket `'data'` event.\n\t *\n\t * @param {Buffer} chunk A chunk of data\n\t * @private\n\t */ function socketOnData(chunk) {\n        if (!this[kWebSocket]._receiver.write(chunk)) {\n            this.pause();\n        }\n    }\n    /**\n\t * The listener of the socket `'end'` event.\n\t *\n\t * @private\n\t */ function socketOnEnd() {\n        const websocket = this[kWebSocket];\n        websocket._readyState = WebSocket.CLOSING;\n        websocket._receiver.end();\n        this.end();\n    }\n    /**\n\t * The listener of the socket `'error'` event.\n\t *\n\t * @private\n\t */ function socketOnError() {\n        const websocket = this[kWebSocket];\n        this.removeListener('error', socketOnError);\n        this.on('error', NOOP);\n        if (websocket) {\n            websocket._readyState = WebSocket.CLOSING;\n            this.destroy();\n        }\n    }\n    return websocket;\n}\nvar websocketExports = requireWebsocket();\nvar WS = /*@__PURE__*/ getDefaultExportFromCjs(websocketExports);\nvar subprotocol;\nvar hasRequiredSubprotocol;\nfunction requireSubprotocol() {\n    if (hasRequiredSubprotocol) return subprotocol;\n    hasRequiredSubprotocol = 1;\n    const { tokenChars } = requireValidation();\n    /**\n\t * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n\t *\n\t * @param {String} header The field value of the header\n\t * @return {Set} The subprotocol names\n\t * @public\n\t */ function parse(header) {\n        const protocols = new Set();\n        let start = -1;\n        let end = -1;\n        let i = 0;\n        for(i; i < header.length; i++){\n            const code = header.charCodeAt(i);\n            if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (i !== 0 && (code === 0x20 /* ' ' */  || code === 0x09)) {\n                if (end === -1 && start !== -1) end = i;\n            } else if (code === 0x2c /* ',' */ ) {\n                if (start === -1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (end === -1) end = i;\n                const protocol = header.slice(start, end);\n                if (protocols.has(protocol)) {\n                    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n                }\n                protocols.add(protocol);\n                start = end = -1;\n            } else {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n        }\n        if (start === -1 || end !== -1) {\n            throw new SyntaxError('Unexpected end of input');\n        }\n        const protocol = header.slice(start, i);\n        if (protocols.has(protocol)) {\n            throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n        }\n        protocols.add(protocol);\n        return protocols;\n    }\n    subprotocol = {\n        parse\n    };\n    return subprotocol;\n}\n/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */ var websocketServer;\nvar hasRequiredWebsocketServer;\nfunction requireWebsocketServer() {\n    if (hasRequiredWebsocketServer) return websocketServer;\n    hasRequiredWebsocketServer = 1;\n    const EventEmitter = events__WEBPACK_IMPORTED_MODULE_4__;\n    const http = http__WEBPACK_IMPORTED_MODULE_6__;\n    const { createHash } = crypto__WEBPACK_IMPORTED_MODULE_3__;\n    const extension = requireExtension();\n    const PerMessageDeflate = requirePermessageDeflate();\n    const subprotocol = requireSubprotocol();\n    const WebSocket = requireWebsocket();\n    const { GUID, kWebSocket } = requireConstants();\n    const keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n    const RUNNING = 0;\n    const CLOSING = 1;\n    const CLOSED = 2;\n    /**\n\t * Class representing a WebSocket server.\n\t *\n\t * @extends EventEmitter\n\t */ class WebSocketServer extends EventEmitter {\n        /**\n\t   * Create a `WebSocketServer` instance.\n\t   *\n\t   * @param {Object} options Configuration options\n\t   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n\t   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n\t   *     multiple times in the same tick\n\t   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n\t   *     automatically send a pong in response to a ping\n\t   * @param {Number} [options.backlog=511] The maximum length of the queue of\n\t   *     pending connections\n\t   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n\t   *     track clients\n\t   * @param {Function} [options.handleProtocols] A hook to handle protocols\n\t   * @param {String} [options.host] The hostname where to bind the server\n\t   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n\t   *     size\n\t   * @param {Boolean} [options.noServer=false] Enable no server mode\n\t   * @param {String} [options.path] Accept only connections matching this path\n\t   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n\t   *     permessage-deflate\n\t   * @param {Number} [options.port] The port where to bind the server\n\t   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n\t   *     server to use\n\t   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n\t   *     not to skip UTF-8 validation for text and close messages\n\t   * @param {Function} [options.verifyClient] A hook to reject connections\n\t   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n\t   *     class to use. It must be the `WebSocket` class or class that extends it\n\t   * @param {Function} [callback] A listener for the `listening` event\n\t   */ constructor(options, callback){\n            super();\n            options = {\n                allowSynchronousEvents: true,\n                autoPong: true,\n                maxPayload: 100 * 1024 * 1024,\n                skipUTF8Validation: false,\n                perMessageDeflate: false,\n                handleProtocols: null,\n                clientTracking: true,\n                verifyClient: null,\n                noServer: false,\n                backlog: null,\n                server: null,\n                host: null,\n                path: null,\n                port: null,\n                WebSocket,\n                ...options\n            };\n            if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n                throw new TypeError('One and only one of the \"port\", \"server\", or \"noServer\" options ' + 'must be specified');\n            }\n            if (options.port != null) {\n                this._server = http.createServer((req, res)=>{\n                    const body = http.STATUS_CODES[426];\n                    res.writeHead(426, {\n                        'Content-Length': body.length,\n                        'Content-Type': 'text/plain'\n                    });\n                    res.end(body);\n                });\n                this._server.listen(options.port, options.host, options.backlog, callback);\n            } else if (options.server) {\n                this._server = options.server;\n            }\n            if (this._server) {\n                const emitConnection = this.emit.bind(this, 'connection');\n                this._removeListeners = addListeners(this._server, {\n                    listening: this.emit.bind(this, 'listening'),\n                    error: this.emit.bind(this, 'error'),\n                    upgrade: (req, socket, head)=>{\n                        this.handleUpgrade(req, socket, head, emitConnection);\n                    }\n                });\n            }\n            if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n            if (options.clientTracking) {\n                this.clients = new Set();\n                this._shouldEmitClose = false;\n            }\n            this.options = options;\n            this._state = RUNNING;\n        }\n        /**\n\t   * Returns the bound address, the address family name, and port of the server\n\t   * as reported by the operating system if listening on an IP socket.\n\t   * If the server is listening on a pipe or UNIX domain socket, the name is\n\t   * returned as a string.\n\t   *\n\t   * @return {(Object|String|null)} The address of the server\n\t   * @public\n\t   */ address() {\n            if (this.options.noServer) {\n                throw new Error('The server is operating in \"noServer\" mode');\n            }\n            if (!this._server) return null;\n            return this._server.address();\n        }\n        /**\n\t   * Stop the server from accepting new connections and emit the `'close'` event\n\t   * when all existing connections are closed.\n\t   *\n\t   * @param {Function} [cb] A one-time listener for the `'close'` event\n\t   * @public\n\t   */ close(cb) {\n            if (this._state === CLOSED) {\n                if (cb) {\n                    this.once('close', ()=>{\n                        cb(new Error('The server is not running'));\n                    });\n                }\n                process.nextTick(emitClose, this);\n                return;\n            }\n            if (cb) this.once('close', cb);\n            if (this._state === CLOSING) return;\n            this._state = CLOSING;\n            if (this.options.noServer || this.options.server) {\n                if (this._server) {\n                    this._removeListeners();\n                    this._removeListeners = this._server = null;\n                }\n                if (this.clients) {\n                    if (!this.clients.size) {\n                        process.nextTick(emitClose, this);\n                    } else {\n                        this._shouldEmitClose = true;\n                    }\n                } else {\n                    process.nextTick(emitClose, this);\n                }\n            } else {\n                const server = this._server;\n                this._removeListeners();\n                this._removeListeners = this._server = null;\n                //\n                // The HTTP/S server was created internally. Close it, and rely on its\n                // `'close'` event.\n                //\n                server.close(()=>{\n                    emitClose(this);\n                });\n            }\n        }\n        /**\n\t   * See if a given request should be handled by this server instance.\n\t   *\n\t   * @param {http.IncomingMessage} req Request object to inspect\n\t   * @return {Boolean} `true` if the request is valid, else `false`\n\t   * @public\n\t   */ shouldHandle(req) {\n            if (this.options.path) {\n                const index = req.url.indexOf('?');\n                const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n                if (pathname !== this.options.path) return false;\n            }\n            return true;\n        }\n        /**\n\t   * Handle a HTTP Upgrade request.\n\t   *\n\t   * @param {http.IncomingMessage} req The request object\n\t   * @param {Duplex} socket The network socket between the server and client\n\t   * @param {Buffer} head The first packet of the upgraded stream\n\t   * @param {Function} cb Callback\n\t   * @public\n\t   */ handleUpgrade(req, socket, head, cb) {\n            socket.on('error', socketOnError);\n            const key = req.headers['sec-websocket-key'];\n            const upgrade = req.headers.upgrade;\n            const version = +req.headers['sec-websocket-version'];\n            if (req.method !== 'GET') {\n                const message = 'Invalid HTTP method';\n                abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n                return;\n            }\n            if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n                const message = 'Invalid Upgrade header';\n                abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n                return;\n            }\n            if (key === undefined || !keyRegex.test(key)) {\n                const message = 'Missing or invalid Sec-WebSocket-Key header';\n                abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n                return;\n            }\n            if (version !== 8 && version !== 13) {\n                const message = 'Missing or invalid Sec-WebSocket-Version header';\n                abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n                return;\n            }\n            if (!this.shouldHandle(req)) {\n                abortHandshake(socket, 400);\n                return;\n            }\n            const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n            let protocols = new Set();\n            if (secWebSocketProtocol !== undefined) {\n                try {\n                    protocols = subprotocol.parse(secWebSocketProtocol);\n                } catch (err) {\n                    const message = 'Invalid Sec-WebSocket-Protocol header';\n                    abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n                    return;\n                }\n            }\n            const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n            const extensions = {};\n            if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {\n                const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n                try {\n                    const offers = extension.parse(secWebSocketExtensions);\n                    if (offers[PerMessageDeflate.extensionName]) {\n                        perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n                        extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n                    }\n                } catch (err) {\n                    const message = 'Invalid or unacceptable Sec-WebSocket-Extensions header';\n                    abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n                    return;\n                }\n            }\n            //\n            // Optionally call external client verification handler.\n            //\n            if (this.options.verifyClient) {\n                const info = {\n                    origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n                    secure: !!(req.socket.authorized || req.socket.encrypted),\n                    req\n                };\n                if (this.options.verifyClient.length === 2) {\n                    this.options.verifyClient(info, (verified, code, message, headers)=>{\n                        if (!verified) {\n                            return abortHandshake(socket, code || 401, message, headers);\n                        }\n                        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n                    });\n                    return;\n                }\n                if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n            }\n            this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n        }\n        /**\n\t   * Upgrade the connection to WebSocket.\n\t   *\n\t   * @param {Object} extensions The accepted extensions\n\t   * @param {String} key The value of the `Sec-WebSocket-Key` header\n\t   * @param {Set} protocols The subprotocols\n\t   * @param {http.IncomingMessage} req The request object\n\t   * @param {Duplex} socket The network socket between the server and client\n\t   * @param {Buffer} head The first packet of the upgraded stream\n\t   * @param {Function} cb Callback\n\t   * @throws {Error} If called more than once with the same socket\n\t   * @private\n\t   */ completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n            //\n            // Destroy the socket if the client has already sent a FIN packet.\n            //\n            if (!socket.readable || !socket.writable) return socket.destroy();\n            if (socket[kWebSocket]) {\n                throw new Error('server.handleUpgrade() was called more than once with the same ' + 'socket, possibly due to a misconfiguration');\n            }\n            if (this._state > RUNNING) return abortHandshake(socket, 503);\n            const digest = createHash('sha1').update(key + GUID).digest('base64');\n            const headers = [\n                'HTTP/1.1 101 Switching Protocols',\n                'Upgrade: websocket',\n                'Connection: Upgrade',\n                `Sec-WebSocket-Accept: ${digest}`\n            ];\n            const ws = new this.options.WebSocket(null, undefined, this.options);\n            if (protocols.size) {\n                //\n                // Optionally call external protocol selection handler.\n                //\n                const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n                if (protocol) {\n                    headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n                    ws._protocol = protocol;\n                }\n            }\n            if (extensions[PerMessageDeflate.extensionName]) {\n                const params = extensions[PerMessageDeflate.extensionName].params;\n                const value = extension.format({\n                    [PerMessageDeflate.extensionName]: [\n                        params\n                    ]\n                });\n                headers.push(`Sec-WebSocket-Extensions: ${value}`);\n                ws._extensions = extensions;\n            }\n            //\n            // Allow external modification/inspection of handshake headers.\n            //\n            this.emit('headers', headers, req);\n            socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n            socket.removeListener('error', socketOnError);\n            ws.setSocket(socket, head, {\n                allowSynchronousEvents: this.options.allowSynchronousEvents,\n                maxPayload: this.options.maxPayload,\n                skipUTF8Validation: this.options.skipUTF8Validation\n            });\n            if (this.clients) {\n                this.clients.add(ws);\n                ws.on('close', ()=>{\n                    this.clients.delete(ws);\n                    if (this._shouldEmitClose && !this.clients.size) {\n                        process.nextTick(emitClose, this);\n                    }\n                });\n            }\n            cb(ws, req);\n        }\n    }\n    websocketServer = WebSocketServer;\n    /**\n\t * Add event listeners on an `EventEmitter` using a map of <event, listener>\n\t * pairs.\n\t *\n\t * @param {EventEmitter} server The event emitter\n\t * @param {Object.<String, Function>} map The listeners to add\n\t * @return {Function} A function that will remove the added listeners when\n\t *     called\n\t * @private\n\t */ function addListeners(server, map) {\n        for (const event of Object.keys(map))server.on(event, map[event]);\n        return function removeListeners() {\n            for (const event of Object.keys(map)){\n                server.removeListener(event, map[event]);\n            }\n        };\n    }\n    /**\n\t * Emit a `'close'` event on an `EventEmitter`.\n\t *\n\t * @param {EventEmitter} server The event emitter\n\t * @private\n\t */ function emitClose(server) {\n        server._state = CLOSED;\n        server.emit('close');\n    }\n    /**\n\t * Handle socket errors.\n\t *\n\t * @private\n\t */ function socketOnError() {\n        this.destroy();\n    }\n    /**\n\t * Close the connection when preconditions are not fulfilled.\n\t *\n\t * @param {Duplex} socket The socket of the upgrade request\n\t * @param {Number} code The HTTP response status code\n\t * @param {String} [message] The HTTP response body\n\t * @param {Object} [headers] Additional HTTP response headers\n\t * @private\n\t */ function abortHandshake(socket, code, message, headers) {\n        //\n        // The socket is writable unless the user destroyed or ended it before calling\n        // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n        // error. Handling this does not make much sense as the worst that can happen\n        // is that some of the data written by the user might be discarded due to the\n        // call to `socket.end()` below, which triggers an `'error'` event that in\n        // turn causes the socket to be destroyed.\n        //\n        message = message || http.STATUS_CODES[code];\n        headers = {\n            Connection: 'close',\n            'Content-Type': 'text/html',\n            'Content-Length': Buffer.byteLength(message),\n            ...headers\n        };\n        socket.once('finish', socket.destroy);\n        socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + Object.keys(headers).map((h)=>`${h}: ${headers[h]}`).join('\\r\\n') + '\\r\\n\\r\\n' + message);\n    }\n    /**\n\t * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n\t * one listener for it, otherwise call `abortHandshake()`.\n\t *\n\t * @param {WebSocketServer} server The WebSocket server\n\t * @param {http.IncomingMessage} req The request object\n\t * @param {Duplex} socket The socket of the upgrade request\n\t * @param {Number} code The HTTP response status code\n\t * @param {String} message The HTTP response body\n\t * @private\n\t */ function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n        if (server.listenerCount('wsClientError')) {\n            const err = new Error(message);\n            Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n            server.emit('wsClientError', err, socket, req);\n        } else {\n            abortHandshake(socket, code, message);\n        }\n    }\n    return websocketServer;\n}\nrequireWebsocketServer();\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nvar WebSocket = WS;\nvar sendMessage = function(socket, message) {\n    return new Promise(function(resolve, reject) {\n        socket.send(message, function(error) {\n            if (error) {\n                reject(error);\n            } else {\n                resolve();\n            }\n        });\n    });\n};\nfunction getWebsocket(settings) {\n    return __awaiter(this, void 0, void 0, function() {\n        return __generator(this, function(_a) {\n            switch(_a.label){\n                case 0:\n                    if (!(settings.policy != undefined)) return [\n                        3 /*break*/ ,\n                        2\n                    ];\n                    return [\n                        4 /*yield*/ ,\n                        settings.policy(settings)\n                    ];\n                case 1:\n                    settings = _a.sent();\n                    _a.label = 2;\n                case 2:\n                    return [\n                        2 /*return*/ ,\n                        new WebSocket(settings.uri, settings.protocols, {\n                            headers: settings.headers\n                        })\n                    ];\n            }\n        });\n    });\n}\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nvar validationSuccess = function(message) {\n    return {\n        success: true,\n        message: message\n    };\n};\nvar validationError = function(error) {\n    return {\n        success: false,\n        error: error\n    };\n};\nvar isValidatorSuccess = function(result) {\n    return result.success;\n};\nvar WebSocketClient = /** @class */ function() {\n    function WebSocketClient(settings, handler) {\n        var _this = this;\n        this.closedPromise = undefined;\n        this.messageQueue = [];\n        this.receiverQueue = [];\n        this.done = false;\n        this.validate = handler.validate;\n        this.serialize = handler.serialize;\n        this.connectedPromise = new Promise(function(resolve, reject) {\n            return __awaiter(_this, void 0, void 0, function() {\n                var _a;\n                var _this = this;\n                return __generator(this, function(_b) {\n                    switch(_b.label){\n                        case 0:\n                            _a = this;\n                            return [\n                                4 /*yield*/ ,\n                                getWebsocket(settings)\n                            ];\n                        case 1:\n                            _a.socket = _b.sent();\n                            this.socket.onopen = function() {\n                                _this.socket.onmessage = _this.getMessageHandler();\n                                _this.closedPromise = new Promise(function(resolve) {\n                                    _this.socket.onclose = _this.getClosedHandler(resolve);\n                                });\n                                _this.socket.onerror = _this.handleError;\n                                resolve();\n                            };\n                            this.socket.onerror = function(event) {\n                                _this.handleError(event);\n                                reject(_this.error);\n                            };\n                            return [\n                                2 /*return*/ \n                            ];\n                    }\n                });\n            });\n        });\n    }\n    WebSocketClient.prototype.handleError = function(event) {\n        this.error = event.error || new Error('unknown error');\n        while(this.receiverQueue.length > 0){\n            var _a = __read(this.receiverQueue.shift(), 2);\n            _a[0];\n            var reject = _a[1];\n            reject(this.error);\n        }\n    };\n    WebSocketClient.prototype.getClosedHandler = function(closeResolve) {\n        var _this = this;\n        return function(event) {\n            if (event.code !== 1000 && _this.error === undefined) {\n                _this.error = new Error(\"WebSocket connection closed with error: \".concat(event.reason, \", code: \").concat(event.code));\n            }\n            _this.done = true;\n            while(_this.receiverQueue.length > 0){\n                var _a = __read(_this.receiverQueue.shift(), 2), resolve = _a[0], reject = _a[1];\n                if (_this.error) {\n                    reject(_this.error);\n                } else {\n                    resolve({\n                        value: undefined,\n                        done: true\n                    });\n                }\n            }\n            closeResolve();\n        };\n    };\n    WebSocketClient.prototype.getMessageHandler = function() {\n        var self = this;\n        return function(event) {\n            var result = self.validate(event);\n            if (isValidatorSuccess(result)) {\n                var message = result.message;\n                if (self.receiverQueue.length > 0) {\n                    var _a = __read(self.receiverQueue.shift(), 2), resolve = _a[0];\n                    _a[1];\n                    resolve({\n                        value: message,\n                        done: false\n                    });\n                } else {\n                    self.messageQueue.push(message);\n                }\n            } else {\n                self.error = result.error;\n                self.socket.close(1000, \"Unexpected message received\");\n            }\n        };\n    };\n    WebSocketClient.prototype[Symbol.asyncIterator] = function() {\n        var _this = this;\n        return {\n            next: function() {\n                if (_this.error) {\n                    return Promise.reject(_this.error);\n                } else if (_this.done) {\n                    return Promise.resolve({\n                        value: undefined,\n                        done: true\n                    });\n                } else if (_this.messageQueue.length > 0) {\n                    var message = _this.messageQueue.shift();\n                    return Promise.resolve({\n                        value: message,\n                        done: false\n                    });\n                } else {\n                    return new Promise(function(resolve, reject) {\n                        _this.receiverQueue.push([\n                            resolve,\n                            reject\n                        ]);\n                    });\n                }\n            }\n        };\n    };\n    WebSocketClient.prototype.send = function(message) {\n        return __awaiter(this, void 0, void 0, function() {\n            var serialized;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.connectedPromise\n                        ];\n                    case 1:\n                        _a.sent();\n                        if (this.error) {\n                            throw this.error;\n                        }\n                        serialized = this.serialize(message);\n                        return [\n                            2 /*return*/ ,\n                            sendMessage(this.socket, serialized)\n                        ];\n                }\n            });\n        });\n    };\n    WebSocketClient.prototype.close = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.connectedPromise\n                        ];\n                    case 1:\n                        _a.sent();\n                        if (this.done) {\n                            return [\n                                2 /*return*/ \n                            ];\n                        }\n                        this.socket.close();\n                        return [\n                            4 /*yield*/ ,\n                            this.closedPromise\n                        ];\n                    case 2:\n                        _a.sent();\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return WebSocketClient;\n}();\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nfunction isKeyCredential(credential) {\n    return typeof credential === \"object\" && credential !== null && \"key\" in credential && typeof credential.key === \"string\";\n}\nfunction isTokenCredential(credential) {\n    return typeof credential === \"object\" && credential !== null && \"getToken\" in credential && typeof credential.getToken === \"function\";\n}\nvar isCredential = function(credential) {\n    return isKeyCredential(credential) || isTokenCredential(credential);\n};\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nvar isRTOpenAIOptions = function(options) {\n    return typeof options === \"object\" && options !== null && \"model\" in options && typeof options.model === \"string\";\n};\nvar isRTAzureOpenAIOptions = function(options) {\n    return typeof options === \"object\" && options !== null && \"deployment\" in options && typeof options.deployment === \"string\";\n};\nvar isRTVoiceAgentOptions = function(options) {\n    return typeof options === \"object\" && options !== null && \"modelOrAgent\" in options && options.modelOrAgent !== undefined;\n};\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nfunction getUserAgent() {\n    return \"ms-rtclient/0.5.2\";\n}\nfunction openAISettings(credential, options) {\n    var uri = new URL(\"wss://api.openai.com/v1/realtime\");\n    uri.searchParams.set(\"model\", options.model);\n    return {\n        uri: uri,\n        headers: {\n            Authorization: \"Bearer \".concat(credential.key),\n            \"openai-beta\": \"realtime=v1\",\n            \"User-Agent\": \"openai-node\"\n        }\n    };\n}\nfunction azureOpenAISettings(uri, credential, options) {\n    var _this = this;\n    var _a, _b, _c;\n    var requestId = (_a = options.requestId) !== null && _a !== void 0 ? _a : crypto.randomUUID();\n    var scopes = [\n        \"https://cognitiveservices.azure.com/.default\"\n    ];\n    uri.searchParams.set(\"api-version\", (_b = options.apiVersion) !== null && _b !== void 0 ? _b : \"2024-10-01-preview\");\n    uri.searchParams.set(\"deployment\", options.deployment);\n    uri.pathname = (_c = options.path) !== null && _c !== void 0 ? _c : \"openai/realtime\";\n    return {\n        uri: uri,\n        headers: {\n            \"User-Agent\": getUserAgent(),\n            \"x-ms-client-request-id\": requestId\n        },\n        policy: function(settings) {\n            return __awaiter(_this, void 0, void 0, function() {\n                var token;\n                return __generator(this, function(_a) {\n                    switch(_a.label){\n                        case 0:\n                            if (!isKeyCredential(credential)) return [\n                                3 /*break*/ ,\n                                1\n                            ];\n                            settings.headers = __assign(__assign({}, settings.headers), {\n                                \"api-key\": credential.key\n                            });\n                            return [\n                                3 /*break*/ ,\n                                3\n                            ];\n                        case 1:\n                            return [\n                                4 /*yield*/ ,\n                                credential.getToken(scopes)\n                            ];\n                        case 2:\n                            token = _a.sent();\n                            settings.headers = __assign(__assign({}, settings.headers), {\n                                Authorization: \"Bearer \".concat(token.token),\n                                requestId: requestId\n                            });\n                            _a.label = 3;\n                        case 3:\n                            return [\n                                2 /*return*/ ,\n                                settings\n                            ];\n                    }\n                });\n            });\n        }\n    };\n}\nfunction voiceAgentSettings(uri, credential, options) {\n    var _this = this;\n    var _a, _b, _c;\n    var requestId = (_a = options.requestId) !== null && _a !== void 0 ? _a : crypto.randomUUID();\n    var scopes = [\n        \"https://cognitiveservices.azure.com/.default\"\n    ];\n    uri.searchParams.set(\"api-version\", (_b = options.apiVersion) !== null && _b !== void 0 ? _b : \"2025-05-01-preview\");\n    uri.searchParams.set(\"x-ms-client-request-id\", requestId);\n    if (typeof options.modelOrAgent === \"string\") {\n        uri.searchParams.set(\"model\", options.modelOrAgent);\n    } else {\n        uri.searchParams.set(\"agent_id\", options.modelOrAgent.agentId);\n        if (options.modelOrAgent.projectName) {\n            uri.searchParams.set(\"agent-project-name\", options.modelOrAgent.projectName);\n        }\n        if (options.modelOrAgent.agentConnectionString) {\n            uri.searchParams.set(\"agent_connection_string\", options.modelOrAgent.agentConnectionString);\n        }\n        if (options.modelOrAgent.agentAccessToken) {\n            uri.searchParams.set(\"agent_access_token\", options.modelOrAgent.agentAccessToken);\n        }\n        if (options.modelOrAgent.threadId) {\n            uri.searchParams.set(\"agent_thread_id\", options.modelOrAgent.threadId);\n        }\n    }\n    uri.pathname = (_c = options.path) !== null && _c !== void 0 ? _c : \"voice-agent/realtime\";\n    return {\n        uri: uri,\n        headers: {\n            \"User-Agent\": getUserAgent(),\n            \"x-ms-client-request-id\": requestId\n        },\n        policy: function(settings) {\n            return __awaiter(_this, void 0, void 0, function() {\n                var token;\n                return __generator(this, function(_a) {\n                    switch(_a.label){\n                        case 0:\n                            if (!isKeyCredential(credential)) return [\n                                3 /*break*/ ,\n                                1\n                            ];\n                            settings.headers = __assign(__assign({}, settings.headers), {\n                                \"api-key\": credential.key\n                            });\n                            return [\n                                3 /*break*/ ,\n                                3\n                            ];\n                        case 1:\n                            return [\n                                4 /*yield*/ ,\n                                credential.getToken(scopes)\n                            ];\n                        case 2:\n                            token = _a.sent();\n                            settings.headers = __assign(__assign({}, settings.headers), {\n                                Authorization: \"Bearer \".concat(token.token),\n                                requestId: requestId\n                            });\n                            _a.label = 3;\n                        case 3:\n                            return [\n                                2 /*return*/ ,\n                                settings\n                            ];\n                    }\n                });\n            });\n        }\n    };\n}\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nvar MessageQueue = /** @class */ function() {\n    function MessageQueue(receiveDelegate) {\n        this.receiveDelegate = receiveDelegate;\n        this.messages = [];\n        this.waitingReceivers = [];\n        this.isPolling = false;\n        this.pollPromise = null;\n    }\n    MessageQueue.prototype.pushBack = function(message) {\n        this.messages.push(message);\n    };\n    MessageQueue.prototype.findAndRemove = function(predicate) {\n        var index = this.messages.findIndex(predicate);\n        if (index === -1) {\n            return null;\n        }\n        return this.messages.splice(index, 1)[0];\n    };\n    MessageQueue.prototype.pollReceive = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                if (this.isPolling) {\n                    return [\n                        2 /*return*/ \n                    ];\n                }\n                this.isPolling = true;\n                this.pollPromise = this.doPollReceive();\n                return [\n                    2 /*return*/ ,\n                    this.pollPromise\n                ];\n            });\n        });\n    };\n    MessageQueue.prototype.doPollReceive = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var message, error_1;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        _a.trys.push([\n                            0,\n                            4,\n                            5,\n                            6\n                        ]);\n                        _a.label = 1;\n                    case 1:\n                        if (!this.isPolling) return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            this.receiveDelegate()\n                        ];\n                    case 2:\n                        message = _a.sent();\n                        if (message === null) {\n                            this.notifyEndOfStream();\n                            return [\n                                3 /*break*/ ,\n                                3\n                            ];\n                        }\n                        this.notifyReceiver(message);\n                        if (this.waitingReceivers.length === 0) {\n                            return [\n                                3 /*break*/ ,\n                                3\n                            ];\n                        }\n                        return [\n                            3 /*break*/ ,\n                            1\n                        ];\n                    case 3:\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 4:\n                        error_1 = _a.sent();\n                        this.notifyError(error_1);\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 5:\n                        this.isPolling = false;\n                        this.pollPromise = null;\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 6:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    MessageQueue.prototype.notifyError = function(error) {\n        while(this.waitingReceivers.length > 0){\n            var _a = __read(this.waitingReceivers.shift(), 3);\n            _a[0];\n            var _b = __read(_a[1], 2);\n            _b[0];\n            var reject = _b[1];\n            _a[2];\n            reject(error);\n        }\n    };\n    MessageQueue.prototype.notifyEndOfStream = function() {\n        while(this.waitingReceivers.length > 0){\n            var _a = __read(this.waitingReceivers.shift(), 3);\n            _a[0];\n            var _b = __read(_a[1], 2), resolve = _b[0];\n            _b[1];\n            _a[2];\n            resolve(null);\n        }\n    };\n    MessageQueue.prototype.notifyReceiver = function(message) {\n        var index = this.waitingReceivers.findIndex(function(_a) {\n            var _b = __read(_a, 3), predicate = _b[0], _c = __read(_b[1], 2);\n            _c[0];\n            _c[1];\n            _b[2];\n            return predicate(message);\n        });\n        if (index === -1) {\n            this.pushBack(message);\n            return;\n        }\n        var _a = __read(this.waitingReceivers.splice(index, 1)[0], 3);\n        _a[0];\n        var _b = __read(_a[1], 2), resolve = _b[0];\n        _b[1];\n        _a[2];\n        resolve(message);\n    };\n    MessageQueue.prototype.queuedMessageCount = function() {\n        return this.messages.length;\n    };\n    MessageQueue.prototype.receive = function(predicate, abort) {\n        var _this = this;\n        var foundMessage = this.findAndRemove(predicate);\n        if (foundMessage !== null) {\n            return Promise.resolve(foundMessage);\n        }\n        return new Promise(function(resolve, reject) {\n            return __awaiter(_this, void 0, void 0, function() {\n                return __generator(this, function(_a) {\n                    switch(_a.label){\n                        case 0:\n                            this.waitingReceivers.push([\n                                predicate,\n                                [\n                                    resolve,\n                                    reject\n                                ],\n                                abort || new AbortController()\n                            ]);\n                            return [\n                                4 /*yield*/ ,\n                                this.pollReceive()\n                            ];\n                        case 1:\n                            _a.sent();\n                            return [\n                                2 /*return*/ \n                            ];\n                    }\n                });\n            });\n        });\n    };\n    return MessageQueue;\n}();\nvar MessageQueueWithError = /** @class */ function(_super) {\n    __extends(MessageQueueWithError, _super);\n    function MessageQueueWithError(receiveDelegate, errorPredicate) {\n        var _this = _super.call(this, receiveDelegate) || this;\n        _this.errorPredicate = errorPredicate;\n        _this.error = undefined;\n        return _this;\n    }\n    MessageQueueWithError.prototype.notifyErrorMessage = function(message) {\n        while(this.waitingReceivers.length > 0){\n            var _a = __read(this.waitingReceivers.shift(), 2);\n            _a[0];\n            var _b = __read(_a[1], 2), resolve = _b[0];\n            _b[1];\n            resolve(message);\n        }\n    };\n    MessageQueueWithError.prototype.notifyReceiver = function(message) {\n        if (this.errorPredicate(message)) {\n            this.error = message;\n            this.notifyErrorMessage(message);\n            return;\n        }\n        var index = this.waitingReceivers.findIndex(function(_a) {\n            var _b = __read(_a, 3), predicate = _b[0], _c = __read(_b[1], 2);\n            _c[0];\n            _c[1];\n            _b[2];\n            return predicate(message);\n        });\n        if (index === -1) {\n            this.pushBack(message);\n            return;\n        }\n        var _a = __read(this.waitingReceivers.splice(index, 1)[0], 3);\n        _a[0];\n        var _b = __read(_a[1], 2), resolve = _b[0];\n        _b[1];\n        _a[2];\n        resolve(message);\n    };\n    MessageQueueWithError.prototype.receive = function(predicate) {\n        return __awaiter(this, void 0, void 0, function() {\n            var message;\n            var _this = this;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        if (this.error !== undefined) {\n                            return [\n                                2 /*return*/ ,\n                                this.error\n                            ];\n                        }\n                        return [\n                            4 /*yield*/ ,\n                            _super.prototype.receive.call(this, function(message) {\n                                return predicate(message) || _this.errorPredicate(message);\n                            })\n                        ];\n                    case 1:\n                        message = _a.sent();\n                        return [\n                            2 /*return*/ ,\n                            message\n                        ];\n                }\n            });\n        });\n    };\n    return MessageQueueWithError;\n}(MessageQueue);\nvar SharedEndQueue = /** @class */ function() {\n    function SharedEndQueue(receiveDelegate, errorPredicate, endPredicate) {\n        this.receiveDelegate = receiveDelegate;\n        this.errorPredicate = errorPredicate;\n        this.endPredicate = endPredicate;\n        this.queue = [];\n        this.lock = Promise.resolve();\n    }\n    SharedEndQueue.prototype.receive = function(predicate) {\n        return __awaiter(this, void 0, void 0, function() {\n            var release, i, message, message;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.acquireLock()\n                        ];\n                    case 1:\n                        release = _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([\n                            2,\n                            ,\n                            6,\n                            7\n                        ]);\n                        for(i = 0; i < this.queue.length; i++){\n                            message = this.queue[i];\n                            if (predicate(message)) {\n                                this.queue.splice(i, 1);\n                                return [\n                                    2 /*return*/ ,\n                                    message\n                                ];\n                            } else if (this.endPredicate(message)) {\n                                return [\n                                    2 /*return*/ ,\n                                    message\n                                ];\n                            }\n                        }\n                        _a.label = 3;\n                    case 3:\n                        return [\n                            4 /*yield*/ ,\n                            this.receiveDelegate()\n                        ];\n                    case 4:\n                        message = _a.sent();\n                        if (message === null || this.errorPredicate(message) || predicate(message)) {\n                            return [\n                                2 /*return*/ ,\n                                message\n                            ];\n                        }\n                        if (this.endPredicate(message)) {\n                            this.queue.push(message);\n                            return [\n                                2 /*return*/ ,\n                                message\n                            ];\n                        }\n                        this.queue.push(message);\n                        return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                    case 5:\n                        return [\n                            3 /*break*/ ,\n                            7\n                        ];\n                    case 6:\n                        release();\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 7:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    SharedEndQueue.prototype.acquireLock = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var release, newLock, oldLock;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        newLock = new Promise(function(resolve) {\n                            release = resolve;\n                        });\n                        oldLock = this.lock;\n                        this.lock = newLock;\n                        return [\n                            4 /*yield*/ ,\n                            oldLock\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            2 /*return*/ ,\n                            release\n                        ];\n                }\n            });\n        });\n    };\n    return SharedEndQueue;\n}();\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nfunction getRandomValues(array) {\n    if (typeof crypto !== \"undefined\" && crypto.getRandomValues) {\n        return crypto.getRandomValues(array);\n    } else if (false) {} else {\n        throw new Error(\"No secure random number generator available.\");\n    }\n}\nfunction generateId(prefix, length) {\n    var array = new Uint8Array(length);\n    getRandomValues(array);\n    var base64 = btoa(String.fromCharCode.apply(String, __spreadArray([], __read(array), false))).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n    return \"\".concat(prefix, \"-\").concat(base64).slice(0, length);\n}\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nvar LowLevelRTClient = /** @class */ function() {\n    function LowLevelRTClient(uriOrCredential, credentialOrOptions, options) {\n        var settings = function() {\n            if (isKeyCredential(uriOrCredential) && isRTOpenAIOptions(credentialOrOptions)) {\n                return openAISettings(uriOrCredential, credentialOrOptions);\n            } else if (isCredential(credentialOrOptions) && isRTAzureOpenAIOptions(options)) {\n                return azureOpenAISettings(uriOrCredential, credentialOrOptions, options);\n            } else if (isCredential(credentialOrOptions) && isRTVoiceAgentOptions(options)) {\n                return voiceAgentSettings(uriOrCredential, credentialOrOptions, options);\n            } else {\n                throw new Error(\"Invalid combination of arguments to initialize the Realtime client\");\n            }\n        }();\n        this.requestId = settings.requestId;\n        this.client = this.getWebsocket(settings);\n    }\n    LowLevelRTClient.prototype.getWebsocket = function(settings) {\n        var handler = {\n            validate: function(event) {\n                if (typeof event.data !== \"string\") {\n                    return validationError(new Error(\"Invalid message type\"));\n                }\n                try {\n                    var data = JSON.parse(event.data);\n                    if (isServerMessageType(data)) {\n                        return validationSuccess(data);\n                    }\n                    return validationError(new Error(\"Invalid message type\"));\n                } catch (error) {\n                    return validationError(new Error(\"Invalid JSON message\"));\n                }\n            },\n            serialize: function(message) {\n                return JSON.stringify(message);\n            }\n        };\n        return new WebSocketClient(settings, handler);\n    };\n    LowLevelRTClient.prototype.messages = function() {\n        return __asyncGenerator(this, arguments, function messages_1() {\n            var _a, _b, _c, message, e_1_1;\n            var _d, e_1, _e, _f;\n            return __generator(this, function(_g) {\n                switch(_g.label){\n                    case 0:\n                        _g.trys.push([\n                            0,\n                            7,\n                            8,\n                            13\n                        ]);\n                        _a = true, _b = __asyncValues(this.client);\n                        _g.label = 1;\n                    case 1:\n                        return [\n                            4 /*yield*/ ,\n                            __await(_b.next())\n                        ];\n                    case 2:\n                        if (!(_c = _g.sent(), _d = _c.done, !_d)) return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                        _f = _c.value;\n                        _a = false;\n                        message = _f;\n                        return [\n                            4 /*yield*/ ,\n                            __await(message)\n                        ];\n                    case 3:\n                        return [\n                            4 /*yield*/ ,\n                            _g.sent()\n                        ];\n                    case 4:\n                        _g.sent();\n                        _g.label = 5;\n                    case 5:\n                        _a = true;\n                        return [\n                            3 /*break*/ ,\n                            1\n                        ];\n                    case 6:\n                        return [\n                            3 /*break*/ ,\n                            13\n                        ];\n                    case 7:\n                        e_1_1 = _g.sent();\n                        e_1 = {\n                            error: e_1_1\n                        };\n                        return [\n                            3 /*break*/ ,\n                            13\n                        ];\n                    case 8:\n                        _g.trys.push([\n                            8,\n                            ,\n                            11,\n                            12\n                        ]);\n                        if (!(!_a && !_d && (_e = _b.return))) return [\n                            3 /*break*/ ,\n                            10\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            __await(_e.call(_b))\n                        ];\n                    case 9:\n                        _g.sent();\n                        _g.label = 10;\n                    case 10:\n                        return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                    case 11:\n                        if (e_1) throw e_1.error;\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 12:\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 13:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    LowLevelRTClient.prototype.send = function(message) {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send(message)\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    LowLevelRTClient.prototype.close = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.client.close()\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return LowLevelRTClient;\n}();\nvar RTError = /** @class */ function(_super) {\n    __extends(RTError, _super);\n    function RTError(errorDetails) {\n        var _this = _super.call(this, errorDetails.message) || this;\n        _this.errorDetails = errorDetails;\n        Object.setPrototypeOf(_this, RTError.prototype);\n        return _this;\n    }\n    Object.defineProperty(RTError.prototype, \"code\", {\n        get: function() {\n            return this.errorDetails.code;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTError.prototype, \"param\", {\n        get: function() {\n            return this.errorDetails.param;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTError.prototype, \"eventId\", {\n        get: function() {\n            return this.errorDetails.event_id;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return RTError;\n}(Error);\nvar RTInputAudioItem = /** @class */ function() {\n    function RTInputAudioItem(id, audioStartMillis, hasTranscription, queue) {\n        this.id = id;\n        this.audioStartMillis = audioStartMillis;\n        this.hasTranscription = hasTranscription;\n        this.queue = queue;\n        this.type = \"input_audio\";\n        this.audioEndMillis = undefined;\n        this.transcription = undefined;\n        this.waitPromise = null;\n    }\n    RTInputAudioItem.create = function(id, audioStartMillis, hasTranscription, queue) {\n        return new RTInputAudioItem(id, audioStartMillis, hasTranscription, queue);\n    };\n    RTInputAudioItem.prototype.wait = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var itemIdValidMessage, message;\n            var _this = this;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        itemIdValidMessage = function(message) {\n                            return [\n                                \"input_audio_buffer.speech_stopped\",\n                                \"conversation.item.input_audio_transcription.completed\",\n                                \"conversation.item.input_audio_transcription.failed\"\n                            ].includes(message.type);\n                        };\n                        _a.label = 1;\n                    case 1:\n                        return [\n                            4 /*yield*/ ,\n                            this.queue.receive(function(m) {\n                                return itemIdValidMessage(m) && m.item_id == _this.id || m.type === \"conversation.item.created\" && m.item.id == _this.id;\n                            })\n                        ];\n                    case 2:\n                        message = _a.sent();\n                        if (message === null) {\n                            return [\n                                2 /*return*/ \n                            ];\n                        } else if (message.type === \"error\") {\n                            throw new RTError(message.error);\n                        } else if (message.type === \"input_audio_buffer.speech_stopped\") {\n                            this.audioEndMillis = message.audio_end_ms;\n                            if (!this.hasTranscription) {\n                                return [\n                                    2 /*return*/ \n                                ];\n                            }\n                        } else if (message.type === \"conversation.item.created\" && !this.hasTranscription) {\n                            return [\n                                2 /*return*/ \n                            ];\n                        } else if (message.type === \"conversation.item.input_audio_transcription.completed\") {\n                            this.transcription = message.transcript;\n                            return [\n                                2 /*return*/ \n                            ];\n                        } else if (message.type === \"conversation.item.input_audio_transcription.failed\") {\n                            throw new RTError(message.error);\n                        }\n                        return [\n                            3 /*break*/ ,\n                            1\n                        ];\n                    case 3:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    RTInputAudioItem.prototype.waitForCompletion = function() {\n        if (!this.waitPromise) {\n            this.waitPromise = this.wait();\n        }\n        return this.waitPromise;\n    };\n    return RTInputAudioItem;\n}();\n/* TODO: Move to PAL so we use Buffer.from in Node */ function decodeBase64(base64) {\n    var binaryString = atob(base64);\n    var length = binaryString.length;\n    var uint8Array = new Uint8Array(length);\n    for(var i = 0; i < length; i++){\n        uint8Array[i] = binaryString.charCodeAt(i);\n    }\n    return uint8Array;\n}\nvar RTAudioContent = /** @class */ function() {\n    function RTAudioContent(message, queue) {\n        var _this = this;\n        this.queue = queue;\n        this.type = \"audio\";\n        this.itemId = message.item_id;\n        this.contentIndex = message.content_index;\n        if (message.part.type !== \"audio\") {\n            throw new Error(\"Unexpected part type\");\n        }\n        this.part = message.part;\n        this.contentQueue = new SharedEndQueue(function() {\n            return _this.receiveContent();\n        }, function(m) {\n            return m !== null && m.type === \"error\";\n        }, function(m) {\n            return m !== null && m.type === \"response.content_part.done\";\n        });\n    }\n    RTAudioContent.create = function(message, queue) {\n        return new RTAudioContent(message, queue);\n    };\n    Object.defineProperty(RTAudioContent.prototype, \"transcript\", {\n        get: function() {\n            return this.part.transcript;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    RTAudioContent.prototype.receiveContent = function() {\n        var _this = this;\n        function isValidMessage(m) {\n            return [\n                \"response.audio.delta\",\n                \"response.audio.done\",\n                \"response.audio_transcript.delta\",\n                \"response.audio_transcript.done\",\n                \"response.content_part.done\"\n            ].includes(m.type);\n        }\n        return this.queue.receive(function(m) {\n            return isValidMessage(m) && m.item_id === _this.itemId && m.content_index === _this.contentIndex;\n        });\n    };\n    RTAudioContent.prototype.audioChunks = function() {\n        return __asyncGenerator(this, arguments, function audioChunks_1() {\n            var message, buffer;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            __await(this.contentQueue.receive(function(m) {\n                                return m !== null && [\n                                    \"response.audio.delta\",\n                                    \"response.audio.done\"\n                                ].includes(m.type);\n                            }))\n                        ];\n                    case 1:\n                        message = _a.sent();\n                        if (!(message === null)) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                    case 2:\n                        if (!(message.type === \"error\")) return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                        throw new RTError(message.error);\n                    case 3:\n                        if (!(message.type === \"response.content_part.done\")) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        if (message.part.type !== \"audio\") {\n                            throw new Error(\"Unexpected part type\");\n                        }\n                        this.part = message.part;\n                        return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                    case 4:\n                        if (!(message.type === \"response.audio.delta\")) return [\n                            3 /*break*/ ,\n                            7\n                        ];\n                        buffer = decodeBase64(message.delta);\n                        return [\n                            4 /*yield*/ ,\n                            __await(buffer)\n                        ];\n                    case 5:\n                        return [\n                            4 /*yield*/ ,\n                            _a.sent()\n                        ];\n                    case 6:\n                        _a.sent();\n                        return [\n                            3 /*break*/ ,\n                            8\n                        ];\n                    case 7:\n                        if (message.type === \"response.audio.done\") {\n                            // We are skipping this as it's information is already provided by 'response.content_part.done'\n                            // and that is a better signal to end the iteration\n                            return [\n                                3 /*break*/ ,\n                                0\n                            ];\n                        }\n                        _a.label = 8;\n                    case 8:\n                        return [\n                            3 /*break*/ ,\n                            0\n                        ];\n                    case 9:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    RTAudioContent.prototype.transcriptChunks = function() {\n        return __asyncGenerator(this, arguments, function transcriptChunks_1() {\n            var message;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            __await(this.contentQueue.receive(function(m) {\n                                return m !== null && [\n                                    \"response.audio_transcript.delta\",\n                                    \"response.audio_transcript.done\"\n                                ].includes(m.type);\n                            }))\n                        ];\n                    case 1:\n                        message = _a.sent();\n                        if (!(message === null)) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                    case 2:\n                        if (!(message.type === \"error\")) return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                        throw new RTError(message.error);\n                    case 3:\n                        if (!(message.type === \"response.content_part.done\")) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        if (message.part.type !== \"audio\") {\n                            throw new Error(\"Unexpected part type\");\n                        }\n                        this.part = message.part;\n                        return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                    case 4:\n                        if (!(message.type === \"response.audio_transcript.delta\")) return [\n                            3 /*break*/ ,\n                            7\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            __await(message.delta)\n                        ];\n                    case 5:\n                        return [\n                            4 /*yield*/ ,\n                            _a.sent()\n                        ];\n                    case 6:\n                        _a.sent();\n                        return [\n                            3 /*break*/ ,\n                            8\n                        ];\n                    case 7:\n                        if (message.type === \"response.audio_transcript.done\") {\n                            // We are skipping this as it's information is already provided by 'response.content_part.done'\n                            // and that is a better signal to end the iteration\n                            return [\n                                3 /*break*/ ,\n                                0\n                            ];\n                        }\n                        _a.label = 8;\n                    case 8:\n                        return [\n                            3 /*break*/ ,\n                            0\n                        ];\n                    case 9:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return RTAudioContent;\n}();\nvar RTTextContent = /** @class */ function() {\n    function RTTextContent(message, queue) {\n        this.queue = queue;\n        this.type = \"text\";\n        this.itemId = message.item_id;\n        this.contentIndex = message.content_index;\n        if (message.part.type !== \"text\") {\n            throw new Error(\"Unexpected part type\");\n        }\n        this.part = message.part;\n    }\n    RTTextContent.create = function(message, queue) {\n        return new RTTextContent(message, queue);\n    };\n    Object.defineProperty(RTTextContent.prototype, \"text\", {\n        get: function() {\n            return this.part.text;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    RTTextContent.prototype.textChunks = function() {\n        return __asyncGenerator(this, arguments, function textChunks_1() {\n            var message;\n            var _this = this;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            __await(this.queue.receive(function(m) {\n                                return (m.type === \"response.content_part.done\" || m.type === \"response.text.delta\" || m.type === \"response.text.done\") && m.item_id === _this.itemId && m.content_index === _this.contentIndex;\n                            }))\n                        ];\n                    case 1:\n                        message = _a.sent();\n                        if (!(message === null)) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                    case 2:\n                        if (!(message.type === \"error\")) return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                        throw new RTError(message.error);\n                    case 3:\n                        if (!(message.type === \"response.content_part.done\")) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        if (message.part.type !== \"text\") {\n                            throw new Error(\"Unexpected part type\");\n                        }\n                        this.part = message.part;\n                        return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                    case 4:\n                        if (!(message.type === \"response.text.delta\")) return [\n                            3 /*break*/ ,\n                            7\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            __await(message.delta)\n                        ];\n                    case 5:\n                        return [\n                            4 /*yield*/ ,\n                            _a.sent()\n                        ];\n                    case 6:\n                        _a.sent();\n                        return [\n                            3 /*break*/ ,\n                            8\n                        ];\n                    case 7:\n                        if (message.type === \"response.text.done\") {\n                            // We are skipping this as it's information is already provided by 'response.content_part.done'\n                            // and that is a better signal to end the iteration\n                            return [\n                                3 /*break*/ ,\n                                0\n                            ];\n                        }\n                        _a.label = 8;\n                    case 8:\n                        return [\n                            3 /*break*/ ,\n                            0\n                        ];\n                    case 9:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return RTTextContent;\n}();\nvar RTMessageItem = /** @class */ function() {\n    function RTMessageItem(responseId, item, previousItemId, queue) {\n        this.responseId = responseId;\n        this.item = item;\n        this.previousItemId = previousItemId;\n        this.queue = queue;\n        this.type = \"message\";\n    }\n    RTMessageItem.create = function(responseId, item, previousItemId, queue) {\n        return new RTMessageItem(responseId, item, previousItemId, queue);\n    };\n    Object.defineProperty(RTMessageItem.prototype, \"id\", {\n        get: function() {\n            return this.item.id;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTMessageItem.prototype, \"role\", {\n        get: function() {\n            return this.item.role;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTMessageItem.prototype, \"status\", {\n        get: function() {\n            return this.item.status;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    RTMessageItem.prototype[Symbol.asyncIterator] = function() {\n        return __asyncGenerator(this, arguments, function _a() {\n            var message;\n            var _this = this;\n            return __generator(this, function(_b) {\n                switch(_b.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            __await(this.queue.receive(function(m) {\n                                return m.type === \"response.content_part.added\" && m.item_id === _this.id || m.type === \"response.output_item.done\" && m.item.id === _this.id;\n                            }))\n                        ];\n                    case 1:\n                        message = _b.sent();\n                        if (!(message === null)) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        return [\n                            3 /*break*/ ,\n                            14\n                        ];\n                    case 2:\n                        if (!(message.type === \"error\")) return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                        throw new RTError(message.error);\n                    case 3:\n                        if (!(message.type === \"response.output_item.done\")) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        if (message.item.type === \"message\") {\n                            this.item = message.item;\n                        } else {\n                            throw new Error(\"Unexpected item type\");\n                        }\n                        return [\n                            3 /*break*/ ,\n                            14\n                        ];\n                    case 4:\n                        if (!(message.type === \"response.content_part.added\")) return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                        if (!(message.part.type === \"audio\")) return [\n                            3 /*break*/ ,\n                            7\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            __await(RTAudioContent.create(message, this.queue))\n                        ];\n                    case 5:\n                        return [\n                            4 /*yield*/ ,\n                            _b.sent()\n                        ];\n                    case 6:\n                        _b.sent();\n                        return [\n                            3 /*break*/ ,\n                            11\n                        ];\n                    case 7:\n                        if (!(message.part.type === \"text\")) return [\n                            3 /*break*/ ,\n                            10\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            __await(RTTextContent.create(message, this.queue))\n                        ];\n                    case 8:\n                        return [\n                            4 /*yield*/ ,\n                            _b.sent()\n                        ];\n                    case 9:\n                        _b.sent();\n                        return [\n                            3 /*break*/ ,\n                            11\n                        ];\n                    case 10:\n                        throw new Error(\"Unexpected part type: \".concat(message.part.type));\n                    case 11:\n                        return [\n                            3 /*break*/ ,\n                            13\n                        ];\n                    case 12:\n                        throw new Error(\"Unexpected message type: \".concat(message.type));\n                    case 13:\n                        return [\n                            3 /*break*/ ,\n                            0\n                        ];\n                    case 14:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return RTMessageItem;\n}();\nvar RTFunctionCallItem = /** @class */ function() {\n    function RTFunctionCallItem(responseId, item, previousItemId, queue) {\n        this.responseId = responseId;\n        this.item = item;\n        this.previousItemId = previousItemId;\n        this.queue = queue;\n        this.type = \"function_call\";\n        this.awaited = false;\n        this.iterated = false;\n    }\n    RTFunctionCallItem.create = function(responseId, item, previousItemId, queue) {\n        return new RTFunctionCallItem(responseId, item, previousItemId, queue);\n    };\n    Object.defineProperty(RTFunctionCallItem.prototype, \"id\", {\n        get: function() {\n            return this.item.id;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTFunctionCallItem.prototype, \"functionName\", {\n        get: function() {\n            return this.item.name;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTFunctionCallItem.prototype, \"callId\", {\n        get: function() {\n            return this.item.call_id;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTFunctionCallItem.prototype, \"arguments\", {\n        get: function() {\n            return this.item.arguments;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    RTFunctionCallItem.prototype.inner = function() {\n        return __asyncGenerator(this, arguments, function inner_1() {\n            var message;\n            var _this = this;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            __await(this.queue.receive(function(m) {\n                                return (m.type == \"response.function_call_arguments.delta\" || m.type == \"response.function_call_arguments.done\") && m.item_id === _this.id || m.type === \"response.output_item.done\" && m.item.id === _this.id;\n                            }))\n                        ];\n                    case 1:\n                        message = _a.sent();\n                        if (!(message === null)) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                    case 2:\n                        if (!(message.type === \"error\")) return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                        throw new RTError(message.error);\n                    case 3:\n                        if (!(message.type === \"response.output_item.done\")) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        if (message.item.type === \"function_call\") {\n                            this.item = message.item;\n                            return [\n                                3 /*break*/ ,\n                                9\n                            ];\n                        } else {\n                            throw new Error(\"Unexpected item type\");\n                        }\n                    case 4:\n                        if (!(message.type === \"response.function_call_arguments.delta\")) return [\n                            3 /*break*/ ,\n                            7\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            __await(message.delta)\n                        ];\n                    case 5:\n                        return [\n                            4 /*yield*/ ,\n                            _a.sent()\n                        ];\n                    case 6:\n                        _a.sent();\n                        return [\n                            3 /*break*/ ,\n                            8\n                        ];\n                    case 7:\n                        if (message.type === \"response.function_call_arguments.done\") {\n                            return [\n                                3 /*break*/ ,\n                                0\n                            ];\n                        } else {\n                            throw new Error(\"Unexpected message type: \".concat(message.type));\n                        }\n                    case 8:\n                        return [\n                            3 /*break*/ ,\n                            0\n                        ];\n                    case 9:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    RTFunctionCallItem.prototype[Symbol.asyncIterator] = function() {\n        return __asyncGenerator(this, arguments, function _a() {\n            return __generator(this, function(_b) {\n                switch(_b.label){\n                    case 0:\n                        if (this.awaited) {\n                            throw new Error(\"Cannot iterate after awaiting.\");\n                        }\n                        this.iterated = true;\n                        return [\n                            4 /*yield*/ ,\n                            __await(this.inner())\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _b.sent()\n                        ];\n                }\n            });\n        });\n    };\n    RTFunctionCallItem.prototype.waitForCompletion = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var _a, _b, _c, e_2_1;\n            var _d, e_2, _e;\n            return __generator(this, function(_g) {\n                switch(_g.label){\n                    case 0:\n                        if (this.iterated) {\n                            throw new Error(\"Cannot await after iterating.\");\n                        }\n                        this.awaited = true;\n                        _g.label = 1;\n                    case 1:\n                        _g.trys.push([\n                            1,\n                            6,\n                            7,\n                            12\n                        ]);\n                        _a = true, _b = __asyncValues(this.inner());\n                        _g.label = 2;\n                    case 2:\n                        return [\n                            4 /*yield*/ ,\n                            _b.next()\n                        ];\n                    case 3:\n                        if (!(_c = _g.sent(), _d = _c.done, !_d)) return [\n                            3 /*break*/ ,\n                            5\n                        ];\n                        _c.value;\n                        _a = false;\n                        _g.label = 4;\n                    case 4:\n                        _a = true;\n                        return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                    case 5:\n                        return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                    case 6:\n                        e_2_1 = _g.sent();\n                        e_2 = {\n                            error: e_2_1\n                        };\n                        return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                    case 7:\n                        _g.trys.push([\n                            7,\n                            ,\n                            10,\n                            11\n                        ]);\n                        if (!(!_a && !_d && (_e = _b.return))) return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            _e.call(_b)\n                        ];\n                    case 8:\n                        _g.sent();\n                        _g.label = 9;\n                    case 9:\n                        return [\n                            3 /*break*/ ,\n                            11\n                        ];\n                    case 10:\n                        if (e_2) throw e_2.error;\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 11:\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 12:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return RTFunctionCallItem;\n}();\nfunction isMessageItem(item) {\n    return item.type === \"message\";\n}\nfunction isFunctionCallItem(item) {\n    return item.type === \"function_call\";\n}\nvar RTResponse = /** @class */ function() {\n    function RTResponse(response, queue, client) {\n        this.response = response;\n        this.queue = queue;\n        this.client = client;\n        this.type = \"response\";\n        this.done = false;\n    }\n    RTResponse.create = function(response, queue, client) {\n        return new RTResponse(response, queue, client);\n    };\n    Object.defineProperty(RTResponse.prototype, \"id\", {\n        get: function() {\n            return this.response.id;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTResponse.prototype, \"status\", {\n        get: function() {\n            return this.response.status;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTResponse.prototype, \"statusDetails\", {\n        get: function() {\n            return this.response.status_details;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTResponse.prototype, \"output\", {\n        get: function() {\n            return this.response.output;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTResponse.prototype, \"usage\", {\n        get: function() {\n            return this.response.usage;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    RTResponse.prototype.cancel = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var _a, _b, _c, e_3_1;\n            var _d, e_3, _e;\n            return __generator(this, function(_g) {\n                switch(_g.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send({\n                                type: \"response.cancel\"\n                            })\n                        ];\n                    case 1:\n                        _g.sent();\n                        _g.label = 2;\n                    case 2:\n                        _g.trys.push([\n                            2,\n                            7,\n                            8,\n                            13\n                        ]);\n                        _a = true, _b = __asyncValues(this);\n                        _g.label = 3;\n                    case 3:\n                        return [\n                            4 /*yield*/ ,\n                            _b.next()\n                        ];\n                    case 4:\n                        if (!(_c = _g.sent(), _d = _c.done, !_d)) return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                        _c.value;\n                        _a = false;\n                        _g.label = 5;\n                    case 5:\n                        _a = true;\n                        return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                    case 6:\n                        return [\n                            3 /*break*/ ,\n                            13\n                        ];\n                    case 7:\n                        e_3_1 = _g.sent();\n                        e_3 = {\n                            error: e_3_1\n                        };\n                        return [\n                            3 /*break*/ ,\n                            13\n                        ];\n                    case 8:\n                        _g.trys.push([\n                            8,\n                            ,\n                            11,\n                            12\n                        ]);\n                        if (!(!_a && !_d && (_e = _b.return))) return [\n                            3 /*break*/ ,\n                            10\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            _e.call(_b)\n                        ];\n                    case 9:\n                        _g.sent();\n                        _g.label = 10;\n                    case 10:\n                        return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                    case 11:\n                        if (e_3) throw e_3.error;\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 12:\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 13:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    RTResponse.prototype[Symbol.asyncIterator] = function() {\n        var _this = this;\n        return {\n            next: function() {\n                return __awaiter(_this, void 0, void 0, function() {\n                    var message, created_message, messageItem, functionCallItem;\n                    var _this = this;\n                    return __generator(this, function(_a) {\n                        switch(_a.label){\n                            case 0:\n                                if (this.done) {\n                                    return [\n                                        2 /*return*/ ,\n                                        {\n                                            value: undefined,\n                                            done: true\n                                        }\n                                    ];\n                                }\n                                return [\n                                    4 /*yield*/ ,\n                                    this.queue.receive(function(m) {\n                                        return m.type === \"response.done\" && m.response.id === _this.id || m.type === \"response.output_item.added\" && m.response_id === _this.id;\n                                    })\n                                ];\n                            case 1:\n                                message = _a.sent();\n                                if (!(message === null)) return [\n                                    3 /*break*/ ,\n                                    2\n                                ];\n                                return [\n                                    2 /*return*/ ,\n                                    {\n                                        value: undefined,\n                                        done: true\n                                    }\n                                ];\n                            case 2:\n                                if (!(message.type === \"error\")) return [\n                                    3 /*break*/ ,\n                                    3\n                                ];\n                                throw new RTError(message.error);\n                            case 3:\n                                if (!(message.type === \"response.done\")) return [\n                                    3 /*break*/ ,\n                                    4\n                                ];\n                                this.done = true;\n                                this.response = message.response;\n                                return [\n                                    2 /*return*/ ,\n                                    {\n                                        value: undefined,\n                                        done: true\n                                    }\n                                ];\n                            case 4:\n                                if (!(message.type === \"response.output_item.added\")) return [\n                                    3 /*break*/ ,\n                                    6\n                                ];\n                                return [\n                                    4 /*yield*/ ,\n                                    this.queue.receive(function(m) {\n                                        return m.type === \"conversation.item.created\" && m.item.id === message.item.id;\n                                    })\n                                ];\n                            case 5:\n                                created_message = _a.sent();\n                                if (created_message === null) {\n                                    return [\n                                        2 /*return*/ ,\n                                        {\n                                            value: undefined,\n                                            done: true\n                                        }\n                                    ];\n                                } else if (created_message.type === \"error\") {\n                                    throw new RTError(created_message.error);\n                                } else if (created_message.type === \"conversation.item.created\") {\n                                    if (created_message.item.type === \"message\") {\n                                        messageItem = RTMessageItem.create(this.id, created_message.item, created_message.previous_item_id, this.queue);\n                                        return [\n                                            2 /*return*/ ,\n                                            {\n                                                value: messageItem,\n                                                done: false\n                                            }\n                                        ];\n                                    } else if (created_message.item.type === \"function_call\") {\n                                        functionCallItem = RTFunctionCallItem.create(this.id, created_message.item, created_message.previous_item_id, this.queue);\n                                        return [\n                                            2 /*return*/ ,\n                                            {\n                                                value: functionCallItem,\n                                                done: false\n                                            }\n                                        ];\n                                    } else {\n                                        throw new Error(\"Unexpected item type (\".concat(created_message.item.type, \".\"));\n                                    }\n                                } else {\n                                    throw new Error(\"Unexpected message type: \".concat(created_message.type));\n                                }\n                            case 6:\n                                throw new Error(\"Unexpected message type: \".concat(message.type));\n                            case 7:\n                                return [\n                                    2 /*return*/ \n                                ];\n                        }\n                    });\n                });\n            }\n        };\n    };\n    return RTResponse;\n}();\nvar RTClient = /** @class */ function() {\n    function RTClient(uriOrCredential, credentialOrOptions, options) {\n        var _this = this;\n        this.iterating = false;\n        this.client = function() {\n            if (isKeyCredential(uriOrCredential)) {\n                return new LowLevelRTClient(uriOrCredential, credentialOrOptions);\n            } else {\n                return new LowLevelRTClient(uriOrCredential, credentialOrOptions, options);\n            }\n        }();\n        this.messagesIterable = this.client.messages()[Symbol.asyncIterator]();\n        this.messageQueue = new MessageQueueWithError(function() {\n            return _this.receiveMessages();\n        }, function(m) {\n            return m.type === \"error\";\n        });\n    }\n    RTClient.prototype.receiveMessages = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var result;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.messagesIterable.next()\n                        ];\n                    case 1:\n                        result = _a.sent();\n                        return [\n                            2 /*return*/ ,\n                            result.done ? null : result.value\n                        ];\n                }\n            });\n        });\n    };\n    Object.defineProperty(RTClient.prototype, \"requestId\", {\n        get: function() {\n            return this.client.requestId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    RTClient.prototype.init = function() {\n        var _this = this;\n        if (this.initPromise !== undefined) {\n            return this.initPromise;\n        }\n        this.initPromise = function() {\n            return __awaiter(_this, void 0, void 0, function() {\n                var message;\n                return __generator(this, function(_a) {\n                    switch(_a.label){\n                        case 0:\n                            if (this.session !== undefined) {\n                                return [\n                                    2 /*return*/ \n                                ];\n                            }\n                            return [\n                                4 /*yield*/ ,\n                                this.messageQueue.receive(function(m) {\n                                    return m.type === \"session.created\";\n                                })\n                            ];\n                        case 1:\n                            message = _a.sent();\n                            if (message === null) {\n                                throw new Error(\"Failed to initialize session\");\n                            }\n                            if (message.type === \"error\") {\n                                throw new RTError(message.error);\n                            }\n                            if (message.type !== \"session.created\") {\n                                throw new Error(\"Unexpected message type\");\n                            }\n                            this.session = message.session;\n                            return [\n                                2 /*return*/ \n                            ];\n                    }\n                });\n            });\n        }();\n        return this.initPromise;\n    };\n    RTClient.prototype.configure = function(params) {\n        return __awaiter(this, void 0, void 0, function() {\n            var message;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.init()\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send({\n                                type: \"session.update\",\n                                session: params\n                            })\n                        ];\n                    case 2:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.messageQueue.receive(function(m) {\n                                return m.type === \"session.updated\";\n                            })\n                        ];\n                    case 3:\n                        message = _a.sent();\n                        if (message === null) {\n                            throw new Error(\"Failed to update session\");\n                        }\n                        if (message.type === \"error\") {\n                            throw new RTError(message.error);\n                        }\n                        if (message.type !== \"session.updated\") {\n                            throw new Error(\"Unexpected message type\");\n                        }\n                        this.session = message.session;\n                        return [\n                            2 /*return*/ ,\n                            this.session\n                        ];\n                }\n            });\n        });\n    };\n    RTClient.prototype.sendAudio = function(audio) {\n        return __awaiter(this, void 0, void 0, function() {\n            var base64;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.init()\n                        ];\n                    case 1:\n                        _a.sent();\n                        base64 = btoa(String.fromCharCode.apply(String, __spreadArray([], __read(audio), false)));\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send({\n                                type: \"input_audio_buffer.append\",\n                                audio: base64\n                            })\n                        ];\n                    case 2:\n                        _a.sent();\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    RTClient.prototype.commitAudio = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var message;\n            var _a, _b;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.init()\n                        ];\n                    case 1:\n                        _c.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send({\n                                type: \"input_audio_buffer.commit\"\n                            })\n                        ];\n                    case 2:\n                        _c.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.messageQueue.receive(function(m) {\n                                return m.type === \"input_audio_buffer.committed\";\n                            })\n                        ];\n                    case 3:\n                        message = _c.sent();\n                        if (message === null) {\n                            throw new Error(\"Failed to commit audio\");\n                        } else if (message.type === \"error\") {\n                            throw new RTError(message.error);\n                        } else if (message.type === \"input_audio_buffer.committed\") {\n                            return [\n                                2 /*return*/ ,\n                                RTInputAudioItem.create(message.item_id, undefined, ((_a = this.session) === null || _a === void 0 ? void 0 : _a.input_audio_transcription) !== undefined && ((_b = this.session) === null || _b === void 0 ? void 0 : _b.input_audio_transcription) !== null, this.messageQueue)\n                            ];\n                        } else {\n                            throw new Error(\"Unexpected message type\");\n                        }\n                }\n            });\n        });\n    };\n    RTClient.prototype.clearAudio = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var message;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.init()\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send({\n                                type: \"input_audio_buffer.clear\"\n                            })\n                        ];\n                    case 2:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.messageQueue.receive(function(m) {\n                                return m.type === \"input_audio_buffer.cleared\";\n                            })\n                        ];\n                    case 3:\n                        message = _a.sent();\n                        if (message === null) {\n                            throw new Error(\"Failed to clear audio\");\n                        } else if (message.type === \"error\") {\n                            throw new RTError(message.error);\n                        } else if (message.type !== \"input_audio_buffer.cleared\") {\n                            throw new Error(\"Unexpected message type\");\n                        }\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    RTClient.prototype.connectAvatar = function(client_sdp) {\n        return __awaiter(this, void 0, void 0, function() {\n            var base64, message;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.init()\n                        ];\n                    case 1:\n                        _a.sent();\n                        base64 = btoa(JSON.stringify(client_sdp));\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send({\n                                type: \"session.avatar.connect\",\n                                client_sdp: base64\n                            })\n                        ];\n                    case 2:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.messageQueue.receive(function(m) {\n                                return m.type === \"session.avatar.connecting\";\n                            })\n                        ];\n                    case 3:\n                        message = _a.sent();\n                        if (message === null) {\n                            throw new Error(\"Failed to connect avatar\");\n                        } else if (message.type === \"error\") {\n                            throw new RTError(message.error);\n                        } else if (message.type === \"session.avatar.connecting\") {\n                            return [\n                                2 /*return*/ ,\n                                new RTCSessionDescription(JSON.parse(atob(message.server_sdp)))\n                            ];\n                        } else {\n                            throw new Error(\"Unexpected message type\");\n                        }\n                }\n            });\n        });\n    };\n    RTClient.prototype.sendItem = function(item, previousItemId) {\n        return __awaiter(this, void 0, void 0, function() {\n            var message;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.init()\n                        ];\n                    case 1:\n                        _a.sent();\n                        item.id = item.id || generateId(\"item\", 32);\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send({\n                                type: \"conversation.item.create\",\n                                previous_item_id: previousItemId,\n                                item: item\n                            })\n                        ];\n                    case 2:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.messageQueue.receive(function(m) {\n                                return m.type === \"conversation.item.created\" && m.item.id === item.id;\n                            })\n                        ];\n                    case 3:\n                        message = _a.sent();\n                        if (message === null) {\n                            throw new Error(\"Failed to create item\");\n                        } else if (message.type === \"error\") {\n                            throw new RTError(message.error);\n                        } else if (message.type === \"conversation.item.created\") {\n                            return [\n                                2 /*return*/ ,\n                                message.item\n                            ];\n                        } else {\n                            throw new Error(\"Unexpected message type\");\n                        }\n                }\n            });\n        });\n    };\n    RTClient.prototype.removeItem = function(itemId) {\n        return __awaiter(this, void 0, void 0, function() {\n            var message;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.init()\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send({\n                                type: \"conversation.item.delete\",\n                                item_id: itemId\n                            })\n                        ];\n                    case 2:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.messageQueue.receive(function(m) {\n                                return m.type === \"conversation.item.deleted\" && m.item_id === itemId;\n                            })\n                        ];\n                    case 3:\n                        message = _a.sent();\n                        if (message === null) {\n                            throw new Error(\"Failed to delete item\");\n                        } else if (message.type === \"error\") {\n                            throw new RTError(message.error);\n                        } else if (message.type === \"conversation.item.deleted\") {\n                            return [\n                                2 /*return*/ \n                            ];\n                        } else {\n                            throw new Error(\"Unexpected message type\");\n                        }\n                }\n            });\n        });\n    };\n    RTClient.prototype.generateResponse = function(response, waitForGenerated) {\n        return __awaiter(this, void 0, void 0, function() {\n            var message;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.init()\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send({\n                                type: \"response.create\",\n                                response: response\n                            })\n                        ];\n                    case 2:\n                        _a.sent();\n                        if (!(!this.iterating && waitForGenerated === true)) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            this.messageQueue.receive(function(m) {\n                                return m.type === \"response.created\";\n                            })\n                        ];\n                    case 3:\n                        message = _a.sent();\n                        if (message === null) {\n                            throw new Error(\"Failed to create response\");\n                        } else if (message.type === \"error\") {\n                            throw new RTError(message.error);\n                        } else if (message.type === \"response.created\") {\n                            return [\n                                2 /*return*/ ,\n                                RTResponse.create(message.response, this.messageQueue, this.client)\n                            ];\n                        }\n                        throw new Error(\"Unexpected message type\");\n                    case 4:\n                        return [\n                            2 /*return*/ ,\n                            undefined\n                        ];\n                }\n            });\n        });\n    };\n    RTClient.prototype.events = function() {\n        return __asyncGenerator(this, arguments, function events_1() {\n            var message, input_audio_item;\n            var _a, _b;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        _c.trys.push([\n                            0,\n                            ,\n                            14,\n                            15\n                        ]);\n                        this.iterating = true;\n                        _c.label = 1;\n                    case 1:\n                        return [\n                            4 /*yield*/ ,\n                            __await(this.messageQueue.receive(function(m) {\n                                return m.type === \"input_audio_buffer.speech_started\" || m.type === \"response.created\";\n                            }))\n                        ];\n                    case 2:\n                        message = _c.sent();\n                        if (!(message === null)) return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                        return [\n                            3 /*break*/ ,\n                            13\n                        ];\n                    case 3:\n                        if (!(message.type === \"error\")) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        throw new RTError(message.error);\n                    case 4:\n                        if (!(message.type === \"input_audio_buffer.speech_started\")) return [\n                            3 /*break*/ ,\n                            8\n                        ];\n                        input_audio_item = RTInputAudioItem.create(message.item_id, message.audio_start_ms, ((_a = this.session) === null || _a === void 0 ? void 0 : _a.input_audio_transcription) !== undefined && ((_b = this.session) === null || _b === void 0 ? void 0 : _b.input_audio_transcription) !== null, this.messageQueue);\n                        return [\n                            4 /*yield*/ ,\n                            __await(input_audio_item)\n                        ];\n                    case 5:\n                        return [\n                            4 /*yield*/ ,\n                            _c.sent()\n                        ];\n                    case 6:\n                        _c.sent();\n                        return [\n                            4 /*yield*/ ,\n                            __await(input_audio_item.waitForCompletion())\n                        ];\n                    case 7:\n                        _c.sent();\n                        return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                    case 8:\n                        if (!(message.type === \"response.created\")) return [\n                            3 /*break*/ ,\n                            11\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            __await(RTResponse.create(message.response, this.messageQueue, this.client))\n                        ];\n                    case 9:\n                        return [\n                            4 /*yield*/ ,\n                            _c.sent()\n                        ];\n                    case 10:\n                        _c.sent();\n                        return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                    case 11:\n                        throw new Error(\"Unexpected message type\");\n                    case 12:\n                        return [\n                            3 /*break*/ ,\n                            1\n                        ];\n                    case 13:\n                        return [\n                            3 /*break*/ ,\n                            15\n                        ];\n                    case 14:\n                        this.iterating = false;\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 15:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    RTClient.prototype.close = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.client.close()\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return RTClient;\n}();\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnQtY2xpZW50L2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQThKTyxJQUFNLGVBQWUsR0FBRztBQy9KL0I7Ozs7Ozs7Ozs7Ozs7OEVBYUEsR0FDQSxpRUFFQSxJQUFJLGFBQWEsR0FBRyxTQUFTLENBQUMsRUFBRSxDQUFDLEVBQUU7SUFDL0IsYUFBYSxHQUFHLE1BQU0sQ0FBQyxjQUFjLEtBQ2hDO1FBQUUsU0FBUyxFQUFFLEVBQUU7SUFBQSxjQUFjLEtBQUssSUFBSSxTQUFVLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFBRSxDQUFDLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztJQUFBLENBQUUsQ0FBQyxHQUM1RSxTQUFVLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFBRSxJQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBRSxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUFBLENBQUUsQ0FBQztJQUN0RyxPQUFPLGFBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDL0IsQ0FBQyxDQUFDO0FBRUssU0FBUyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUM1QixJQUFJLE9BQU8sQ0FBQyxLQUFLLFVBQVUsSUFBSSxDQUFDLEtBQUssSUFBSSxFQUNyQyxNQUFNLElBQUksU0FBUyxDQUFDLHNCQUFzQixHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRywrQkFBK0IsQ0FBQyxDQUFDO0lBQzlGLGFBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDcEIsU0FBUyxFQUFFLEdBQUc7UUFBRSxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FB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QUFDLENBQUM7WUFBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUFBLENBQUU7UUFBRSxJQUFJLEVBQUUsRUFBRTtRQUFFLEdBQUcsRUFBRSxFQUFFO0lBQUEsQ0FBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsUUFBUSxLQUFLLFVBQVUsR0FBRyxRQUFRLEdBQUcsT0FBTSxDQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ2pNLE9BQU8sQ0FBQyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sTUFBTSxLQUFLLFVBQVUsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLFdBQVc7UUFBRSxPQUFPLElBQUksQ0FBQztJQUFBLEVBQUUsQ0FBQyxDQUFFLENBQUMsQ0FBQztJQUM1SixTQUFTLElBQUksQ0FBQyxDQUFDLEVBQUU7UUFBRSxPQUFPLFNBQVUsQ0FBQyxFQUFFO1lBQUUsT0FBTyxJQUFJLENBQUM7Z0JBQUMsQ0FBQztnQkFBRSxDQUFDO2FBQUMsQ0FBQyxDQUFDO1FBQUEsQ0FBRSxDQUFDO0lBQUEsQ0FBRTtJQUNsRSxTQUFTLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDZCxJQUFJLENBQUMsRUFBRSxNQUFNLElBQUksU0FBUyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7UUFDOUQsTUFBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLENBQUUsQ0FBQyxDQUFFLElBQUk7WUFDMUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUSxLQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUUsQ0FBQyxDQUFDLEVBQUcsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztZQUM3SixJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsR0FBRztnQkFBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztnQkFBRSxDQUFDLENBQUMsS0FBSzthQUFDLENBQUM7WUFDeEMsT0FBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUNULEtBQUssQ0FBQyxDQUFDO2dCQUFDLEtBQUssQ0FBQztvQkFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO29CQUFDLE1BQU07Z0JBQzlCLEtBQUssQ0FBQztvQkFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7b0JBQUMsT0FBTzt3QkFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQzt3QkFBRSxJQUFJLEVBQUUsS0FBSztvQkFBQSxDQUFFLENBQUM7Z0JBQ3hELEtBQUssQ0FBQztvQkFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7b0JBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFBQyxFQUFFLEdBQUc7d0JBQUMsQ0FBQztxQkFBQyxDQUFDO29CQUFDLFNBQVM7Z0JBQ2pELEtBQUssQ0FBQztvQkFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztvQkFBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO29CQUFDLFNBQVM7Z0JBQ2pEO29CQUNJLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsRUFBQyxDQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQUssQ0FBQyxDQUFDLENBQUU7d0JBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQzt3QkFBQyxTQUFTO29CQUFBLENBQUU7b0JBQzVHLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFFO3dCQUFFLENBQUMsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUFDLE1BQU07b0JBQUEsQ0FBRTtvQkFDdEYsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO3dCQUFFLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7d0JBQUMsTUFBTTtvQkFBQSxDQUFFO29CQUNyRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTt3QkFBRSxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQzt3QkFBQyxNQUFNO29C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QUFDLGFBQWEsRUFBRSxNQUFNLElBQUksU0FBUyxDQUFDLHNDQUFzQyxDQUFDLENBQUM7SUFDdkYsSUFBSSxDQUFDLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsVUFBVSxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQzlELE9BQU8sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLGFBQWEsS0FBSyxVQUFVLEdBQUcsYUFBYSxHQUFHLE9BQU0sQ0FBRSxTQUFTLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBRyxZQUFZO1FBQUUsT0FBTyxJQUFJLENBQUM7SUFBQSxDQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ3hOLFNBQVMsV0FBVyxDQUFDLENBQUMsRUFBRTtRQUFFLE9BQU8sU0FBVSxDQUFDLEVBQUU7WUFBRSxPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUFBLENBQUUsQ0FBQztJQUFBLENBQUU7SUFDL0YsU0FBUyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRTtRQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVUsQ0FBQyxFQUFFO2dCQUFFLE9BQU8sSUFBSSxPQUFPLENBQUMsU0FBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFO29CQUFFLENBQUMsQ0FBQyxJQUFJLENBQUM7d0JBQUMsQ0FBQzt3QkFBRSxDQUFDO3dCQUFFLENBQUM7d0JBQUUsQ0FBQztxQkFBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQUEsQ0FBRSxDQUFDLENBQUM7WUFBQSxDQUFFLENBQUM7WUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQUEsQ0FBRTtJQUFBLENBQUU7SUFDeEssU0FBUyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRTtRQUFFLElBQUk7WUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFBQSxDQUFFLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQUEsQ0FBRTtJQUFBLENBQUU7SUFDbEYsU0FBUyxJQUFJLENBQUMsQ0FBQyxFQUFFO1FBQUUsQ0FBQyxDQUFDLEtBQUssWUFBWSxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUFBLENBQUU7SUFDeEgsU0FBUyxPQUFPLENBQUMsS0FBSyxFQUFFO1FBQUUsTUFBTSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUFBLENBQUU7SUFDbEQsU0FBUyxNQUFNLENBQUMsS0FBSyxFQUFFO1FBQUUsTUFBTSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUFBLENBQUU7SUFDbEQsU0FBUyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRTtRQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENB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QUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQzlDLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFDOUMsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUM5QyxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQzlDLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7UUFBRSxDQUFDO1FBQUUsQ0FBQztRQUFFLENBQUM7S0FDL0M7SUFFRDs7Ozs7O0VBTUEsR0FDQSxTQUFTLGlCQUFpQixDQUFDLElBQUksRUFBRTtRQUMvQixPQUNHLElBQUksSUFBSSxJQUFJLElBQ1gsSUFBSSxJQUFJLElBQUksSUFDWixJQUFJLEtBQUssSUFBSSxJQUNiLElBQUksS0FBSyxJQUFJLElBQ2IsSUFBSSxLQUFLLElBQUksSUFDZCxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJO0lBRWpDO0lBRUE7Ozs7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SUFBSSxDQUFDLFlBQVksQ0FDbEIsQ0FBQzs7O29DQUNJLGdCQUFnQjt5QkFBQTs7d0JBQXRCLE9BQXNCOzRCQUFBOzRCQUFBO3lCQUFBOzt3QkFBdEIsU0FBc0IsQ0FBQzt3QkFDdkI7NEJBQUE7NEJBQUEsUUFBTSxnQkFBZ0IsQ0FBQyxpQkFBaUIsRUFBRTt5QkFBQTs7d0JBQTFDLFNBQTBDLENBQUM7Ozs7Ozt3QkFDbEMsYUFBTyxDQUFDLElBQUksS0FBSyxtQkFBa0IsRUFBbkMsT0FBbUM7NEJBQUE7NEJBQUE7eUJBQUE7d0JBQ3RDOzRCQUFBOzRCQUFBLGtCQUFVLENBQUMsTUFBTSxDQUNyQixPQUFPLENBQUMsUUFBUSxFQUNoQixJQUFJLENBQUMsWUFBWSxFQUNqQixJQUFJLENBQUMsTUFBTSxDQUNaO3lCQUFBOzt3QkFKRCxPQUlDOzRCQUFBOzRCQUFBO3lCQUFBOzt3QkFKRCxTQUlDLENBQUM7Ozs7O29CQUVGO3dCQUFBLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7O3dCQUkvQyxJQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQzs7Ozs7Ozs7Ozs7SUFFMUI7SUFFSyx3QkFBSyxHQUFYOzs7O29CQUNFO3dCQUFBOzRCQUFBOzRCQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFO3lCQUFBOzt3QkFBekIsU0FBeUIsQ0FBQzs7Ozs7OztJQUMzQjtJQUNILE9BQUM7QUFBRCxDQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxpZmVjXFxPbmVEcml2ZSAtIEhlbGxvIFNjcmlwdCBBSVxcbGlmZUFnZW50XFx2b2ljZS1saXZlLWFnZW50XFxzcmNcXG1vZGVscy50cyIsIkM6XFxVc2Vyc1xcbGlmZWNcXE9uZURyaXZlIC0gSGVsbG8gU2NyaXB0IEFJXFxsaWZlQWdlbnRcXHZvaWNlLWxpdmUtYWdlbnRcXG5vZGVfbW9kdWxlc1xcdHNsaWJcXHRzbGliLmVzNi5qcyIsIkM6XFxVc2Vyc1xcbGlmZWNcXE9uZURyaXZlIC0gSGVsbG8gU2NyaXB0IEFJXFxsaWZlQWdlbnRcXHZvaWNlLWxpdmUtYWdlbnRcXHNyY1xcbW9kZWwtdXRpbHMudHMiLCJDOlxcVXNlcnNcXGxpZmVjXFxPbmVEcml2ZSAtIEhlbGxvIFNjcmlwdCBBSVxcbGlmZUFnZW50XFx2b2ljZS1saXZlLWFnZW50XFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXGNvbnN0YW50cy5qcyIsIkM6XFxVc2Vyc1xcbGlmZWNcXE9uZURyaXZlIC0gSGVsbG8gU2NyaXB0IEFJXFxsaWZlQWdlbnRcXHZvaWNlLWxpdmUtYWdlbnRcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxcYnVmZmVyLXV0aWwuanMiLCJDOlxcVXNlcnNcXGxpZmVjXFxPbmVEcml2ZSAtIEhlbGxvIFNjcmlwdCBBSVxcbGlmZUFnZW50XFx2b2ljZS1saXZlLWFnZW50XFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXGxpbWl0ZXIuanMiLCJDOlxcVXNlcnNcXGxpZmVjXFxPbmVEcml2ZSAtIEhlbGxvIFNjcmlwdCBBSVxcbGlmZUFnZW50XFx2b2ljZS1saXZlLWFnZW50XFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXHBlcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIkM6XFxVc2Vyc1xcbGlmZWNcXE9uZURyaXZlIC0gSGVsbG8gU2NyaXB0IEFJXFxsaWZlQWdlbnRcXHZvaWNlLWxpdmUtYWdlbnRcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxcdmFsaWRhdGlvbi5qcyIsIkM6XFxVc2Vyc1xcbGlmZWNcXE9uZURyaXZlIC0gSGVsbG8gU2NyaXB0IEFJXFxsaWZlQWdlbnRcXHZvaWNlLWxpdmUtYWdlbnRcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxccmVjZWl2ZXIuanMiLCJDOlxcVXNlcnNcXGxpZmVjXFxPbmVEcml2ZSAtIEhlbGxvIFNjcmlwdCBBSVxcbGlmZUFnZW50XFx2b2ljZS1saXZlLWFnZW50XFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXHNlbmRlci5qcyIsIkM6XFxVc2Vyc1xcbGlmZWNcXE9uZURyaXZlIC0gSGVsbG8gU2NyaXB0IEFJXFxsaWZlQWdlbnRcXHZvaWNlLWxpdmUtYWdlbnRcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxcZXZlbnQtdGFyZ2V0LmpzIiwiQzpcXFVzZXJzXFxsaWZlY1xcT25lRHJpdmUgLSBIZWxsbyBTY3JpcHQgQUlcXGxpZmVBZ2VudFxcdm9pY2UtbGl2ZS1hZ2VudFxcbm9kZV9tb2R1bGVzXFx3c1xcbGliXFxleHRlbnNpb24uanMiLCJDOlxcVXNlcnNcXGxpZmVjXFxPbmVEcml2ZSAtIEhlbGxvIFNjcmlwdCBBSVxcbGlmZUFnZW50XFx2b2ljZS1saXZlLWFnZW50XFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXHdlYnNvY2tldC5qcyIsIkM6XFxVc2Vyc1xcbGlmZWNcXE9uZURyaXZlIC0gSGVsbG8gU2NyaXB0IEFJXFxsaWZlQWdlbnRcXHZvaWNlLWxpdmUtYWdlbnRcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxcc3VicHJvdG9jb2wuanMiLCJDOlxcVXNlcnNcXGxpZmVjXFxPbmVEcml2ZSAtIEhlbGxvIFNjcmlwdCBBSVxcbGlmZUFnZW50XFx2b2ljZS1saXZlLWFnZW50XFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXHdlYnNvY2tldC1zZXJ2ZXIuanMiLCJDOlxcVXNlcnNcXGxpZmVjXFxPbmVEcml2ZSAtIEhlbGxvIFNjcmlwdCBBSVxcbGlmZUFnZW50XFx2b2ljZS1saXZlLWFnZW50XFxzcmNcXHV0aWxcXHdlYnNvY2tldC50cyIsIkM6XFxVc2Vyc1xcbGlmZWNcXE9uZURyaXZlIC0gSGVsbG8gU2NyaXB0IEFJXFxsaWZlQWdlbnRcXHZvaWNlLWxpdmUtYWdlbnRcXHNyY1xcdXRpbFxcd2Vic29ja2V0LWNsaWVudC50cyIsIkM6XFxVc2Vyc1xcbGlmZWNcXE9uZURyaXZlIC0gSGVsbG8gU2NyaXB0IEFJXFxsaWZlQWdlbnRcXHZvaWNlLWxpdmUtYWdlbnRcXHNyY1xcdXRpbFxcYXV0aC50cyIsIkM6XFxVc2Vyc1xcbGlmZWNcXE9uZURyaXZlIC0gSGVsbG8gU2NyaXB0IEFJXFxsaWZlQWdlbnRcXHZvaWNlLWxpdmUtYWdlbnRcXHNyY1xcdXRpbFxcaW50ZXJmYWNlcy50cyIsIkM6XFxVc2Vyc1xcbGlmZWNcXE9uZURyaXZlIC0gSGVsbG8gU2NyaXB0IEFJXFxsaWZlQWdlbnRcXHZvaWNlLWxpdmUtYWdlbnRcXHNyY1xcdXRpbFxcY29ubmVjdGlvbi1zZXR0aW5ncy50cyIsIkM6XFxVc2Vyc1xcbGlmZWNcXE9uZURyaXZlIC0gSGVsbG8gU2NyaXB0IEFJXFxsaWZlQWdlbnRcXHZvaWNlLWxpdmUtYWdlbnRcXHNyY1xcdXRpbFxcbWVzc2FnZV9xdWV1ZS50cyIsIkM6XFxVc2Vyc1xcbGlmZWNcXE9uZURyaXZlIC0gSGVsbG8gU2NyaXB0IEFJXFxsaWZlQWdlbnRcXHZvaWNlLWxpdmUtYWdlbnRcXHNyY1xcdXRpbFxcY3J5cHRvLnRzIiwiQzpcXFVzZXJzXFxsaWZlY1xcT25lRHJpdmUgLSBIZWxsbyBTY3JpcHQgQUlcXGxpZmVBZ2VudFxcdm9pY2UtbGl2ZS1hZ2VudFxcc3JjXFxjbGllbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmV4cG9ydCB0eXBlIEF6dXJlU3RhbmRhcmRWb2ljZSA9IHtcbiAgdHlwZTogXCJhenVyZS1zdGFuZGFyZFwiO1xuICBuYW1lOiBzdHJpbmc7XG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xuICBjdXN0b21fbGV4aWNvbl91cmw/OiBzdHJpbmc7XG4gIHByZWZlcl9sb2NhbGVzPzogc3RyaW5nW107XG59XG5leHBvcnQgdHlwZSBBenVyZUN1c3RvbVZvaWNlID0ge1xuICB0eXBlOiBcImF6dXJlLWN1c3RvbVwiO1xuICBuYW1lOiBzdHJpbmc7XG4gIGVuZHBvaW50X2lkOiBzdHJpbmc7XG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xuICBjdXN0b21fbGV4aWNvbl91cmw/OiBzdHJpbmc7XG4gIHByZWZlcl9sb2NhbGVzPzogc3RyaW5nW107XG59XG5leHBvcnQgdHlwZSBWb2ljZSA9XG4gIHwgJ2FsbG95J1xuICB8ICdhc2gnXG4gIHwgJ2JhbGxhZCdcbiAgfCAnY29yYWwnXG4gIHwgJ2VjaG8nXG4gIHwgJ2ZhYmxlJ1xuICB8ICdvbnl4J1xuICB8ICdub3ZhJ1xuICB8ICdzYWdlJ1xuICB8ICdzaGltbWVyJ1xuICB8ICd2ZXJzZSdcbiAgfCBBenVyZVN0YW5kYXJkVm9pY2VcbiAgfCBBenVyZUN1c3RvbVZvaWNlO1xuZXhwb3J0IHR5cGUgQXVkaW9Gb3JtYXQgPSBcInBjbTE2XCIgfCBcImc3MTEtdWxhd1wiIHwgXCJnNzExLWFsYXdcIjtcbmV4cG9ydCB0eXBlIE1vZGFsaXR5ID0gXCJ0ZXh0XCIgfCBcImF1ZGlvXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9UdXJuRGV0ZWN0aW9uIHtcbiAgdHlwZTogXCJub25lXCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmVyVkFEIHtcbiAgdHlwZTogXCJzZXJ2ZXJfdmFkXCI7XG4gIHRocmVzaG9sZD86IG51bWJlcjtcbiAgcHJlZml4X3BhZGRpbmdfbXM/OiBudW1iZXI7XG4gIHNpbGVuY2VfZHVyYXRpb25fbXM/OiBudW1iZXI7XG4gIGVuZF9vZl91dHRlcmFuY2VfZGV0ZWN0aW9uPzogRU9VRGV0ZWN0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF6dXJlU2VtYW50aWNWQUQge1xuICB0eXBlOiBcImF6dXJlX3NlbWFudGljX3ZhZFwiO1xuICB0aHJlc2hvbGQ/OiBudW1iZXI7XG4gIHByZWZpeF9wYWRkaW5nX21zPzogbnVtYmVyO1xuICBzaWxlbmNlX2R1cmF0aW9uX21zPzogbnVtYmVyO1xuICByZW1vdmVfZmlsbGVyX3dvcmRzPzogYm9vbGVhbjtcbiAgZW5kX29mX3V0dGVyYW5jZV9kZXRlY3Rpb24/OiBFT1VEZXRlY3Rpb247XG59XG5cbmV4cG9ydCB0eXBlIFR1cm5EZXRlY3Rpb24gPSBTZXJ2ZXJWQUQgfCBBenVyZVNlbWFudGljVkFEIHwgbnVsbDtcblxuZXhwb3J0IGludGVyZmFjZSBBenVyZUVPVSB7XG4gIG1vZGVsOiBcInNlbWFudGljX2RldGVjdGlvbl92MVwiO1xuICB0aHJlc2hvbGQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIEVPVURldGVjdGlvbiA9IEF6dXJlRU9VIHwgbnVsbDtcblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvblRvb2xDaG9pY2Uge1xuICB0eXBlOiBcImZ1bmN0aW9uXCI7XG4gIGZ1bmN0aW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIFRvb2xDaG9pY2UgPSBcImF1dG9cIiB8IFwibm9uZVwiIHwgXCJyZXF1aXJlZFwiIHwgRnVuY3Rpb25Ub29sQ2hvaWNlO1xuXG5leHBvcnQgdHlwZSBNZXNzYWdlUm9sZSA9IFwic3lzdGVtXCIgfCBcImFzc2lzdGFudFwiIHwgXCJ1c2VyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24ge1xuICBtb2RlbDogXCJ3aGlzcGVyLTFcIiB8IFwiZ3B0LTRvLXRyYW5zY3JpYmVcIiB8IFwiZ3B0LTRvLW1pbmktdHJhbnNjcmliZVwiIHwgXCJhenVyZS1mYXN0LXRyYW5zY3JpcHRpb25cIjtcbiAgbGFuZ3VhZ2U/OiBzdHJpbmc7XG4gIHByb21wdD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdmF0YXJDb25maWdWaWRlb1BhcmFtcyB7XG4gIGJpdHJhdGU/OiBudW1iZXI7XG4gIGNvZGVjOiBcImgyNjRcIjtcbiAgY3JvcD86IHtcbiAgICBib3R0b21fcmlnaHQ6IFtudW1iZXIsIG51bWJlcl07XG4gICAgdG9wX2xlZnQ6IFtudW1iZXIsIG51bWJlcl07XG4gIH07XG4gIHJlc29sdXRpb24/OiB7XG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICBoZWlnaHQ6IG51bWJlcjtcbiAgfTtcbiAgYmFja2dyb3VuZD86IHtcbiAgICBjb2xvcj86IHN0cmluZztcbiAgICBpbWFnZV91cmw/OiBVUkw7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXZhdGFyQ29uZmlnIHtcbiAgaWNlX3NlcnZlcnM/OiBSVENJY2VTZXJ2ZXJbXTtcbiAgY2hhcmFjdGVyOiBzdHJpbmc7XG4gIHN0eWxlPzogc3RyaW5nO1xuICBjdXN0b21pemVkPzogYm9vbGVhbjtcbiAgdmlkZW8/OiBBdmF0YXJDb25maWdWaWRlb1BhcmFtcztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDbGllbnRNZXNzYWdlQmFzZSB7XG4gIGV2ZW50X2lkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBUb29sc0RlZmluaXRpb24gPSBSZWNvcmQ8c3RyaW5nLCBhbnk+W107XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmVyRWNob0NhbmNlbGxhdGlvbiB7XG4gIHR5cGU6IFwic2VydmVyX2VjaG9fY2FuY2VsbGF0aW9uXCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXp1cmVEZWVwTm9pc2VTdXBwcmVzc2lvbiB7XG4gIHR5cGU6IFwiYXp1cmVfZGVlcF9ub2lzZV9zdXBwcmVzc2lvblwiO1xufVxuXG5leHBvcnQgdHlwZSBJbnB1dEF1ZGlvRWNob0NhbmNlbGxhdGlvbiA9IFNlcnZlckVjaG9DYW5jZWxsYXRpb24gfCBudWxsO1xuXG5leHBvcnQgdHlwZSBJbnB1dEF1ZGlvTm9pc2VSZWR1Y3Rpb24gPSBBenVyZURlZXBOb2lzZVN1cHByZXNzaW9uIHwgbnVsbDtcblxuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uVXBkYXRlUGFyYW1zIHtcbiAgbW9kZWw/OiBzdHJpbmc7XG4gIG1vZGFsaXRpZXM/OiBNb2RhbGl0eVtdO1xuICB2b2ljZT86IFZvaWNlO1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmc7XG4gIGlucHV0X2F1ZGlvX2Zvcm1hdD86IEF1ZGlvRm9ybWF0O1xuICBvdXRwdXRfYXVkaW9fZm9ybWF0PzogQXVkaW9Gb3JtYXQ7XG4gIGlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24/OiBJbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiB8IG51bGw7XG4gIHR1cm5fZGV0ZWN0aW9uPzogVHVybkRldGVjdGlvbjtcbiAgdG9vbHM/OiBUb29sc0RlZmluaXRpb247XG4gIHRvb2xfY2hvaWNlPzogVG9vbENob2ljZTtcbiAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG4gIG1heF9yZXNwb25zZV9vdXRwdXRfdG9rZW5zPzogbnVtYmVyO1xuICBhdmF0YXI/OiBBdmF0YXJDb25maWc7XG4gIGlucHV0X2F1ZGlvX25vaXNlX3JlZHVjdGlvbj86IElucHV0QXVkaW9Ob2lzZVJlZHVjdGlvbjtcbiAgaW5wdXRfYXVkaW9fZWNob19jYW5jZWxsYXRpb24/OiBJbnB1dEF1ZGlvRWNob0NhbmNlbGxhdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uVXBkYXRlTWVzc2FnZSBleHRlbmRzIENsaWVudE1lc3NhZ2VCYXNlIHtcbiAgdHlwZTogXCJzZXNzaW9uLnVwZGF0ZVwiO1xuICBzZXNzaW9uOiBTZXNzaW9uVXBkYXRlUGFyYW1zO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9CdWZmZXJBcHBlbmRNZXNzYWdlIGV4dGVuZHMgQ2xpZW50TWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcImlucHV0X2F1ZGlvX2J1ZmZlci5hcHBlbmRcIjtcbiAgYXVkaW86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvQnVmZmVyQ29tbWl0TWVzc2FnZSBleHRlbmRzIENsaWVudE1lc3NhZ2VCYXNlIHtcbiAgdHlwZTogXCJpbnB1dF9hdWRpb19idWZmZXIuY29tbWl0XCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb0J1ZmZlckNsZWFyTWVzc2FnZSBleHRlbmRzIENsaWVudE1lc3NhZ2VCYXNlIHtcbiAgdHlwZTogXCJpbnB1dF9hdWRpb19idWZmZXIuY2xlYXJcIjtcbn1cblxuZXhwb3J0IGNvbnN0IE1lc3NhZ2VJdGVtVHlwZSA9IFwibWVzc2FnZVwiIGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgTWVzc2FnZUl0ZW1UeXBlID0gdHlwZW9mIE1lc3NhZ2VJdGVtVHlwZTtcblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dFRleHRDb250ZW50UGFydCB7XG4gIHR5cGU6IFwiaW5wdXRfdGV4dFwiO1xuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb0NvbnRlbnRQYXJ0IHtcbiAgdHlwZTogXCJpbnB1dF9hdWRpb1wiO1xuICBhdWRpbzogc3RyaW5nO1xuICB0cmFuc2NyaXB0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE91dHB1dFRleHRDb250ZW50UGFydCB7XG4gIHR5cGU6IFwidGV4dFwiO1xuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIFN5c3RlbUNvbnRlbnRQYXJ0ID0gSW5wdXRUZXh0Q29udGVudFBhcnQ7XG5leHBvcnQgdHlwZSBVc2VyQ29udGVudFBhcnQgPSBJbnB1dFRleHRDb250ZW50UGFydCB8IElucHV0QXVkaW9Db250ZW50UGFydDtcbmV4cG9ydCB0eXBlIEFzc2lzdGFudENvbnRlbnRQYXJ0ID0gT3V0cHV0VGV4dENvbnRlbnRQYXJ0O1xuXG5leHBvcnQgdHlwZSBJdGVtUGFyYW1TdGF0dXMgPSBcImNvbXBsZXRlZFwiIHwgXCJpbmNvbXBsZXRlXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3lzdGVtTWVzc2FnZUl0ZW0ge1xuICB0eXBlOiBNZXNzYWdlSXRlbVR5cGU7XG4gIHJvbGU6IFwic3lzdGVtXCI7XG4gIGlkPzogc3RyaW5nO1xuICBjb250ZW50OiBTeXN0ZW1Db250ZW50UGFydFtdO1xuICBzdGF0dXM/OiBJdGVtUGFyYW1TdGF0dXM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlck1lc3NhZ2VJdGVtIHtcbiAgdHlwZTogTWVzc2FnZUl0ZW1UeXBlO1xuICByb2xlOiBcInVzZXJcIjtcbiAgaWQ/OiBzdHJpbmc7XG4gIGNvbnRlbnQ6IFVzZXJDb250ZW50UGFydFtdO1xuICBzdGF0dXM/OiBJdGVtUGFyYW1TdGF0dXM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXNzaXN0YW50TWVzc2FnZUl0ZW0ge1xuICB0eXBlOiBNZXNzYWdlSXRlbVR5cGU7XG4gIHJvbGU6IFwiYXNzaXN0YW50XCI7XG4gIGlkPzogc3RyaW5nO1xuICBjb250ZW50OiBBc3Npc3RhbnRDb250ZW50UGFydFtdO1xuICBzdGF0dXM/OiBJdGVtUGFyYW1TdGF0dXM7XG59XG5cbmV4cG9ydCB0eXBlIE1lc3NhZ2VJdGVtID1cbiAgfCBTeXN0ZW1NZXNzYWdlSXRlbVxuICB8IFVzZXJNZXNzYWdlSXRlbVxuICB8IEFzc2lzdGFudE1lc3NhZ2VJdGVtO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQ2FsbEl0ZW0ge1xuICB0eXBlOiBcImZ1bmN0aW9uX2NhbGxcIjtcbiAgaWQ/OiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgY2FsbF9pZDogc3RyaW5nO1xuICBhcmd1bWVudHM6IHN0cmluZztcbiAgc3RhdHVzPzogSXRlbVBhcmFtU3RhdHVzO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQ2FsbE91dHB1dEl0ZW0ge1xuICB0eXBlOiBcImZ1bmN0aW9uX2NhbGxfb3V0cHV0XCI7XG4gIGlkPzogc3RyaW5nO1xuICBjYWxsX2lkOiBzdHJpbmc7XG4gIG91dHB1dDogc3RyaW5nO1xuICBzdGF0dXM/OiBJdGVtUGFyYW1TdGF0dXM7XG59XG5cbmV4cG9ydCB0eXBlIEl0ZW0gPSBNZXNzYWdlSXRlbSB8IEZ1bmN0aW9uQ2FsbEl0ZW0gfCBGdW5jdGlvbkNhbGxPdXRwdXRJdGVtO1xuXG5leHBvcnQgaW50ZXJmYWNlIEl0ZW1DcmVhdGVNZXNzYWdlIGV4dGVuZHMgQ2xpZW50TWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcImNvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZVwiO1xuICBwcmV2aW91c19pdGVtX2lkPzogc3RyaW5nO1xuICBpdGVtOiBJdGVtO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEl0ZW1UcnVuY2F0ZU1lc3NhZ2UgZXh0ZW5kcyBDbGllbnRNZXNzYWdlQmFzZSB7XG4gIHR5cGU6IFwiY29udmVyc2F0aW9uLml0ZW0udHJ1bmNhdGVcIjtcbiAgaXRlbV9pZDogc3RyaW5nO1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG4gIGF1ZGlvX2VuZF9tczogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEl0ZW1EZWxldGVNZXNzYWdlIGV4dGVuZHMgQ2xpZW50TWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcImNvbnZlcnNhdGlvbi5pdGVtLmRlbGV0ZVwiO1xuICBpdGVtX2lkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VDcmVhdGVQYXJhbXMge1xuICBjb252ZXJzYXRpb24/OiAnYXV0bycgfCAnbm9uZSc7XG4gIGFwcGVuZF9pbnB1dF9pdGVtcz86IEl0ZW1bXTtcbiAgaW5wdXRfaXRlbXM/OiBJdGVtW107XG4gIGluc3RydWN0aW9ucz86IHN0cmluZztcbiAgYWRkaXRpb25hbF9pbnN0cnVjdGlvbnM/OiBzdHJpbmc7XG4gIG1vZGFsaXRpZXM/OiBNb2RhbGl0eVtdO1xuICB2b2ljZT86IFZvaWNlO1xuICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcbiAgbWF4X291dHB1dF90b2tlbnM/OiBudW1iZXIgfCAnaW5mJztcbiAgdG9vbHM/OiBUb29sc0RlZmluaXRpb247XG4gIHRvb2xfY2hvaWNlPzogVG9vbENob2ljZTtcbiAgb3V0cHV0X2F1ZGlvX2Zvcm1hdD86IEF1ZGlvRm9ybWF0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQ3JlYXRlTWVzc2FnZSBleHRlbmRzIENsaWVudE1lc3NhZ2VCYXNlIHtcbiAgdHlwZTogXCJyZXNwb25zZS5jcmVhdGVcIjtcbiAgcmVzcG9uc2U/OiBSZXNwb25zZUNyZWF0ZVBhcmFtcztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUNhbmNlbE1lc3NhZ2UgZXh0ZW5kcyBDbGllbnRNZXNzYWdlQmFzZSB7XG4gIHR5cGU6IFwicmVzcG9uc2UuY2FuY2VsXCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbkF2YXRhckNvbm5lY3RNZXNzYWdlIGV4dGVuZHMgQ2xpZW50TWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcInNlc3Npb24uYXZhdGFyLmNvbm5lY3RcIjtcbiAgY2xpZW50X3NkcDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlYWx0aW1lRXJyb3Ige1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIHR5cGU/OiBzdHJpbmc7XG4gIGNvZGU/OiBzdHJpbmc7XG4gIHBhcmFtPzogc3RyaW5nO1xuICBldmVudF9pZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXJ2ZXJNZXNzYWdlQmFzZSB7XG4gIGV2ZW50X2lkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JNZXNzYWdlIGV4dGVuZHMgU2VydmVyTWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcImVycm9yXCI7XG4gIGVycm9yOiBSZWFsdGltZUVycm9yO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlc3Npb24ge1xuICBpZDogc3RyaW5nO1xuICBtb2RlbDogc3RyaW5nO1xuICBtb2RhbGl0aWVzOiBNb2RhbGl0eVtdO1xuICBpbnN0cnVjdGlvbnM6IHN0cmluZztcbiAgdm9pY2U6IFZvaWNlO1xuICBpbnB1dF9hdWRpb19mb3JtYXQ6IEF1ZGlvRm9ybWF0O1xuICBvdXRwdXRfYXVkaW9fZm9ybWF0OiBBdWRpb0Zvcm1hdDtcbiAgaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbj86IElucHV0QXVkaW9UcmFuc2NyaXB0aW9uO1xuICB0dXJuX2RldGVjdGlvbjogVHVybkRldGVjdGlvbjtcbiAgdG9vbHM6IFRvb2xzRGVmaW5pdGlvbjtcbiAgdG9vbF9jaG9pY2U6IFRvb2xDaG9pY2U7XG4gIHRlbXBlcmF0dXJlOiBudW1iZXI7XG4gIG1heF9yZXNwb25zZV9vdXRwdXRfdG9rZW5zPzogbnVtYmVyO1xuICBhdmF0YXI/OiBBdmF0YXJDb25maWc7XG4gIGlucHV0X2F1ZGlvX25vaXNlX3JlZHVjdGlvbj86IElucHV0QXVkaW9Ob2lzZVJlZHVjdGlvbjtcbiAgaW5wdXRfYXVkaW9fZWNob19jYW5jZWxsYXRpb24/OiBJbnB1dEF1ZGlvRWNob0NhbmNlbGxhdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uQ3JlYXRlZE1lc3NhZ2UgZXh0ZW5kcyBTZXJ2ZXJNZXNzYWdlQmFzZSB7XG4gIHR5cGU6IFwic2Vzc2lvbi5jcmVhdGVkXCI7XG4gIHNlc3Npb246IFNlc3Npb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvblVwZGF0ZWRNZXNzYWdlIGV4dGVuZHMgU2VydmVyTWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcInNlc3Npb24udXBkYXRlZFwiO1xuICBzZXNzaW9uOiBTZXNzaW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9CdWZmZXJDb21taXR0ZWRNZXNzYWdlIGV4dGVuZHMgU2VydmVyTWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcImlucHV0X2F1ZGlvX2J1ZmZlci5jb21taXR0ZWRcIjtcbiAgcHJldmlvdXNfaXRlbV9pZD86IHN0cmluZztcbiAgaXRlbV9pZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9CdWZmZXJDbGVhcmVkTWVzc2FnZSBleHRlbmRzIFNlcnZlck1lc3NhZ2VCYXNlIHtcbiAgdHlwZTogXCJpbnB1dF9hdWRpb19idWZmZXIuY2xlYXJlZFwiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9CdWZmZXJTcGVlY2hTdGFydGVkTWVzc2FnZVxuICBleHRlbmRzIFNlcnZlck1lc3NhZ2VCYXNlIHtcbiAgdHlwZTogXCJpbnB1dF9hdWRpb19idWZmZXIuc3BlZWNoX3N0YXJ0ZWRcIjtcbiAgYXVkaW9fc3RhcnRfbXM6IG51bWJlcjtcbiAgaXRlbV9pZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9CdWZmZXJTcGVlY2hTdG9wcGVkTWVzc2FnZVxuICBleHRlbmRzIFNlcnZlck1lc3NhZ2VCYXNlIHtcbiAgdHlwZTogXCJpbnB1dF9hdWRpb19idWZmZXIuc3BlZWNoX3N0b3BwZWRcIjtcbiAgYXVkaW9fZW5kX21zOiBudW1iZXI7XG4gIGl0ZW1faWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgUmVzcG9uc2VJdGVtU3RhdHVzID0gXCJpbl9wcm9ncmVzc1wiIHwgXCJjb21wbGV0ZWRcIiB8IFwiaW5jb21wbGV0ZVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlSXRlbUlucHV0VGV4dENvbnRlbnRQYXJ0IHtcbiAgdHlwZTogXCJpbnB1dF90ZXh0XCI7XG4gIHRleHQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUl0ZW1JbnB1dEF1ZGlvQ29udGVudFBhcnQge1xuICB0eXBlOiBcImlucHV0X2F1ZGlvXCI7XG4gIHRyYW5zY3JpcHQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VJdGVtVGV4dENvbnRlbnRQYXJ0IHtcbiAgdHlwZTogXCJ0ZXh0XCI7XG4gIHRleHQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUl0ZW1BdWRpb0NvbnRlbnRQYXJ0IHtcbiAgdHlwZTogXCJhdWRpb1wiO1xuICB0cmFuc2NyaXB0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBSZXNwb25zZUl0ZW1Db250ZW50UGFydCA9XG4gIHwgUmVzcG9uc2VJdGVtSW5wdXRUZXh0Q29udGVudFBhcnRcbiAgfCBSZXNwb25zZUl0ZW1JbnB1dEF1ZGlvQ29udGVudFBhcnRcbiAgfCBSZXNwb25zZUl0ZW1UZXh0Q29udGVudFBhcnRcbiAgfCBSZXNwb25zZUl0ZW1BdWRpb0NvbnRlbnRQYXJ0O1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlSXRlbUJhc2Uge1xuICBpZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZU1lc3NhZ2VJdGVtIGV4dGVuZHMgUmVzcG9uc2VJdGVtQmFzZSB7XG4gIHR5cGU6IE1lc3NhZ2VJdGVtVHlwZTtcbiAgc3RhdHVzOiBSZXNwb25zZUl0ZW1TdGF0dXM7XG4gIHJvbGU6IE1lc3NhZ2VSb2xlO1xuICBjb250ZW50OiBSZXNwb25zZUl0ZW1Db250ZW50UGFydFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlRnVuY3Rpb25DYWxsSXRlbSBleHRlbmRzIFJlc3BvbnNlSXRlbUJhc2Uge1xuICB0eXBlOiBcImZ1bmN0aW9uX2NhbGxcIjtcbiAgc3RhdHVzOiBSZXNwb25zZUl0ZW1TdGF0dXM7XG4gIG5hbWU6IHN0cmluZztcbiAgY2FsbF9pZDogc3RyaW5nO1xuICBhcmd1bWVudHM6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUZ1bmN0aW9uQ2FsbE91dHB1dEl0ZW0gZXh0ZW5kcyBSZXNwb25zZUl0ZW1CYXNlIHtcbiAgdHlwZTogXCJmdW5jdGlvbl9jYWxsX291dHB1dFwiO1xuICBjYWxsX2lkOiBzdHJpbmc7XG4gIG91dHB1dDogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBSZXNwb25zZUl0ZW0gPVxuICB8IFJlc3BvbnNlTWVzc2FnZUl0ZW1cbiAgfCBSZXNwb25zZUZ1bmN0aW9uQ2FsbEl0ZW1cbiAgfCBSZXNwb25zZUZ1bmN0aW9uQ2FsbE91dHB1dEl0ZW07XG5cbmV4cG9ydCBpbnRlcmZhY2UgSXRlbUNyZWF0ZWRNZXNzYWdlIGV4dGVuZHMgU2VydmVyTWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcImNvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZWRcIjtcbiAgcHJldmlvdXNfaXRlbV9pZD86IHN0cmluZztcbiAgaXRlbTogUmVzcG9uc2VJdGVtO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEl0ZW1UcnVuY2F0ZWRNZXNzYWdlIGV4dGVuZHMgU2VydmVyTWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcImNvbnZlcnNhdGlvbi5pdGVtLnRydW5jYXRlZFwiO1xuICBpdGVtX2lkOiBzdHJpbmc7XG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcbiAgYXVkaW9fZW5kX21zOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSXRlbURlbGV0ZWRNZXNzYWdlIGV4dGVuZHMgU2VydmVyTWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcImNvbnZlcnNhdGlvbi5pdGVtLmRlbGV0ZWRcIjtcbiAgaXRlbV9pZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEl0ZW1JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbkNvbXBsZXRlZE1lc3NhZ2VcbiAgZXh0ZW5kcyBTZXJ2ZXJNZXNzYWdlQmFzZSB7XG4gIHR5cGU6IFwiY29udmVyc2F0aW9uLml0ZW0uaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbi5jb21wbGV0ZWRcIjtcbiAgaXRlbV9pZDogc3RyaW5nO1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG4gIHRyYW5zY3JpcHQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJdGVtSW5wdXRBdWRpb1RyYW5zY3JpcHRpb25GYWlsZWRNZXNzYWdlXG4gIGV4dGVuZHMgU2VydmVyTWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcImNvbnZlcnNhdGlvbi5pdGVtLmlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24uZmFpbGVkXCI7XG4gIGl0ZW1faWQ6IHN0cmluZztcbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuICBlcnJvcjogUmVhbHRpbWVFcnJvcjtcbn1cblxuZXhwb3J0IHR5cGUgUmVzcG9uc2VTdGF0dXMgPVxuICB8IFwiaW5fcHJvZ3Jlc3NcIlxuICB8IFwiY29tcGxldGVkXCJcbiAgfCBcImNhbmNlbGxlZFwiXG4gIHwgXCJpbmNvbXBsZXRlXCJcbiAgfCBcImZhaWxlZFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQ2FuY2VsbGVkRGV0YWlscyB7XG4gIHR5cGU6IFwiY2FuY2VsbGVkXCI7XG4gIHJlYXNvbjogXCJ0dXJuX2RldGVjdGVkXCIgfCBcImNsaWVudF9jYW5jZWxsZWRcIjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUluY29tcGxldGVEZXRhaWxzIHtcbiAgdHlwZTogXCJpbmNvbXBsZXRlXCI7XG4gIHJlYXNvbjogXCJtYXhfb3V0cHV0X3Rva2Vuc1wiIHwgXCJjb250ZW50X2ZpbHRlclwiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlRmFpbGVkRGV0YWlscyB7XG4gIHR5cGU6IFwiZmFpbGVkXCI7XG4gIGVycm9yOiBSZWFsdGltZUVycm9yO1xufVxuXG5leHBvcnQgdHlwZSBSZXNwb25zZVN0YXR1c0RldGFpbHMgPVxuICB8IFJlc3BvbnNlQ2FuY2VsbGVkRGV0YWlsc1xuICB8IFJlc3BvbnNlSW5jb21wbGV0ZURldGFpbHNcbiAgfCBSZXNwb25zZUZhaWxlZERldGFpbHM7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRUb2tlbkRldGFpbHMge1xuICBjYWNoZWRfdG9rZW5zOiBudW1iZXI7XG4gIHRleHRfdG9rZW5zOiBudW1iZXI7XG4gIGF1ZGlvX3Rva2VuczogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE91dHB1dFRva2VuRGV0YWlscyB7XG4gIHRleHRfdG9rZW5zOiBudW1iZXI7XG4gIGF1ZGlvX3Rva2VuczogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzYWdlIHtcbiAgdG90YWxfdG9rZW5zOiBudW1iZXI7XG4gIGlucHV0X3Rva2VuczogbnVtYmVyO1xuICBvdXRwdXRfdG9rZW5zOiBudW1iZXI7XG4gIGlucHV0X3Rva2VuX2RldGFpbHM6IElucHV0VG9rZW5EZXRhaWxzO1xuICBvdXRwdXRfdG9rZW5fZGV0YWlsczogT3V0cHV0VG9rZW5EZXRhaWxzO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlIHtcbiAgaWQ6IHN0cmluZztcbiAgc3RhdHVzOiBSZXNwb25zZVN0YXR1cztcbiAgc3RhdHVzX2RldGFpbHM/OiBSZXNwb25zZVN0YXR1c0RldGFpbHM7XG4gIG91dHB1dDogUmVzcG9uc2VJdGVtW107XG4gIHVzYWdlPzogVXNhZ2U7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VDcmVhdGVkTWVzc2FnZSBleHRlbmRzIFNlcnZlck1lc3NhZ2VCYXNlIHtcbiAgdHlwZTogXCJyZXNwb25zZS5jcmVhdGVkXCI7XG4gIHJlc3BvbnNlOiBSZXNwb25zZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZURvbmVNZXNzYWdlIGV4dGVuZHMgU2VydmVyTWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcInJlc3BvbnNlLmRvbmVcIjtcbiAgcmVzcG9uc2U6IFJlc3BvbnNlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlT3V0cHV0SXRlbUFkZGVkTWVzc2FnZSBleHRlbmRzIFNlcnZlck1lc3NhZ2VCYXNlIHtcbiAgdHlwZTogXCJyZXNwb25zZS5vdXRwdXRfaXRlbS5hZGRlZFwiO1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcbiAgaXRlbTogUmVzcG9uc2VJdGVtO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlT3V0cHV0SXRlbURvbmVNZXNzYWdlIGV4dGVuZHMgU2VydmVyTWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcInJlc3BvbnNlLm91dHB1dF9pdGVtLmRvbmVcIjtcbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG4gIGl0ZW06IFJlc3BvbnNlSXRlbTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUNvbnRlbnRQYXJ0QWRkZWRNZXNzYWdlIGV4dGVuZHMgU2VydmVyTWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcInJlc3BvbnNlLmNvbnRlbnRfcGFydC5hZGRlZFwiO1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuICBpdGVtX2lkOiBzdHJpbmc7XG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG4gIHBhcnQ6IFJlc3BvbnNlSXRlbUNvbnRlbnRQYXJ0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQ29udGVudFBhcnREb25lTWVzc2FnZSBleHRlbmRzIFNlcnZlck1lc3NhZ2VCYXNlIHtcbiAgdHlwZTogXCJyZXNwb25zZS5jb250ZW50X3BhcnQuZG9uZVwiO1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuICBpdGVtX2lkOiBzdHJpbmc7XG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG4gIHBhcnQ6IFJlc3BvbnNlSXRlbUNvbnRlbnRQYXJ0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlVGV4dERlbHRhTWVzc2FnZSBleHRlbmRzIFNlcnZlck1lc3NhZ2VCYXNlIHtcbiAgdHlwZTogXCJyZXNwb25zZS50ZXh0LmRlbHRhXCI7XG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG4gIGl0ZW1faWQ6IHN0cmluZztcbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcbiAgZGVsdGE6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZVRleHREb25lTWVzc2FnZSBleHRlbmRzIFNlcnZlck1lc3NhZ2VCYXNlIHtcbiAgdHlwZTogXCJyZXNwb25zZS50ZXh0LmRvbmVcIjtcbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcbiAgaXRlbV9pZDogc3RyaW5nO1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VBdWRpb1RyYW5zY3JpcHREZWx0YU1lc3NhZ2UgZXh0ZW5kcyBTZXJ2ZXJNZXNzYWdlQmFzZSB7XG4gIHR5cGU6IFwicmVzcG9uc2UuYXVkaW9fdHJhbnNjcmlwdC5kZWx0YVwiO1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuICBpdGVtX2lkOiBzdHJpbmc7XG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG4gIGRlbHRhOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VBdWRpb1RyYW5zY3JpcHREb25lTWVzc2FnZSBleHRlbmRzIFNlcnZlck1lc3NhZ2VCYXNlIHtcbiAgdHlwZTogXCJyZXNwb25zZS5hdWRpb190cmFuc2NyaXB0LmRvbmVcIjtcbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcbiAgaXRlbV9pZDogc3RyaW5nO1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuICB0cmFuc2NyaXB0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VBdWRpb0RlbHRhTWVzc2FnZSBleHRlbmRzIFNlcnZlck1lc3NhZ2VCYXNlIHtcbiAgdHlwZTogXCJyZXNwb25zZS5hdWRpby5kZWx0YVwiO1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuICBpdGVtX2lkOiBzdHJpbmc7XG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG4gIGRlbHRhOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VBdWRpb0RvbmVNZXNzYWdlIGV4dGVuZHMgU2VydmVyTWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcInJlc3BvbnNlLmF1ZGlvLmRvbmVcIjtcbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcbiAgaXRlbV9pZDogc3RyaW5nO1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlRnVuY3Rpb25DYWxsQXJndW1lbnRzRGVsdGFNZXNzYWdlXG4gIGV4dGVuZHMgU2VydmVyTWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcInJlc3BvbnNlLmZ1bmN0aW9uX2NhbGxfYXJndW1lbnRzLmRlbHRhXCI7XG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG4gIGl0ZW1faWQ6IHN0cmluZztcbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG4gIGNhbGxfaWQ6IHN0cmluZztcbiAgZGVsdGE6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUZ1bmN0aW9uQ2FsbEFyZ3VtZW50c0RvbmVNZXNzYWdlXG4gIGV4dGVuZHMgU2VydmVyTWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcInJlc3BvbnNlLmZ1bmN0aW9uX2NhbGxfYXJndW1lbnRzLmRvbmVcIjtcbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcbiAgaXRlbV9pZDogc3RyaW5nO1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcbiAgY2FsbF9pZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGFyZ3VtZW50czogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJhdGVMaW1pdHMge1xuICBuYW1lOiBzdHJpbmc7XG4gIGxpbWl0OiBudW1iZXI7XG4gIHJlbWFpbmluZzogbnVtYmVyO1xuICByZXNldF9zZWNvbmRzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmF0ZUxpbWl0c1VwZGF0ZWRNZXNzYWdlIGV4dGVuZHMgU2VydmVyTWVzc2FnZUJhc2Uge1xuICB0eXBlOiBcInJhdGVfbGltaXRzLnVwZGF0ZWRcIjtcbiAgcmF0ZV9saW1pdHM6IFJhdGVMaW1pdHNbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uQXZhdGFyQ29ubmVjdGluZ01lc3NhZ2UgZXh0ZW5kcyBTZXJ2ZXJNZXNzYWdlQmFzZSB7XG4gIHR5cGU6IFwic2Vzc2lvbi5hdmF0YXIuY29ubmVjdGluZ1wiO1xuICBzZXJ2ZXJfc2RwOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VCbGVuZFNoYXBlTWVzc2FnZSBleHRlbmRzIFNlcnZlck1lc3NhZ2VCYXNlIHtcbiAgdHlwZTogXCJyZXNwb25zZS5hbmltYXRpb24uYmxlbmRzaGFwZXNcIjtcbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcbiAgaXRlbV9pZDogc3RyaW5nO1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuICBibGVuZHNoYXBlczogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBVc2VyTWVzc2FnZVR5cGUgPVxuICB8IFNlc3Npb25VcGRhdGVNZXNzYWdlXG4gIHwgSW5wdXRBdWRpb0J1ZmZlckFwcGVuZE1lc3NhZ2VcbiAgfCBJbnB1dEF1ZGlvQnVmZmVyQ29tbWl0TWVzc2FnZVxuICB8IElucHV0QXVkaW9CdWZmZXJDbGVhck1lc3NhZ2VcbiAgfCBJdGVtQ3JlYXRlTWVzc2FnZVxuICB8IEl0ZW1UcnVuY2F0ZU1lc3NhZ2VcbiAgfCBJdGVtRGVsZXRlTWVzc2FnZVxuICB8IFJlc3BvbnNlQ3JlYXRlTWVzc2FnZVxuICB8IFJlc3BvbnNlQ2FuY2VsTWVzc2FnZVxuICB8IFNlc3Npb25BdmF0YXJDb25uZWN0TWVzc2FnZTtcblxuZXhwb3J0IHR5cGUgU2VydmVyTWVzc2FnZVR5cGUgPVxuICB8IEVycm9yTWVzc2FnZVxuICB8IFNlc3Npb25DcmVhdGVkTWVzc2FnZVxuICB8IFNlc3Npb25VcGRhdGVkTWVzc2FnZVxuICB8IElucHV0QXVkaW9CdWZmZXJDb21taXR0ZWRNZXNzYWdlXG4gIHwgSW5wdXRBdWRpb0J1ZmZlckNsZWFyZWRNZXNzYWdlXG4gIHwgSW5wdXRBdWRpb0J1ZmZlclNwZWVjaFN0YXJ0ZWRNZXNzYWdlXG4gIHwgSW5wdXRBdWRpb0J1ZmZlclNwZWVjaFN0b3BwZWRNZXNzYWdlXG4gIHwgSXRlbUNyZWF0ZWRNZXNzYWdlXG4gIHwgSXRlbVRydW5jYXRlZE1lc3NhZ2VcbiAgfCBJdGVtRGVsZXRlZE1lc3NhZ2VcbiAgfCBJdGVtSW5wdXRBdWRpb1RyYW5zY3JpcHRpb25Db21wbGV0ZWRNZXNzYWdlXG4gIHwgSXRlbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uRmFpbGVkTWVzc2FnZVxuICB8IFJlc3BvbnNlQ3JlYXRlZE1lc3NhZ2VcbiAgfCBSZXNwb25zZURvbmVNZXNzYWdlXG4gIHwgUmVzcG9uc2VPdXRwdXRJdGVtQWRkZWRNZXNzYWdlXG4gIHwgUmVzcG9uc2VPdXRwdXRJdGVtRG9uZU1lc3NhZ2VcbiAgfCBSZXNwb25zZUNvbnRlbnRQYXJ0QWRkZWRNZXNzYWdlXG4gIHwgUmVzcG9uc2VDb250ZW50UGFydERvbmVNZXNzYWdlXG4gIHwgUmVzcG9uc2VUZXh0RGVsdGFNZXNzYWdlXG4gIHwgUmVzcG9uc2VUZXh0RG9uZU1lc3NhZ2VcbiAgfCBSZXNwb25zZUF1ZGlvVHJhbnNjcmlwdERlbHRhTWVzc2FnZVxuICB8IFJlc3BvbnNlQXVkaW9UcmFuc2NyaXB0RG9uZU1lc3NhZ2VcbiAgfCBSZXNwb25zZUF1ZGlvRGVsdGFNZXNzYWdlXG4gIHwgUmVzcG9uc2VBdWRpb0RvbmVNZXNzYWdlXG4gIHwgUmVzcG9uc2VCbGVuZFNoYXBlTWVzc2FnZVxuICB8IFJlc3BvbnNlRnVuY3Rpb25DYWxsQXJndW1lbnRzRGVsdGFNZXNzYWdlXG4gIHwgUmVzcG9uc2VGdW5jdGlvbkNhbGxBcmd1bWVudHNEb25lTWVzc2FnZVxuICB8IFJhdGVMaW1pdHNVcGRhdGVkTWVzc2FnZVxuICB8IFNlc3Npb25BdmF0YXJDb25uZWN0aW5nTWVzc2FnZTtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wsIEl0ZXJhdG9yICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2VzRGVjb3JhdGUoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcclxuICAgIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxyXG4gICAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcclxuICAgIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xyXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XHJcbiAgICB2YXIgXywgZG9uZSA9IGZhbHNlO1xyXG4gICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xyXG4gICAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XHJcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XHJcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XHJcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xyXG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcclxuICAgICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcclxuICAgIGRvbmUgPSB0cnVlO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcnVuSW5pdGlhbGl6ZXJzKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcclxuICAgIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Byb3BLZXkoeCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcInN5bWJvbFwiID8geCA6IFwiXCIuY29uY2F0KHgpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc2V0RnVuY3Rpb25OYW1lKGYsIG5hbWUsIHByZWZpeCkge1xyXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSBuYW1lID0gbmFtZS5kZXNjcmlwdGlvbiA/IFwiW1wiLmNvbmNhdChuYW1lLmRlc2NyaXB0aW9uLCBcIl1cIikgOiBcIlwiO1xyXG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcIm5hbWVcIiwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiIFwiLCBuYW1lKSA6IG5hbWUgfSk7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEl0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKTtcclxuICAgIHJldHVybiBnLm5leHQgPSB2ZXJiKDApLCBnW1widGhyb3dcIl0gPSB2ZXJiKDEpLCBnW1wicmV0dXJuXCJdID0gdmVyYigyKSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xyXG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcclxuICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgQXN5bmNJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gQXN5bmNJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBmYWxzZSB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcclxuICAgIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlKGVudiwgdmFsdWUsIGFzeW5jKSB7XHJcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xyXG4gICAgICAgIHZhciBkaXNwb3NlLCBpbm5lcjtcclxuICAgICAgICBpZiAoYXN5bmMpIHtcclxuICAgICAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNEaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jRGlzcG9zZSBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpc3Bvc2UgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgICAgICBkaXNwb3NlID0gdmFsdWVbU3ltYm9sLmRpc3Bvc2VdO1xyXG4gICAgICAgICAgICBpZiAoYXN5bmMpIGlubmVyID0gZGlzcG9zZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkaXNwb3NlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qgbm90IGRpc3Bvc2FibGUuXCIpO1xyXG4gICAgICAgIGlmIChpbm5lcikgZGlzcG9zZSA9IGZ1bmN0aW9uKCkgeyB0cnkgeyBpbm5lci5jYWxsKHRoaXMpOyB9IGNhdGNoIChlKSB7IHJldHVybiBQcm9taXNlLnJlamVjdChlKTsgfSB9O1xyXG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBkaXNwb3NlOiBkaXNwb3NlLCBhc3luYzogYXN5bmMgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhc3luYykge1xyXG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcblxyXG59XHJcblxyXG52YXIgX1N1cHByZXNzZWRFcnJvciA9IHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGlzcG9zZVJlc291cmNlcyhlbnYpIHtcclxuICAgIGZ1bmN0aW9uIGZhaWwoZSkge1xyXG4gICAgICAgIGVudi5lcnJvciA9IGVudi5oYXNFcnJvciA/IG5ldyBfU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcclxuICAgICAgICBlbnYuaGFzRXJyb3IgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIHIsIHMgPSAwO1xyXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcclxuICAgICAgICB3aGlsZSAociA9IGVudi5zdGFjay5wb3AoKSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyLmFzeW5jICYmIHMgPT09IDEpIHJldHVybiBzID0gMCwgZW52LnN0YWNrLnB1c2gociksIFByb21pc2UucmVzb2x2ZSgpLnRoZW4obmV4dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoci5kaXNwb3NlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHIuZGlzcG9zZS5jYWxsKHIudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmFzeW5jKSByZXR1cm4gcyB8PSAyLCBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKG5leHQsIGZ1bmN0aW9uKGUpIHsgZmFpbChlKTsgcmV0dXJuIG5leHQoKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHMgfD0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgZmFpbChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocyA9PT0gMSkgcmV0dXJuIGVudi5oYXNFcnJvciA/IFByb21pc2UucmVqZWN0KGVudi5lcnJvcikgOiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICBpZiAoZW52Lmhhc0Vycm9yKSB0aHJvdyBlbnYuZXJyb3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV4dCgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24ocGF0aCwgcHJlc2VydmVKc3gpIHtcclxuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIiAmJiAvXlxcLlxcLj9cXC8vLnRlc3QocGF0aCkpIHtcclxuICAgICAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC4odHN4KSR8KCg/OlxcLmQpPykoKD86XFwuW14uL10rPyk/KVxcLihbY21dPyl0cyQvaSwgZnVuY3Rpb24gKG0sIHRzeCwgZCwgZXh0LCBjbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHN4ID8gcHJlc2VydmVKc3ggPyBcIi5qc3hcIiA6IFwiLmpzXCIgOiBkICYmICghZXh0IHx8ICFjbSkgPyBtIDogKGQgKyBleHQgKyBcIi5cIiArIGNtLnRvTG93ZXJDYXNlKCkgKyBcImpzXCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhdGg7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIF9fZXh0ZW5kczogX19leHRlbmRzLFxyXG4gICAgX19hc3NpZ246IF9fYXNzaWduLFxyXG4gICAgX19yZXN0OiBfX3Jlc3QsXHJcbiAgICBfX2RlY29yYXRlOiBfX2RlY29yYXRlLFxyXG4gICAgX19wYXJhbTogX19wYXJhbSxcclxuICAgIF9fZXNEZWNvcmF0ZTogX19lc0RlY29yYXRlLFxyXG4gICAgX19ydW5Jbml0aWFsaXplcnM6IF9fcnVuSW5pdGlhbGl6ZXJzLFxyXG4gICAgX19wcm9wS2V5OiBfX3Byb3BLZXksXHJcbiAgICBfX3NldEZ1bmN0aW9uTmFtZTogX19zZXRGdW5jdGlvbk5hbWUsXHJcbiAgICBfX21ldGFkYXRhOiBfX21ldGFkYXRhLFxyXG4gICAgX19hd2FpdGVyOiBfX2F3YWl0ZXIsXHJcbiAgICBfX2dlbmVyYXRvcjogX19nZW5lcmF0b3IsXHJcbiAgICBfX2NyZWF0ZUJpbmRpbmc6IF9fY3JlYXRlQmluZGluZyxcclxuICAgIF9fZXhwb3J0U3RhcjogX19leHBvcnRTdGFyLFxyXG4gICAgX192YWx1ZXM6IF9fdmFsdWVzLFxyXG4gICAgX19yZWFkOiBfX3JlYWQsXHJcbiAgICBfX3NwcmVhZDogX19zcHJlYWQsXHJcbiAgICBfX3NwcmVhZEFycmF5czogX19zcHJlYWRBcnJheXMsXHJcbiAgICBfX3NwcmVhZEFycmF5OiBfX3NwcmVhZEFycmF5LFxyXG4gICAgX19hd2FpdDogX19hd2FpdCxcclxuICAgIF9fYXN5bmNHZW5lcmF0b3I6IF9fYXN5bmNHZW5lcmF0b3IsXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yOiBfX2FzeW5jRGVsZWdhdG9yLFxyXG4gICAgX19hc3luY1ZhbHVlczogX19hc3luY1ZhbHVlcyxcclxuICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0OiBfX21ha2VUZW1wbGF0ZU9iamVjdCxcclxuICAgIF9faW1wb3J0U3RhcjogX19pbXBvcnRTdGFyLFxyXG4gICAgX19pbXBvcnREZWZhdWx0OiBfX2ltcG9ydERlZmF1bHQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0OiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldDogX19jbGFzc1ByaXZhdGVGaWVsZFNldCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRJbjogX19jbGFzc1ByaXZhdGVGaWVsZEluLFxyXG4gICAgX19hZGREaXNwb3NhYmxlUmVzb3VyY2U6IF9fYWRkRGlzcG9zYWJsZVJlc291cmNlLFxyXG4gICAgX19kaXNwb3NlUmVzb3VyY2VzOiBfX2Rpc3Bvc2VSZXNvdXJjZXMsXHJcbiAgICBfX3Jld3JpdGVSZWxhdGl2ZUltcG9ydEV4dGVuc2lvbjogX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24sXHJcbn07XHJcbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG5pbXBvcnQgeyBTZXJ2ZXJNZXNzYWdlVHlwZSB9IGZyb20gXCIuL21vZGVsc1wiO1xuXG5jb25zdCBpc1JlYWx0aW1lRXZlbnQgPSAobWVzc2FnZTogdW5rbm93bik6IG1lc3NhZ2UgaXMgeyB0eXBlOiBzdHJpbmcgfSA9PlxuICB0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJiBtZXNzYWdlICE9PSBudWxsICYmIFwidHlwZVwiIGluIG1lc3NhZ2U7XG5cbmV4cG9ydCBjb25zdCBpc1NlcnZlck1lc3NhZ2VUeXBlID0gKFxuICBtZXNzYWdlOiB1bmtub3duLFxuKTogbWVzc2FnZSBpcyBTZXJ2ZXJNZXNzYWdlVHlwZSA9PlxuICBpc1JlYWx0aW1lRXZlbnQobWVzc2FnZSkgJiZcbiAgW1xuICAgIFwiZXJyb3JcIixcbiAgICBcInNlc3Npb24uY3JlYXRlZFwiLFxuICAgIFwic2Vzc2lvbi51cGRhdGVkXCIsXG4gICAgXCJpbnB1dF9hdWRpb19idWZmZXIuY29tbWl0dGVkXCIsXG4gICAgXCJpbnB1dF9hdWRpb19idWZmZXIuY2xlYXJlZFwiLFxuICAgIFwiaW5wdXRfYXVkaW9fYnVmZmVyLnNwZWVjaF9zdGFydGVkXCIsXG4gICAgXCJpbnB1dF9hdWRpb19idWZmZXIuc3BlZWNoX3N0b3BwZWRcIixcbiAgICBcImNvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZWRcIixcbiAgICBcImNvbnZlcnNhdGlvbi5pdGVtLnRydW5jYXRlZFwiLFxuICAgIFwiY29udmVyc2F0aW9uLml0ZW0uZGVsZXRlZFwiLFxuICAgIFwiY29udmVyc2F0aW9uLml0ZW0uaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbi5jb21wbGV0ZWRcIixcbiAgICBcImNvbnZlcnNhdGlvbi5pdGVtLmlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24uZmFpbGVkXCIsXG4gICAgXCJyZXNwb25zZS5jcmVhdGVkXCIsXG4gICAgXCJyZXNwb25zZS5kb25lXCIsXG4gICAgXCJyZXNwb25zZS5vdXRwdXRfaXRlbS5hZGRlZFwiLFxuICAgIFwicmVzcG9uc2Uub3V0cHV0X2l0ZW0uZG9uZVwiLFxuICAgIFwicmVzcG9uc2UuY29udGVudF9wYXJ0LmFkZGVkXCIsXG4gICAgXCJyZXNwb25zZS5jb250ZW50X3BhcnQuZG9uZVwiLFxuICAgIFwicmVzcG9uc2UudGV4dC5kZWx0YVwiLFxuICAgIFwicmVzcG9uc2UudGV4dC5kb25lXCIsXG4gICAgXCJyZXNwb25zZS5hdWRpb190cmFuc2NyaXB0LmRlbHRhXCIsXG4gICAgXCJyZXNwb25zZS5hdWRpb190cmFuc2NyaXB0LmRvbmVcIixcbiAgICBcInJlc3BvbnNlLmF1ZGlvLmRlbHRhXCIsXG4gICAgXCJyZXNwb25zZS5hdWRpby5kb25lXCIsXG4gICAgXCJyZXNwb25zZS5mdW5jdGlvbl9jYWxsX2FyZ3VtZW50cy5kZWx0YVwiLFxuICAgIFwicmVzcG9uc2UuZnVuY3Rpb25fY2FsbF9hcmd1bWVudHMuZG9uZVwiLFxuICAgIFwicmF0ZV9saW1pdHMudXBkYXRlZFwiLFxuICAgIFwic2Vzc2lvbi5hdmF0YXIuY29ubmVjdGluZ1wiLFxuICAgIFwic2Vzc2lvbi5hdmF0YXIuY29ubmVjdGVkXCIsXG4gICAgXCJyZXNwb25zZS5hbmltYXRpb24uYmxlbmRzaGFwZXNcIixcbiAgXS5pbmNsdWRlcyhtZXNzYWdlLnR5cGUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCSU5BUllfVFlQRVMgPSBbJ25vZGVidWZmZXInLCAnYXJyYXlidWZmZXInLCAnZnJhZ21lbnRzJ107XG5jb25zdCBoYXNCbG9iID0gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnO1xuXG5pZiAoaGFzQmxvYikgQklOQVJZX1RZUEVTLnB1c2goJ2Jsb2InKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEJJTkFSWV9UWVBFUyxcbiAgRU1QVFlfQlVGRkVSOiBCdWZmZXIuYWxsb2MoMCksXG4gIEdVSUQ6ICcyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTEnLFxuICBoYXNCbG9iLFxuICBrRm9yT25FdmVudEF0dHJpYnV0ZTogU3ltYm9sKCdrSXNGb3JPbkV2ZW50QXR0cmlidXRlJyksXG4gIGtMaXN0ZW5lcjogU3ltYm9sKCdrTGlzdGVuZXInKSxcbiAga1N0YXR1c0NvZGU6IFN5bWJvbCgnc3RhdHVzLWNvZGUnKSxcbiAga1dlYlNvY2tldDogU3ltYm9sKCd3ZWJzb2NrZXQnKSxcbiAgTk9PUDogKCkgPT4ge31cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBGYXN0QnVmZmVyID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXTtcblxuLyoqXG4gKiBNZXJnZXMgYW4gYXJyYXkgb2YgYnVmZmVycyBpbnRvIGEgbmV3IGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBhcnJheSBvZiBidWZmZXJzIHRvIGNvbmNhdFxuICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsTGVuZ3RoIFRoZSB0b3RhbCBsZW5ndGggb2YgYnVmZmVycyBpbiB0aGUgbGlzdFxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgcmVzdWx0aW5nIGJ1ZmZlclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjb25jYXQobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXR1cm4gRU1QVFlfQlVGRkVSO1xuICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHJldHVybiBsaXN0WzBdO1xuXG4gIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0b3RhbExlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJ1ZiA9IGxpc3RbaV07XG4gICAgdGFyZ2V0LnNldChidWYsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGJ1Zi5sZW5ndGg7XG4gIH1cblxuICBpZiAob2Zmc2V0IDwgdG90YWxMZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IEZhc3RCdWZmZXIodGFyZ2V0LmJ1ZmZlciwgdGFyZ2V0LmJ5dGVPZmZzZXQsIG9mZnNldCk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIE1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBzb3VyY2UgVGhlIGJ1ZmZlciB0byBtYXNrXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBvdXRwdXQgVGhlIGJ1ZmZlciB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgd3JpdGluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIG1hc2suXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0W29mZnNldCArIGldID0gc291cmNlW2ldIF4gbWFza1tpICYgM107XG4gIH1cbn1cblxuLyoqXG4gKiBVbm1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byB1bm1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfdW5tYXNrKGJ1ZmZlciwgbWFzaykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGJ1ZmZlcltpXSBePSBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYnVmZmVyIHRvIGFuIGBBcnJheUJ1ZmZlcmAuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBDb252ZXJ0ZWQgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gYnVmLmJ1ZmZlcjtcbiAgfVxuXG4gIHJldHVybiBidWYuYnVmZmVyLnNsaWNlKGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZU9mZnNldCArIGJ1Zi5sZW5ndGgpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBkYXRhYCB0byBhIGBCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgZGF0YSB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBidWZmZXJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9CdWZmZXIoZGF0YSkge1xuICB0b0J1ZmZlci5yZWFkT25seSA9IHRydWU7XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgcmV0dXJuIGRhdGE7XG5cbiAgbGV0IGJ1ZjtcblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgYnVmID0gbmV3IEZhc3RCdWZmZXIoZGF0YSk7XG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgYnVmID0gbmV3IEZhc3RCdWZmZXIoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICB0b0J1ZmZlci5yZWFkT25seSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbmNhdCxcbiAgbWFzazogX21hc2ssXG4gIHRvQXJyYXlCdWZmZXIsXG4gIHRvQnVmZmVyLFxuICB1bm1hc2s6IF91bm1hc2tcbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuaWYgKCFwcm9jZXNzLmVudi5XU19OT19CVUZGRVJfVVRJTCkge1xuICB0cnkge1xuICAgIGNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCdidWZmZXJ1dGlsJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cy5tYXNrID0gZnVuY3Rpb24gKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA8IDQ4KSBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgZWxzZSBidWZmZXJVdGlsLm1hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMudW5tYXNrID0gZnVuY3Rpb24gKGJ1ZmZlciwgbWFzaykge1xuICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPCAzMikgX3VubWFzayhidWZmZXIsIG1hc2spO1xuICAgICAgZWxzZSBidWZmZXJVdGlsLnVubWFzayhidWZmZXIsIG1hc2spO1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBDb250aW51ZSByZWdhcmRsZXNzIG9mIHRoZSBlcnJvci5cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBrRG9uZSA9IFN5bWJvbCgna0RvbmUnKTtcbmNvbnN0IGtSdW4gPSBTeW1ib2woJ2tSdW4nKTtcblxuLyoqXG4gKiBBIHZlcnkgc2ltcGxlIGpvYiBxdWV1ZSB3aXRoIGFkanVzdGFibGUgY29uY3VycmVuY3kuIEFkYXB0ZWQgZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL1NUUk1ML2FzeW5jLWxpbWl0ZXJcbiAqL1xuY2xhc3MgTGltaXRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBMaW1pdGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25jdXJyZW5jeT1JbmZpbml0eV0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGpvYnMgYWxsb3dlZFxuICAgKiAgICAgdG8gcnVuIGNvbmN1cnJlbnRseVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uY3VycmVuY3kpIHtcbiAgICB0aGlzW2tEb25lXSA9ICgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZy0tO1xuICAgICAgdGhpc1trUnVuXSgpO1xuICAgIH07XG4gICAgdGhpcy5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5IHx8IEluZmluaXR5O1xuICAgIHRoaXMuam9icyA9IFtdO1xuICAgIHRoaXMucGVuZGluZyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGpvYiB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGpvYiBUaGUgam9iIHRvIHJ1blxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGQoam9iKSB7XG4gICAgdGhpcy5qb2JzLnB1c2goam9iKTtcbiAgICB0aGlzW2tSdW5dKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGpvYiBmcm9tIHRoZSBxdWV1ZSBhbmQgcnVucyBpdCBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFtrUnVuXSgpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nID09PSB0aGlzLmNvbmN1cnJlbmN5KSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5qb2JzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgam9iID0gdGhpcy5qb2JzLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMucGVuZGluZysrO1xuICAgICAgam9iKHRoaXNba0RvbmVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMaW1pdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuXG5jb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgTGltaXRlciA9IHJlcXVpcmUoJy4vbGltaXRlcicpO1xuY29uc3QgeyBrU3RhdHVzQ29kZSB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5jb25zdCBUUkFJTEVSID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4ZmYsIDB4ZmZdKTtcbmNvbnN0IGtQZXJNZXNzYWdlRGVmbGF0ZSA9IFN5bWJvbCgncGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBrVG90YWxMZW5ndGggPSBTeW1ib2woJ3RvdGFsLWxlbmd0aCcpO1xuY29uc3Qga0NhbGxiYWNrID0gU3ltYm9sKCdjYWxsYmFjaycpO1xuY29uc3Qga0J1ZmZlcnMgPSBTeW1ib2woJ2J1ZmZlcnMnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcblxuLy9cbi8vIFdlIGxpbWl0IHpsaWIgY29uY3VycmVuY3ksIHdoaWNoIHByZXZlbnRzIHNldmVyZSBtZW1vcnkgZnJhZ21lbnRhdGlvblxuLy8gYXMgZG9jdW1lbnRlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzg4NzEjaXNzdWVjb21tZW50LTI1MDkxNTkxM1xuLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xMjAyXG4vL1xuLy8gSW50ZW50aW9uYWxseSBnbG9iYWw7IGl0J3MgdGhlIGdsb2JhbCB0aHJlYWQgcG9vbCB0aGF0J3MgYW4gaXNzdWUuXG4vL1xubGV0IHpsaWJMaW1pdGVyO1xuXG4vKipcbiAqIHBlcm1lc3NhZ2UtZGVmbGF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgUGVyTWVzc2FnZURlZmxhdGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBlck1lc3NhZ2VEZWZsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHNdIEFkdmVydGlzZSBzdXBwb3J0XG4gICAqICAgICBmb3IsIG9yIHJlcXVlc3QsIGEgY3VzdG9tIGNsaWVudCB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBBZHZlcnRpc2UvXG4gICAqICAgICBhY2tub3dsZWRnZSBkaXNhYmxpbmcgb2YgY2xpZW50IGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbmN1cnJlbmN5TGltaXQ9MTBdIFRoZSBudW1iZXIgb2YgY29uY3VycmVudFxuICAgKiAgICAgY2FsbHMgdG8gemxpYlxuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHNdIFJlcXVlc3QvY29uZmlybSB0aGVcbiAgICogICAgIHVzZSBvZiBhIGN1c3RvbSBzZXJ2ZXIgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gUmVxdWVzdC9hY2NlcHRcbiAgICogICAgIGRpc2FibGluZyBvZiBzZXJ2ZXIgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGhyZXNob2xkPTEwMjRdIFNpemUgKGluIGJ5dGVzKSBiZWxvdyB3aGljaFxuICAgKiAgICAgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBjb21wcmVzc2VkIGlmIGNvbnRleHQgdGFrZW92ZXIgaXMgZGlzYWJsZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGRlZmxhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGluZmxhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNTZXJ2ZXI9ZmFsc2VdIENyZWF0ZSB0aGUgaW5zdGFuY2UgaW4gZWl0aGVyIHNlcnZlciBvclxuICAgKiAgICAgY2xpZW50IG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX3RocmVzaG9sZCA9XG4gICAgICB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgOiAxMDI0O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFpc1NlcnZlcjtcbiAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcblxuICAgIHRoaXMucGFyYW1zID0gbnVsbDtcblxuICAgIGlmICghemxpYkxpbWl0ZXIpIHtcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID1cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdFxuICAgICAgICAgIDogMTA7XG4gICAgICB6bGliTGltaXRlciA9IG5ldyBMaW1pdGVyKGNvbmN1cnJlbmN5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZXh0ZW5zaW9uTmFtZSgpIHtcbiAgICByZXR1cm4gJ3Blcm1lc3NhZ2UtZGVmbGF0ZSc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBFeHRlbnNpb24gcGFyYW1ldGVyc1xuICAgKiBAcHVibGljXG4gICAqL1xuICBvZmZlcigpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09IG51bGwpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIvcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFjY2VwdChjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zID0gdGhpcy5ub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgdGhpcy5wYXJhbXMgPSB0aGlzLl9pc1NlcnZlclxuICAgICAgPyB0aGlzLmFjY2VwdEFzU2VydmVyKGNvbmZpZ3VyYXRpb25zKVxuICAgICAgOiB0aGlzLmFjY2VwdEFzQ2xpZW50KGNvbmZpZ3VyYXRpb25zKTtcblxuICAgIHJldHVybiB0aGlzLnBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbGwgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGV4dGVuc2lvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5faW5mbGF0ZSkge1xuICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQnXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAgQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gb2ZmZXJzIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNTZXJ2ZXIob2ZmZXJzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMuX29wdGlvbnM7XG4gICAgY29uc3QgYWNjZXB0ZWQgPSBvZmZlcnMuZmluZCgocGFyYW1zKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcikgfHxcbiAgICAgICAgKHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzICYmXG4gICAgICAgICAgKG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPiBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cykpKSB8fFxuICAgICAgICAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAhcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGlmICghYWNjZXB0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9uZSBvZiB0aGUgZXh0ZW5zaW9uIG9mZmVycyBjYW4gYmUgYWNjZXB0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0cy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9IG9wdHMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9PT0gdHJ1ZSB8fFxuICAgICAgb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZVxuICAgICkge1xuICAgICAgZGVsZXRlIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY2VwdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCB0aGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSByZXNwb25zZSBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNDbGllbnQocmVzcG9uc2UpIHtcbiAgICBjb25zdCBwYXJhbXMgPSByZXNwb25zZVswXTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBwYXJhbWV0ZXIgXCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclwiJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG4gICAgICAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVbmV4cGVjdGVkIG9yIGludmFsaWQgcGFyYW1ldGVyIFwiY2xpZW50X21heF93aW5kb3dfYml0c1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgb2ZmZXJzL3Jlc3BvbnNlIHdpdGggbm9ybWFsaXplZCBwYXJhbWV0ZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucy5mb3JFYWNoKChwYXJhbXMpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJhbWV0ZXIgXCIke2tleX1cIiBtdXN0IGhhdmUgb25seSBhIHNpbmdsZSB2YWx1ZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnY2xpZW50X21heF93aW5kb3dfYml0cycpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInIHx8XG4gICAgICAgICAga2V5ID09PSAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbWV0ZXIgXCIke2tleX1cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fZGVjb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnY2xpZW50JyA6ICdzZXJ2ZXInO1xuXG4gICAgaWYgKCF0aGlzLl9pbmZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2luZmxhdGUgPSB6bGliLmNyZWF0ZUluZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tQZXJNZXNzYWdlRGVmbGF0ZV0gPSB0aGlzO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdlcnJvcicsIGluZmxhdGVPbkVycm9yKTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbmZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2luZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgaWYgKGZpbikgdGhpcy5faW5mbGF0ZS53cml0ZShUUkFJTEVSKTtcblxuICAgIHRoaXMuX2luZmxhdGUuZmx1c2goKCkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gdGhpcy5faW5mbGF0ZVtrRXJyb3JdO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAodGhpcy5faW5mbGF0ZS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICAgIHRoaXMuX2luZmxhdGUucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnc2VydmVyJyA6ICdjbGllbnQnO1xuXG4gICAgaWYgKCF0aGlzLl9kZWZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUgPSB6bGliLmNyZWF0ZURlZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLm9uKCdkYXRhJywgZGVmbGF0ZU9uRGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLl9kZWZsYXRlLndyaXRlKGRhdGEpO1xuICAgIHRoaXMuX2RlZmxhdGUuZmx1c2goemxpYi5aX1NZTkNfRkxVU0gsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAgIC8vXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKGZpbikge1xuICAgICAgICBkYXRhID0gbmV3IEZhc3RCdWZmZXIoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5sZW5ndGggLSA0KTtcbiAgICAgIH1cblxuICAgICAgLy9cbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgYWdhaW4gaW5cbiAgICAgIC8vIGBQZXJNZXNzYWdlRGVmbGF0ZSNjbGVhbnVwKClgLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IG51bGw7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZS5yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlck1lc3NhZ2VEZWZsYXRlO1xuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuRGVmbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xuXG4gIGlmIChcbiAgICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWQgPCAxIHx8XG4gICAgdGhpc1trVG90YWxMZW5ndGhdIDw9IHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZFxuICApIHtcbiAgICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzW2tFcnJvcl0gPSBuZXcgUmFuZ2VFcnJvcignTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcpO1xuICB0aGlzW2tFcnJvcl0uY29kZSA9ICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnO1xuICB0aGlzW2tFcnJvcl1ba1N0YXR1c0NvZGVdID0gMTAwOTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICB0aGlzLnJlc2V0KCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRXJyb3IoZXJyKSB7XG4gIC8vXG4gIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBgWmxpYiNjbG9zZSgpYCBhcyB0aGUgaGFuZGxlIGlzIGF1dG9tYXRpY2FsbHlcbiAgLy8gY2xvc2VkIHdoZW4gYW4gZXJyb3IgaXMgZW1pdHRlZC5cbiAgLy9cbiAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9pbmZsYXRlID0gbnVsbDtcbiAgZXJyW2tTdGF0dXNDb2RlXSA9IDEwMDc7XG4gIHRoaXNba0NhbGxiYWNrXShlcnIpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IGlzVXRmOCB9ID0gcmVxdWlyZSgnYnVmZmVyJyk7XG5cbmNvbnN0IHsgaGFzQmxvYiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuLy9cbi8vIEFsbG93ZWQgdG9rZW4gY2hhcmFjdGVyczpcbi8vXG4vLyAnIScsICcjJywgJyQnLCAnJScsICcmJywgJycnLCAnKicsICcrJywgJy0nLFxuLy8gJy4nLCAwLTksIEEtWiwgJ14nLCAnXycsICdgJywgYS16LCAnfCcsICd+J1xuLy9cbi8vIHRva2VuQ2hhcnNbMzJdID09PSAwIC8vICcgJ1xuLy8gdG9rZW5DaGFyc1szM10gPT09IDEgLy8gJyEnXG4vLyB0b2tlbkNoYXJzWzM0XSA9PT0gMCAvLyAnXCInXG4vLyAuLi5cbi8vXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHRva2VuQ2hhcnMgPSBbXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDAgLSAxNVxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAxNiAtIDMxXG4gIDAsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDAsIDEsIDEsIDAsIC8vIDMyIC0gNDdcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gNDggLSA2M1xuICAwLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA2NCAtIDc5XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDEsIDEsIC8vIDgwIC0gOTVcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gOTYgLSAxMTFcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMSwgMCAvLyAxMTIgLSAxMjdcbl07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhdHVzIGNvZGUgaXMgYWxsb3dlZCBpbiBhIGNsb3NlIGZyYW1lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBzdGF0dXMgY29kZSBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICAoY29kZSA+PSAxMDAwICYmXG4gICAgICBjb2RlIDw9IDEwMTQgJiZcbiAgICAgIGNvZGUgIT09IDEwMDQgJiZcbiAgICAgIGNvZGUgIT09IDEwMDUgJiZcbiAgICAgIGNvZGUgIT09IDEwMDYpIHx8XG4gICAgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTkpXG4gICk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYnVmZmVyIGNvbnRhaW5zIG9ubHkgY29ycmVjdCBVVEYtOC5cbiAqIFBvcnRlZCBmcm9tIGh0dHBzOi8vd3d3LmNsLmNhbS5hYy51ay8lN0VtZ2syNS91Y3MvdXRmOF9jaGVjay5jIGJ5XG4gKiBNYXJrdXMgS3Vobi5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgYnVmYCBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTgsIGVsc2UgYGZhbHNlYFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfaXNWYWxpZFVURjgoYnVmKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gIGxldCBpID0gMDtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmICgoYnVmW2ldICYgMHg4MCkgPT09IDApIHtcbiAgICAgIC8vIDB4eHh4eHh4XG4gICAgICBpKys7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgIC8vIDExMHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAxID09PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldICYgMHhmZSkgPT09IDB4YzAgLy8gT3ZlcmxvbmdcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMjtcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgLy8gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDIgPj0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldID09PSAweGUwICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4ODApIHx8IC8vIE92ZXJsb25nXG4gICAgICAgIChidWZbaV0gPT09IDB4ZWQgJiYgKGJ1ZltpICsgMV0gJiAweGUwKSA9PT0gMHhhMCkgLy8gU3Vycm9nYXRlIChVK0Q4MDAgLSBVK0RGRkYpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDM7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgIC8vIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAzID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgM10gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldID09PSAweGYwICYmIChidWZbaSArIDFdICYgMHhmMCkgPT09IDB4ODApIHx8IC8vIE92ZXJsb25nXG4gICAgICAgIChidWZbaV0gPT09IDB4ZjQgJiYgYnVmW2kgKyAxXSA+IDB4OGYpIHx8XG4gICAgICAgIGJ1ZltpXSA+IDB4ZjQgLy8gPiBVKzEwRkZGRlxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgdmFsdWUgaXMgYSBgQmxvYmAuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGBCbG9iYCwgZWxzZSBgZmFsc2VgXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBoYXNCbG9iICYmXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5hcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS50eXBlID09PSAnc3RyaW5nJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5zdHJlYW0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAodmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0Jsb2InIHx8XG4gICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnRmlsZScpXG4gICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0Jsb2IsXG4gIGlzVmFsaWRTdGF0dXNDb2RlLFxuICBpc1ZhbGlkVVRGODogX2lzVmFsaWRVVEY4LFxuICB0b2tlbkNoYXJzXG59O1xuXG5pZiAoaXNVdGY4KSB7XG4gIG1vZHVsZS5leHBvcnRzLmlzVmFsaWRVVEY4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHJldHVybiBidWYubGVuZ3RoIDwgMjQgPyBfaXNWYWxpZFVURjgoYnVmKSA6IGlzVXRmOChidWYpO1xuICB9O1xufSAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi8gZWxzZSBpZiAoIXByb2Nlc3MuZW52LldTX05PX1VURl84X1ZBTElEQVRFKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgaXNWYWxpZFVURjggPSByZXF1aXJlKCd1dGYtOC12YWxpZGF0ZScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMuaXNWYWxpZFVURjggPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDMyID8gX2lzVmFsaWRVVEY4KGJ1ZikgOiBpc1ZhbGlkVVRGOChidWYpO1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBDb250aW51ZSByZWdhcmRsZXNzIG9mIHRoZSBlcnJvci5cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFdyaXRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXRcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBjb25jYXQsIHRvQXJyYXlCdWZmZXIsIHVubWFzayB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSwgaXNWYWxpZFVURjggfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG5jb25zdCBGYXN0QnVmZmVyID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXTtcblxuY29uc3QgR0VUX0lORk8gPSAwO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzE2ID0gMTtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF82NCA9IDI7XG5jb25zdCBHRVRfTUFTSyA9IDM7XG5jb25zdCBHRVRfREFUQSA9IDQ7XG5jb25zdCBJTkZMQVRJTkcgPSA1O1xuY29uc3QgREVGRVJfRVZFTlQgPSA2O1xuXG4vKipcbiAqIEh5QmkgUmVjZWl2ZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGV4dGVuZHMgV3JpdGFibGVcbiAqL1xuY2xhc3MgUmVjZWl2ZXIgZXh0ZW5kcyBXcml0YWJsZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVjZWl2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYmluYXJ5VHlwZT1ub2RlYnVmZmVyXSBUaGUgdHlwZSBmb3IgYmluYXJ5IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkXG4gICAqICAgICBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNTZXJ2ZXI9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRvIG9wZXJhdGUgaW5cbiAgICogICAgIGNsaWVudCBvciBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzID1cbiAgICAgIG9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzXG4gICAgICAgIDogdHJ1ZTtcbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gb3B0aW9ucy5iaW5hcnlUeXBlIHx8IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zIHx8IHt9O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFvcHRpb25zLmlzU2VydmVyO1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBvcHRpb25zLm1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiA9ICEhb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb247XG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2J1ZmZlcnMgPSBbXTtcblxuICAgIHRoaXMuX2NvbXByZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXNrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX21hc2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbiA9IGZhbHNlO1xuICAgIHRoaXMuX29wY29kZSA9IDA7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fZXJyb3JlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgYFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBUaGUgY2h1bmsgb2YgZGF0YSB0byB3cml0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgVGhlIGNoYXJhY3RlciBlbmNvZGluZyBvZiBgY2h1bmtgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDggJiYgdGhpcy5fc3RhdGUgPT0gR0VUX0lORk8pIHJldHVybiBjYigpO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3VtZXMgYG5gIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29uc3VtZVxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBjb25zdW1lZCBieXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3VtZShuKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBuO1xuXG4gICAgaWYgKG4gPT09IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSByZXR1cm4gdGhpcy5fYnVmZmVycy5zaGlmdCgpO1xuXG4gICAgaWYgKG4gPCB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgYnVmLmJ1ZmZlcixcbiAgICAgICAgYnVmLmJ5dGVPZmZzZXQgKyBuLFxuICAgICAgICBidWYubGVuZ3RoIC0gblxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKTtcbiAgICB9XG5cbiAgICBjb25zdCBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG5cbiAgICBkbyB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gZHN0Lmxlbmd0aCAtIG47XG5cbiAgICAgIGlmIChuID49IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgZHN0LnNldCh0aGlzLl9idWZmZXJzLnNoaWZ0KCksIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkc3Quc2V0KG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKSwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IG5ldyBGYXN0QnVmZmVyKFxuICAgICAgICAgIGJ1Zi5idWZmZXIsXG4gICAgICAgICAgYnVmLmJ5dGVPZmZzZXQgKyBuLFxuICAgICAgICAgIGJ1Zi5sZW5ndGggLSBuXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIG4gLT0gYnVmLmxlbmd0aDtcbiAgICB9IHdoaWxlIChuID4gMCk7XG5cbiAgICByZXR1cm4gZHN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcGFyc2luZyBsb29wLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRMb29wKGNiKSB7XG4gICAgdGhpcy5fbG9vcCA9IHRydWU7XG5cbiAgICBkbyB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIGNhc2UgR0VUX0lORk86XG4gICAgICAgICAgdGhpcy5nZXRJbmZvKGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY6XG4gICAgICAgICAgdGhpcy5nZXRQYXlsb2FkTGVuZ3RoMTYoY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF82NDpcbiAgICAgICAgICB0aGlzLmdldFBheWxvYWRMZW5ndGg2NChjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX01BU0s6XG4gICAgICAgICAgdGhpcy5nZXRNYXNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX0RBVEE6XG4gICAgICAgICAgdGhpcy5nZXREYXRhKGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBJTkZMQVRJTkc6XG4gICAgICAgIGNhc2UgREVGRVJfRVZFTlQ6XG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0aGlzLl9sb29wKTtcblxuICAgIGlmICghdGhpcy5fZXJyb3JlZCkgY2IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgZmlyc3QgdHdvIGJ5dGVzIG9mIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRJbmZvKGNiKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDIpO1xuXG4gICAgaWYgKChidWZbMF0gJiAweDMwKSAhPT0gMHgwMCkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnUlNWMiBhbmQgUlNWMyBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8yXzMnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29tcHJlc3NlZCA9IChidWZbMF0gJiAweDQwKSA9PT0gMHg0MDtcblxuICAgIGlmIChjb21wcmVzc2VkICYmICF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZmluID0gKGJ1ZlswXSAmIDB4ODApID09PSAweDgwO1xuICAgIHRoaXMuX29wY29kZSA9IGJ1ZlswXSAmIDB4MGY7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDB4N2Y7XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAwKSB7XG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ2ludmFsaWQgb3Bjb2RlIDAnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vcGNvZGUgPSB0aGlzLl9mcmFnbWVudGVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAxIHx8IHRoaXMuX29wY29kZSA9PT0gMHgwMikge1xuICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvbXByZXNzZWQgPSBjb21wcmVzc2VkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNyAmJiB0aGlzLl9vcGNvZGUgPCAweDBiKSB7XG4gICAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnRklOIG11c3QgYmUgc2V0JyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9GSU4nXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fcGF5bG9hZExlbmd0aCA+IDB4N2QgfHxcbiAgICAgICAgKHRoaXMuX29wY29kZSA9PT0gMHgwOCAmJiB0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIHBheWxvYWQgbGVuZ3RoICR7dGhpcy5fcGF5bG9hZExlbmd0aH1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfQ09OVFJPTF9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2ZpbiAmJiAhdGhpcy5fZnJhZ21lbnRlZCkgdGhpcy5fZnJhZ21lbnRlZCA9IHRoaXMuX29wY29kZTtcbiAgICB0aGlzLl9tYXNrZWQgPSAoYnVmWzFdICYgMHg4MCkgPT09IDB4ODA7XG5cbiAgICBpZiAodGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgIGlmICghdGhpcy5fbWFza2VkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdNQVNLIG11c3QgYmUgc2V0JyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9NQVNLJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fbWFza2VkKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdNQVNLIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfTUFTSydcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI2KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF8xNjtcbiAgICBlbHNlIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjcpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzY0O1xuICAgIGVsc2UgdGhpcy5oYXZlTGVuZ3RoKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzE2KS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGgxNihjYikge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSB0aGlzLmNvbnN1bWUoMikucmVhZFVJbnQxNkJFKDApO1xuICAgIHRoaXMuaGF2ZUxlbmd0aChjYik7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNys2NCkuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoNjQoY2IpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoOCk7XG4gICAgY29uc3QgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyIGluIEphdmFTY3JpcHQgaXMgMl41MyAtIDEuIEFuIGVycm9yIGlzIHJldHVybmVkXG4gICAgLy8gaWYgcGF5bG9hZCBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoaXMgbnVtYmVyLlxuICAgIC8vXG4gICAgaWYgKG51bSA+IE1hdGgucG93KDIsIDUzIC0gMzIpIC0gMSkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgV2ViU29ja2V0IGZyYW1lOiBwYXlsb2FkIGxlbmd0aCA+IDJeNTMgLSAxJyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIDEwMDksXG4gICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfREFUQV9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gbnVtICogTWF0aC5wb3coMiwgMzIpICsgYnVmLnJlYWRVSW50MzJCRSg0KTtcbiAgICB0aGlzLmhhdmVMZW5ndGgoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBheWxvYWQgbGVuZ3RoIGhhcyBiZWVuIHJlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXZlTGVuZ3RoKGNiKSB7XG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggJiYgdGhpcy5fb3Bjb2RlIDwgMHgwOCkge1xuICAgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoICs9IHRoaXMuX3BheWxvYWRMZW5ndGg7XG4gICAgICBpZiAodGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgMTAwOSxcbiAgICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9tYXNrZWQpIHRoaXMuX3N0YXRlID0gR0VUX01BU0s7XG4gICAgZWxzZSB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIG1hc2sgYnl0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNYXNrKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgNCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX21hc2sgPSB0aGlzLmNvbnN1bWUoNCk7XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBkYXRhIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RGF0YShjYikge1xuICAgIGxldCBkYXRhID0gRU1QVFlfQlVGRkVSO1xuXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgdGhpcy5fcGF5bG9hZExlbmd0aCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IHRoaXMuY29uc3VtZSh0aGlzLl9wYXlsb2FkTGVuZ3RoKTtcblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9tYXNrZWQgJiZcbiAgICAgICAgKHRoaXMuX21hc2tbMF0gfCB0aGlzLl9tYXNrWzFdIHwgdGhpcy5fbWFza1syXSB8IHRoaXMuX21hc2tbM10pICE9PSAwXG4gICAgICApIHtcbiAgICAgICAgdW5tYXNrKGRhdGEsIHRoaXMuX21hc2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPiAweDA3KSB7XG4gICAgICB0aGlzLmNvbnRyb2xNZXNzYWdlKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29tcHJlc3NlZCkge1xuICAgICAgdGhpcy5fc3RhdGUgPSBJTkZMQVRJTkc7XG4gICAgICB0aGlzLmRlY29tcHJlc3MoZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgbWVzc2FnZSBpcyBub3QgY29tcHJlc3NlZCBzbyBpdHMgbGVuZ3RoIGlzIHRoZSBzdW0gb2YgdGhlIHBheWxvYWRcbiAgICAgIC8vIGxlbmd0aCBvZiBhbGwgZnJhZ21lbnRzLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGg7XG4gICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChkYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFNZXNzYWdlKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuZGVjb21wcmVzcyhkYXRhLCB0aGlzLl9maW4sIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChidWYubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgMTAwOSxcbiAgICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChidWYpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRhdGFNZXNzYWdlKGNiKTtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gR0VUX0lORk8pIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGF0YU1lc3NhZ2UoY2IpIHtcbiAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlTGVuZ3RoID0gdGhpcy5fbWVzc2FnZUxlbmd0aDtcbiAgICBjb25zdCBmcmFnbWVudHMgPSB0aGlzLl9mcmFnbWVudHM7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMikge1xuICAgICAgbGV0IGRhdGE7XG5cbiAgICAgIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnbm9kZWJ1ZmZlcicpIHtcbiAgICAgICAgZGF0YSA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgQmxvYihmcmFnbWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IGZyYWdtZW50cztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEsIHRydWUpO1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYnVmID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG5cbiAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDA3LFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IElORkxBVElORyB8fCB0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1ZiwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBERUZFUl9FVkVOVDtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBidWYsIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBjb250cm9sIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gaGFuZGxlXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnRyb2xNZXNzYWdlKGRhdGEsIGNiKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIDEwMDUsIEVNUFRZX0JVRkZFUik7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDAyLFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NMT1NFX0NPREUnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWYgPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgICBkYXRhLmJ1ZmZlcixcbiAgICAgICAgICBkYXRhLmJ5dGVPZmZzZXQgKyAyLFxuICAgICAgICAgIGRhdGEubGVuZ3RoIC0gMlxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgRXJyb3IsXG4gICAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgMTAwNyxcbiAgICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgY29kZSwgYnVmKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYWxsb3dTeW5jaHJvbm91c0V2ZW50cykge1xuICAgICAgdGhpcy5lbWl0KHRoaXMuX29wY29kZSA9PT0gMHgwOSA/ICdwaW5nJyA6ICdwb25nJywgZGF0YSk7XG4gICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuX29wY29kZSA9PT0gMHgwOSA/ICdwaW5nJyA6ICdwb25nJywgZGF0YSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYW4gZXJyb3Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpFcnJvcnxSYW5nZUVycm9yKX0gRXJyb3JDdG9yIFRoZSBlcnJvciBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZpeCBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gYWRkIGEgZGVmYXVsdCBwcmVmaXggdG9cbiAgICogICAgIGBtZXNzYWdlYFxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzQ29kZSBUaGUgc3RhdHVzIGNvZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVycm9yQ29kZSBUaGUgZXhwb3NlZCBlcnJvciBjb2RlXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yKX0gVGhlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVFcnJvcihFcnJvckN0b3IsIG1lc3NhZ2UsIHByZWZpeCwgc3RhdHVzQ29kZSwgZXJyb3JDb2RlKSB7XG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vycm9yZWQgPSB0cnVlO1xuXG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yQ3RvcihcbiAgICAgIHByZWZpeCA/IGBJbnZhbGlkIFdlYlNvY2tldCBmcmFtZTogJHttZXNzYWdlfWAgOiBtZXNzYWdlXG4gICAgKTtcblxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgdGhpcy5jcmVhdGVFcnJvcik7XG4gICAgZXJyLmNvZGUgPSBlcnJvckNvZGU7XG4gICAgZXJyW2tTdGF0dXNDb2RlXSA9IHN0YXR1c0NvZGU7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xuIiwiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4XCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IHJhbmRvbUZpbGxTeW5jIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgeyBFTVBUWV9CVUZGRVIsIGtXZWJTb2NrZXQsIE5PT1AgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7IGlzQmxvYiwgaXNWYWxpZFN0YXR1c0NvZGUgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuY29uc3QgeyBtYXNrOiBhcHBseU1hc2ssIHRvQnVmZmVyIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5cbmNvbnN0IGtCeXRlTGVuZ3RoID0gU3ltYm9sKCdrQnl0ZUxlbmd0aCcpO1xuY29uc3QgbWFza0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbmNvbnN0IFJBTkRPTV9QT09MX1NJWkUgPSA4ICogMTAyNDtcbmxldCByYW5kb21Qb29sO1xubGV0IHJhbmRvbVBvb2xQb2ludGVyID0gUkFORE9NX1BPT0xfU0laRTtcblxuY29uc3QgREVGQVVMVCA9IDA7XG5jb25zdCBERUZMQVRJTkcgPSAxO1xuY29uc3QgR0VUX0JMT0JfREFUQSA9IDI7XG5cbi8qKlxuICogSHlCaSBTZW5kZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFNlbmRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU2VuZGVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBjb25uZWN0aW9uIHNvY2tldFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2V4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2dlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc29ja2V0LCBleHRlbnNpb25zLCBnZW5lcmF0ZU1hc2spIHtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcblxuICAgIGlmIChnZW5lcmF0ZU1hc2spIHtcbiAgICAgIHRoaXMuX2dlbmVyYXRlTWFzayA9IGdlbmVyYXRlTWFzaztcbiAgICAgIHRoaXMuX21hc2tCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgfVxuXG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG4gICAgdGhpcy5fY29tcHJlc3MgPSBmYWxzZTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xuICAgIHRoaXMub25lcnJvciA9IE5PT1A7XG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYSBwaWVjZSBvZiBkYXRhIGFjY29yZGluZyB0byB0aGUgSHlCaSBXZWJTb2NrZXQgcHJvdG9jb2wuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIFRoZSBkYXRhIHRvIGZyYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcmV0dXJuIHsoQnVmZmVyfFN0cmluZylbXX0gVGhlIGZyYW1lZCBkYXRhXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBmcmFtZShkYXRhLCBvcHRpb25zKSB7XG4gICAgbGV0IG1hc2s7XG4gICAgbGV0IG1lcmdlID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IDI7XG4gICAgbGV0IHNraXBNYXNraW5nID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5tYXNrKSB7XG4gICAgICBtYXNrID0gb3B0aW9ucy5tYXNrQnVmZmVyIHx8IG1hc2tCdWZmZXI7XG5cbiAgICAgIGlmIChvcHRpb25zLmdlbmVyYXRlTWFzaykge1xuICAgICAgICBvcHRpb25zLmdlbmVyYXRlTWFzayhtYXNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyYW5kb21Qb29sUG9pbnRlciA9PT0gUkFORE9NX1BPT0xfU0laRSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuICAgICAgICAgIGlmIChyYW5kb21Qb29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGxhemlseSBpbml0aWFsaXplZCBiZWNhdXNlIHNlcnZlci1zZW50IGZyYW1lcyBtdXN0IG5vdFxuICAgICAgICAgICAgLy8gYmUgbWFza2VkIHNvIGl0IG1heSBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHJhbmRvbVBvb2wgPSBCdWZmZXIuYWxsb2MoUkFORE9NX1BPT0xfU0laRSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmFuZG9tRmlsbFN5bmMocmFuZG9tUG9vbCwgMCwgUkFORE9NX1BPT0xfU0laRSk7XG4gICAgICAgICAgcmFuZG9tUG9vbFBvaW50ZXIgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFza1swXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XG4gICAgICAgIG1hc2tbMV0gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuICAgICAgICBtYXNrWzJdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcbiAgICAgICAgbWFza1szXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XG4gICAgICB9XG5cbiAgICAgIHNraXBNYXNraW5nID0gKG1hc2tbMF0gfCBtYXNrWzFdIHwgbWFza1syXSB8IG1hc2tbM10pID09PSAwO1xuICAgICAgb2Zmc2V0ID0gNjtcbiAgICB9XG5cbiAgICBsZXQgZGF0YUxlbmd0aDtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKCFvcHRpb25zLm1hc2sgfHwgc2tpcE1hc2tpbmcpICYmXG4gICAgICAgIG9wdGlvbnNba0J5dGVMZW5ndGhdICE9PSB1bmRlZmluZWRcbiAgICAgICkge1xuICAgICAgICBkYXRhTGVuZ3RoID0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgbWVyZ2UgPSBvcHRpb25zLm1hc2sgJiYgb3B0aW9ucy5yZWFkT25seSAmJiAhc2tpcE1hc2tpbmc7XG4gICAgfVxuXG4gICAgbGV0IHBheWxvYWRMZW5ndGggPSBkYXRhTGVuZ3RoO1xuXG4gICAgaWYgKGRhdGFMZW5ndGggPj0gNjU1MzYpIHtcbiAgICAgIG9mZnNldCArPSA4O1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNztcbiAgICB9IGVsc2UgaWYgKGRhdGFMZW5ndGggPiAxMjUpIHtcbiAgICAgIG9mZnNldCArPSAyO1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobWVyZ2UgPyBkYXRhTGVuZ3RoICsgb2Zmc2V0IDogb2Zmc2V0KTtcblxuICAgIHRhcmdldFswXSA9IG9wdGlvbnMuZmluID8gb3B0aW9ucy5vcGNvZGUgfCAweDgwIDogb3B0aW9ucy5vcGNvZGU7XG4gICAgaWYgKG9wdGlvbnMucnN2MSkgdGFyZ2V0WzBdIHw9IDB4NDA7XG5cbiAgICB0YXJnZXRbMV0gPSBwYXlsb2FkTGVuZ3RoO1xuXG4gICAgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNikge1xuICAgICAgdGFyZ2V0LndyaXRlVUludDE2QkUoZGF0YUxlbmd0aCwgMik7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjcpIHtcbiAgICAgIHRhcmdldFsyXSA9IHRhcmdldFszXSA9IDA7XG4gICAgICB0YXJnZXQud3JpdGVVSW50QkUoZGF0YUxlbmd0aCwgNCwgNik7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLm1hc2spIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcblxuICAgIHRhcmdldFsxXSB8PSAweDgwO1xuICAgIHRhcmdldFtvZmZzZXQgLSA0XSA9IG1hc2tbMF07XG4gICAgdGFyZ2V0W29mZnNldCAtIDNdID0gbWFza1sxXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMl0gPSBtYXNrWzJdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAxXSA9IG1hc2tbM107XG5cbiAgICBpZiAoc2tpcE1hc2tpbmcpIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcblxuICAgIGlmIChtZXJnZSkge1xuICAgICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIHRhcmdldCwgb2Zmc2V0LCBkYXRhTGVuZ3RoKTtcbiAgICAgIHJldHVybiBbdGFyZ2V0XTtcbiAgICB9XG5cbiAgICBhcHBseU1hc2soZGF0YSwgbWFzaywgZGF0YSwgMCwgZGF0YUxlbmd0aCk7XG4gICAgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgY2xvc2UgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBUaGUgc3RhdHVzIGNvZGUgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXIpfSBbZGF0YV0gVGhlIG1lc3NhZ2UgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIHRoZSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnVmO1xuXG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYnVmID0gRU1QVFlfQlVGRkVSO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInIHx8ICFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHZhbGlkIGVycm9yIGNvZGUgbnVtYmVyJyk7XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMik7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG5cbiAgICAgIGlmIChsZW5ndGggPiAxMjMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBtZXNzYWdlIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjMgYnl0ZXMnKTtcbiAgICAgIH1cblxuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIgKyBsZW5ndGgpO1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYnVmLndyaXRlKGRhdGEsIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmLnNldChkYXRhLCAyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnVmLmxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MDgsXG4gICAgICByZWFkT25seTogZmFsc2UsXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgYnVmLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwaW5nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnl0ZUxlbmd0aDtcbiAgICBsZXQgcmVhZE9ubHk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5zaXplO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlci5yZWFkT25seTtcbiAgICB9XG5cbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDEyNSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBkYXRhIHNpemUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyNSBieXRlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZTogMHgwOSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5nZXRCbG9iRGF0YSwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdldEJsb2JEYXRhKGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcG9uZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEuc2l6ZTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MGEsXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZ2V0QmxvYkRhdGEsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGRhdGEgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5hcnk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnlcbiAgICogICAgIG9yIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICBjb21wcmVzcyBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcbiAgICogICAgIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG4gICAgbGV0IG9wY29kZSA9IG9wdGlvbnMuYmluYXJ5ID8gMiA6IDE7XG4gICAgbGV0IHJzdjEgPSBvcHRpb25zLmNvbXByZXNzO1xuXG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEuc2l6ZTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZpcnN0RnJhZ21lbnQpIHtcbiAgICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSBmYWxzZTtcbiAgICAgIGlmIChcbiAgICAgICAgcnN2MSAmJlxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5wYXJhbXNbXG4gICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuX2lzU2VydmVyXG4gICAgICAgICAgICA/ICdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgICAgIDogJ2NsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyJ1xuICAgICAgICBdXG4gICAgICApIHtcbiAgICAgICAgcnN2MSA9IGJ5dGVMZW5ndGggPj0gcGVyTWVzc2FnZURlZmxhdGUuX3RocmVzaG9sZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbXByZXNzID0gcnN2MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnN2MSA9IGZhbHNlO1xuICAgICAgb3Bjb2RlID0gMDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5maW4pIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICBmaW46IG9wdGlvbnMuZmluLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlLFxuICAgICAgcmVhZE9ubHksXG4gICAgICByc3YxXG4gICAgfTtcblxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZ2V0QmxvYkRhdGEsIGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2goZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY29udGVudHMgb2YgYSBibG9iIGFzIGJpbmFyeSBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2IgVGhlIGJsb2JcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgdGhlIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcbiAgICogICAgIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEJsb2JEYXRhKGJsb2IsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfQkxPQl9EQVRBO1xuXG4gICAgYmxvYlxuICAgICAgLmFycmF5QnVmZmVyKClcbiAgICAgIC50aGVuKChhcnJheUJ1ZmZlcikgPT4ge1xuICAgICAgICBpZiAodGhpcy5fc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgc29ja2V0IHdhcyBjbG9zZWQgd2hpbGUgdGhlIGJsb2Igd2FzIGJlaW5nIHJlYWQnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gYGNhbGxDYWxsYmFja3NgIGlzIGNhbGxlZCBpbiB0aGUgbmV4dCB0aWNrIHRvIGVuc3VyZSB0aGF0IGVycm9yc1xuICAgICAgICAgIC8vIHRoYXQgbWlnaHQgYmUgdGhyb3duIGluIHRoZSBjYWxsYmFja3MgYmVoYXZlIGxpa2UgZXJyb3JzIHRocm93blxuICAgICAgICAgIC8vIG91dHNpZGUgdGhlIHByb21pc2UgY2hhaW4uXG4gICAgICAgICAgLy9cbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxDYWxsYmFja3MsIHRoaXMsIGVyciwgY2IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0b0J1ZmZlcihhcnJheUJ1ZmZlcik7XG5cbiAgICAgICAgaWYgKCFjb21wcmVzcykge1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gREVGQVVMVDtcbiAgICAgICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICAgICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoKGRhdGEsIGNvbXByZXNzLCBvcHRpb25zLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAvL1xuICAgICAgICAvLyBgb25FcnJvcmAgaXMgY2FsbGVkIGluIHRoZSBuZXh0IHRpY2sgZm9yIHRoZSBzYW1lIHJlYXNvbiB0aGF0XG4gICAgICAgIC8vIGBjYWxsQ2FsbGJhY2tzYCBhYm92ZSBpcy5cbiAgICAgICAgLy9cbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhvbkVycm9yLCB0aGlzLCBlcnIsIGNiKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGlzcGF0Y2goZGF0YSwgY29tcHJlc3MsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKCFjb21wcmVzcykge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICB0aGlzLl9zdGF0ZSA9IERFRkxBVElORztcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5jb21wcmVzcyhkYXRhLCBvcHRpb25zLmZpbiwgKF8sIGJ1ZikgPT4ge1xuICAgICAgaWYgKHRoaXMuX3NvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgc29ja2V0IHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgY29tcHJlc3NlZCdcbiAgICAgICAgKTtcblxuICAgICAgICBjYWxsQ2FsbGJhY2tzKHRoaXMsIGVyciwgY2IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgICB0aGlzLl9zdGF0ZSA9IERFRkFVTFQ7XG4gICAgICBvcHRpb25zLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xuICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgcXVldWVkIHNlbmQgb3BlcmF0aW9ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlcXVldWUoKSB7XG4gICAgd2hpbGUgKHRoaXMuX3N0YXRlID09PSBERUZBVUxUICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcblxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBwYXJhbXNbM11ba0J5dGVMZW5ndGhdO1xuICAgICAgUmVmbGVjdC5hcHBseShwYXJhbXNbMF0sIHRoaXMsIHBhcmFtcy5zbGljZSgxKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc2VuZCBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBTZW5kIG9wZXJhdGlvbiBwYXJhbWV0ZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW5xdWV1ZShwYXJhbXMpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IHBhcmFtc1szXVtrQnl0ZUxlbmd0aF07XG4gICAgdGhpcy5fcXVldWUucHVzaChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGZyYW1lIHRvIHNlbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2VuZEZyYW1lKGxpc3QsIGNiKSB7XG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aGlzLl9zb2NrZXQuY29yaygpO1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0pO1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMV0sIGNiKTtcbiAgICAgIHRoaXMuX3NvY2tldC51bmNvcmsoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0sIGNiKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXI7XG5cbi8qKlxuICogQ2FsbHMgcXVldWVkIGNhbGxiYWNrcyB3aXRoIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U2VuZGVyfSBzZW5kZXIgVGhlIGBTZW5kZXJgIGluc3RhbmNlXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yIHRvIGNhbGwgdGhlIGNhbGxiYWNrcyB3aXRoXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIFRoZSBmaXJzdCBjYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FsbENhbGxiYWNrcyhzZW5kZXIsIGVyciwgY2IpIHtcbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgY2IoZXJyKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbmRlci5fcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzZW5kZXIuX3F1ZXVlW2ldO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXTtcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVzIGEgYFNlbmRlcmAgZXJyb3IuXG4gKlxuICogQHBhcmFtIHtTZW5kZXJ9IHNlbmRlciBUaGUgYFNlbmRlcmAgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gVGhlIGZpcnN0IHBlbmRpbmcgY2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG9uRXJyb3Ioc2VuZGVyLCBlcnIsIGNiKSB7XG4gIGNhbGxDYWxsYmFja3Moc2VuZGVyLCBlcnIsIGNiKTtcbiAgc2VuZGVyLm9uZXJyb3IoZXJyKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBrRm9yT25FdmVudEF0dHJpYnV0ZSwga0xpc3RlbmVyIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBrQ29kZSA9IFN5bWJvbCgna0NvZGUnKTtcbmNvbnN0IGtEYXRhID0gU3ltYm9sKCdrRGF0YScpO1xuY29uc3Qga0Vycm9yID0gU3ltYm9sKCdrRXJyb3InKTtcbmNvbnN0IGtNZXNzYWdlID0gU3ltYm9sKCdrTWVzc2FnZScpO1xuY29uc3Qga1JlYXNvbiA9IFN5bWJvbCgna1JlYXNvbicpO1xuY29uc3Qga1RhcmdldCA9IFN5bWJvbCgna1RhcmdldCcpO1xuY29uc3Qga1R5cGUgPSBTeW1ib2woJ2tUeXBlJyk7XG5jb25zdCBrV2FzQ2xlYW4gPSBTeW1ib2woJ2tXYXNDbGVhbicpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBldmVudC5cbiAqL1xuY2xhc3MgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRoZSBgdHlwZWAgYXJndW1lbnQgaXMgbm90IHNwZWNpZmllZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHRoaXNba1RhcmdldF0gPSBudWxsO1xuICAgIHRoaXNba1R5cGVdID0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCB0YXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXNba1RhcmdldF07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzW2tUeXBlXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCAndGFyZ2V0JywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3R5cGUnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY2xvc2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgQ2xvc2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgQ2xvc2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvZGU9MF0gVGhlIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZVxuICAgKiAgICAgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZWFzb249JyddIEEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIGV4cGxhaW5pbmcgd2h5XG4gICAqICAgICB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2FzQ2xlYW49ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gd2FzIGNsZWFubHkgY2xvc2VkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0NvZGVdID0gb3B0aW9ucy5jb2RlID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5jb2RlO1xuICAgIHRoaXNba1JlYXNvbl0gPSBvcHRpb25zLnJlYXNvbiA9PT0gdW5kZWZpbmVkID8gJycgOiBvcHRpb25zLnJlYXNvbjtcbiAgICB0aGlzW2tXYXNDbGVhbl0gPSBvcHRpb25zLndhc0NsZWFuID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMud2FzQ2xlYW47XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjb2RlKCkge1xuICAgIHJldHVybiB0aGlzW2tDb2RlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpc1trUmVhc29uXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCB3YXNDbGVhbigpIHtcbiAgICByZXR1cm4gdGhpc1trV2FzQ2xlYW5dO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgJ2NvZGUnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdyZWFzb24nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICd3YXNDbGVhbicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXJyb3IgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgRXJyb3JFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXJyb3JFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5lcnJvcj1udWxsXSBUaGUgZXJyb3IgdGhhdCBnZW5lcmF0ZWQgdGhpcyBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZT0nJ10gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgdGhpc1trRXJyb3JdID0gb3B0aW9ucy5lcnJvciA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMuZXJyb3I7XG4gICAgdGhpc1trTWVzc2FnZV0gPSBvcHRpb25zLm1lc3NhZ2UgPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5tZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGVycm9yKCkge1xuICAgIHJldHVybiB0aGlzW2tFcnJvcl07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBtZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzW2tNZXNzYWdlXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdlcnJvcicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFcnJvckV2ZW50LnByb3RvdHlwZSwgJ21lc3NhZ2UnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbWVzc2FnZSBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICovXG5jbGFzcyBNZXNzYWdlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYE1lc3NhZ2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5kYXRhPW51bGxdIFRoZSBtZXNzYWdlIGNvbnRlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgdGhpc1trRGF0YV0gPSBvcHRpb25zLmRhdGEgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpc1trRGF0YV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2VFdmVudC5wcm90b3R5cGUsICdkYXRhJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIFRoaXMgcHJvdmlkZXMgbWV0aG9kcyBmb3IgZW11bGF0aW5nIHRoZSBgRXZlbnRUYXJnZXRgIGludGVyZmFjZS4gSXQncyBub3RcbiAqIG1lYW50IHRvIGJlIHVzZWQgZGlyZWN0bHkuXG4gKlxuICogQG1peGluXG4gKi9cbmNvbnN0IEV2ZW50VGFyZ2V0ID0ge1xuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yXG4gICAqIEBwYXJhbSB7KEZ1bmN0aW9ufE9iamVjdCl9IGhhbmRsZXIgVGhlIGxpc3RlbmVyIHRvIGFkZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXRcbiAgICogICAgIHRoZSBldmVudCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9uY2U9ZmFsc2VdIEEgYEJvb2xlYW5gIGluZGljYXRpbmcgdGhhdCB0aGVcbiAgICogICAgIGxpc3RlbmVyIHNob3VsZCBiZSBpbnZva2VkIGF0IG1vc3Qgb25jZSBhZnRlciBiZWluZyBhZGRlZC4gSWYgYHRydWVgLFxuICAgKiAgICAgdGhlIGxpc3RlbmVyIHdvdWxkIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCB3aGVuIGludm9rZWQuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyh0eXBlKSkge1xuICAgICAgaWYgKFxuICAgICAgICAhb3B0aW9uc1trRm9yT25FdmVudEF0dHJpYnV0ZV0gJiZcbiAgICAgICAgbGlzdGVuZXJba0xpc3RlbmVyXSA9PT0gaGFuZGxlciAmJlxuICAgICAgICAhbGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB3cmFwcGVyO1xuXG4gICAgaWYgKHR5cGUgPT09ICdtZXNzYWdlJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uTWVzc2FnZShkYXRhLCBpc0JpbmFyeSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBNZXNzYWdlRXZlbnQoJ21lc3NhZ2UnLCB7XG4gICAgICAgICAgZGF0YTogaXNCaW5hcnkgPyBkYXRhIDogZGF0YS50b1N0cmluZygpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2xvc2UnKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25DbG9zZShjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IENsb3NlRXZlbnQoJ2Nsb3NlJywge1xuICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgcmVhc29uOiBtZXNzYWdlLnRvU3RyaW5nKCksXG4gICAgICAgICAgd2FzQ2xlYW46IHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJiB0aGlzLl9jbG9zZUZyYW1lU2VudFxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXJyb3JFdmVudCgnZXJyb3InLCB7XG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29wZW4nKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25PcGVuKCkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnb3BlbicpO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3cmFwcGVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSA9ICEhb3B0aW9uc1trRm9yT25FdmVudEF0dHJpYnV0ZV07XG4gICAgd3JhcHBlcltrTGlzdGVuZXJdID0gaGFuZGxlcjtcblxuICAgIGlmIChvcHRpb25zLm9uY2UpIHtcbiAgICAgIHRoaXMub25jZSh0eXBlLCB3cmFwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbih0eXBlLCB3cmFwcGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIHJlbW92ZVxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyh0eXBlKSkge1xuICAgICAgaWYgKGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiYgIWxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2xvc2VFdmVudCxcbiAgRXJyb3JFdmVudCxcbiAgRXZlbnQsXG4gIEV2ZW50VGFyZ2V0LFxuICBNZXNzYWdlRXZlbnRcbn07XG5cbi8qKlxuICogQ2FsbCBhbiBldmVudCBsaXN0ZW5lclxuICpcbiAqIEBwYXJhbSB7KEZ1bmN0aW9ufE9iamVjdCl9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBjYWxsXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIHZhbHVlIHRvIHVzZSBhcyBgdGhpc2BgIHdoZW4gY2FsbGluZyB0aGUgbGlzdGVuZXJcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBwYXNzIHRvIHRoZSBsaXN0ZW5lclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FsbExpc3RlbmVyKGxpc3RlbmVyLCB0aGlzQXJnLCBldmVudCkge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0JyAmJiBsaXN0ZW5lci5oYW5kbGVFdmVudCkge1xuICAgIGxpc3RlbmVyLmhhbmRsZUV2ZW50LmNhbGwobGlzdGVuZXIsIGV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBsaXN0ZW5lci5jYWxsKHRoaXNBcmcsIGV2ZW50KTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG4vKipcbiAqIEFkZHMgYW4gb2ZmZXIgdG8gdGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIGEgcGFyYW1ldGVyIHRvIHRoZSBtYXAgb2ZcbiAqIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3QgVGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBleHRlbnNpb24gb3IgcGFyYW1ldGVyIG5hbWVcbiAqIEBwYXJhbSB7KE9iamVjdHxCb29sZWFufFN0cmluZyl9IGVsZW0gVGhlIGV4dGVuc2lvbiBwYXJhbWV0ZXJzIG9yIHRoZVxuICogICAgIHBhcmFtZXRlciB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVzaChkZXN0LCBuYW1lLCBlbGVtKSB7XG4gIGlmIChkZXN0W25hbWVdID09PSB1bmRlZmluZWQpIGRlc3RbbmFtZV0gPSBbZWxlbV07XG4gIGVsc2UgZGVzdFtuYW1lXS5wdXNoKGVsZW0pO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHBhcnNlZCBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcGFyc2UoaGVhZGVyKSB7XG4gIGNvbnN0IG9mZmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBsZXQgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gIGxldCBpc0VzY2FwaW5nID0gZmFsc2U7XG4gIGxldCBpblF1b3RlcyA9IGZhbHNlO1xuICBsZXQgZXh0ZW5zaW9uTmFtZTtcbiAgbGV0IHBhcmFtTmFtZTtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBjb2RlID0gLTE7XG4gIGxldCBlbmQgPSAtMTtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBpICE9PSAwICYmXG4gICAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuICAgICAgKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiAvKiAnOycgKi8gfHwgY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIG5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICBwdXNoKHBhcmFtcywgaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpLCB0cnVlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNkIC8qICc9JyAqLyAmJiBzdGFydCAhPT0gLTEgJiYgZW5kID09PSAtMSkge1xuICAgICAgICBwYXJhbU5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgdmFsdWUgb2YgYSBxdW90ZWQtc3RyaW5nIGFmdGVyIHVuZXNjYXBpbmcgbXVzdCBjb25mb3JtIHRvIHRoZVxuICAgICAgLy8gdG9rZW4gQUJORiwgc28gb25seSB0b2tlbiBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcbiAgICAgIC8vXG4gICAgICBpZiAoaXNFc2NhcGluZykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgZWxzZSBpZiAoIW11c3RVbmVzY2FwZSkgbXVzdFVuZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgaXNFc2NhcGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpblF1b3Rlcykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyIC8qICdcIicgKi8gJiYgc3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgaW5RdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NWMgLyogJ1xcJyAqLykge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgJiYgaGVhZGVyLmNoYXJDb2RlQXQoaSAtIDEpID09PSAweDNkKSB7XG4gICAgICAgIGluUXVvdGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQgIT09IC0xICYmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgICAgICAgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdmFsdWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgaW5RdW90ZXMgfHwgY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gIGNvbnN0IHRva2VuID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcHVzaChvZmZlcnMsIHRva2VuLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHVzaChwYXJhbXMsIHRva2VuLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdG9rZW4ucmVwbGFjZSgvXFxcXC9nLCAnJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbik7XG4gICAgfVxuICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICB9XG5cbiAgcmV0dXJuIG9mZmVycztcbn1cblxuLyoqXG4gKiBCdWlsZHMgdGhlIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciBmaWVsZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBUaGUgbWFwIG9mIGV4dGVuc2lvbnMgYW5kIHBhcmFtZXRlcnMgdG8gZm9ybWF0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gb2JqZWN0XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdChleHRlbnNpb25zKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhleHRlbnNpb25zKVxuICAgIC5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgbGV0IGNvbmZpZ3VyYXRpb25zID0gZXh0ZW5zaW9uc1tleHRlbnNpb25dO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZ3VyYXRpb25zKSkgY29uZmlndXJhdGlvbnMgPSBbY29uZmlndXJhdGlvbnNdO1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zXG4gICAgICAgIC5tYXAoKHBhcmFtcykgPT4ge1xuICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uXVxuICAgICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5tYXAoKGspID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gcGFyYW1zW2tdO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzXG4gICAgICAgICAgICAgICAgICAubWFwKCh2KSA9PiAodiA9PT0gdHJ1ZSA/IGsgOiBgJHtrfT0ke3Z9YCkpXG4gICAgICAgICAgICAgICAgICAuam9pbignOyAnKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbignLCAnKTtcbiAgICB9KVxuICAgIC5qb2luKCcsICcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZm9ybWF0LCBwYXJzZSB9O1xuIiwiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4fFJlYWRhYmxlJFwiLCBcImNhdWdodEVycm9yc1wiOiBcIm5vbmVcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuY29uc3QgdGxzID0gcmVxdWlyZSgndGxzJyk7XG5jb25zdCB7IHJhbmRvbUJ5dGVzLCBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IHsgRHVwbGV4LCBSZWFkYWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlcicpO1xuY29uc3QgU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXInKTtcbmNvbnN0IHsgaXNCbG9iIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAgR1VJRCxcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGUsXG4gIGtMaXN0ZW5lcixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXQsXG4gIE5PT1Bcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3Qge1xuICBFdmVudFRhcmdldDogeyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyIH1cbn0gPSByZXF1aXJlKCcuL2V2ZW50LXRhcmdldCcpO1xuY29uc3QgeyBmb3JtYXQsIHBhcnNlIH0gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgeyB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCBjbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG5jb25zdCBrQWJvcnRlZCA9IFN5bWJvbCgna0Fib3J0ZWQnKTtcbmNvbnN0IHByb3RvY29sVmVyc2lvbnMgPSBbOCwgMTNdO1xuY29uc3QgcmVhZHlTdGF0ZXMgPSBbJ0NPTk5FQ1RJTkcnLCAnT1BFTicsICdDTE9TSU5HJywgJ0NMT1NFRCddO1xuY29uc3Qgc3VicHJvdG9jb2xSZWdleCA9IC9eWyEjJCUmJyorXFwtLjAtOUEtWl5fYHxhLXp+XSskLztcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYFdlYlNvY2tldGAuXG4gICAqXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICAgKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW10pfSBbcHJvdG9jb2xzXSBUaGUgc3VicHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9jbG9zZUNvZGUgPSAxMDA2O1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VNZXNzYWdlID0gRU1QVFlfQlVGRkVSO1xuICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2Vycm9yRW1pdHRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wcm90b2NvbCA9ICcnO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgICB0aGlzLl9yZWNlaXZlciA9IG51bGw7XG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcbiAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuXG4gICAgaWYgKGFkZHJlc3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWRpcmVjdHMgPSAwO1xuXG4gICAgICBpZiAocHJvdG9jb2xzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHByb3RvY29scykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm90b2NvbHMgPT09ICdvYmplY3QnICYmIHByb3RvY29scyAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBwcm90b2NvbHM7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5pdEFzQ2xpZW50KHRoaXMsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2F1dG9Qb25nID0gb3B0aW9ucy5hdXRvUG9uZztcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9yIGhpc3RvcmljYWwgcmVhc29ucywgdGhlIGN1c3RvbSBcIm5vZGVidWZmZXJcIiB0eXBlIGlzIHVzZWQgYnkgdGhlIGRlZmF1bHRcbiAgICogaW5zdGVhZCBvZiBcImJsb2JcIi5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBiaW5hcnlUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9iaW5hcnlUeXBlO1xuICB9XG5cbiAgc2V0IGJpbmFyeVR5cGUodHlwZSkge1xuICAgIGlmICghQklOQVJZX1RZUEVTLmluY2x1ZGVzKHR5cGUpKSByZXR1cm47XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcblxuICAgIC8vXG4gICAgLy8gQWxsb3cgdG8gY2hhbmdlIGBiaW5hcnlUeXBlYCBvbiB0aGUgZmx5LlxuICAgIC8vXG4gICAgaWYgKHRoaXMuX3JlY2VpdmVyKSB0aGlzLl9yZWNlaXZlci5fYmluYXJ5VHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBidWZmZXJlZEFtb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkQW1vdW50O1xuXG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5sZW5ndGggKyB0aGlzLl9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBleHRlbnNpb25zKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9leHRlbnNpb25zKS5qb2luKCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNQYXVzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdXNlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25jbG9zZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25lcnJvcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25vcGVuKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBwcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2w7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByZWFkeVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIHRoZSBzb2NrZXQgYW5kIHRoZSBpbnRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0U29ja2V0KHNvY2tldCwgaGVhZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKHtcbiAgICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IG9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcbiAgICAgIGJpbmFyeVR5cGU6IHRoaXMuYmluYXJ5VHlwZSxcbiAgICAgIGV4dGVuc2lvbnM6IHRoaXMuX2V4dGVuc2lvbnMsXG4gICAgICBpc1NlcnZlcjogdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBtYXhQYXlsb2FkOiBvcHRpb25zLm1heFBheWxvYWQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IG9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG5cbiAgICBjb25zdCBzZW5kZXIgPSBuZXcgU2VuZGVyKHNvY2tldCwgdGhpcy5fZXh0ZW5zaW9ucywgb3B0aW9ucy5nZW5lcmF0ZU1hc2spO1xuXG4gICAgdGhpcy5fcmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICB0aGlzLl9zZW5kZXIgPSBzZW5kZXI7XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgcmVjZWl2ZXJba1dlYlNvY2tldF0gPSB0aGlzO1xuICAgIHNlbmRlcltrV2ViU29ja2V0XSA9IHRoaXM7XG4gICAgc29ja2V0W2tXZWJTb2NrZXRdID0gdGhpcztcblxuICAgIHJlY2VpdmVyLm9uKCdjb25jbHVkZScsIHJlY2VpdmVyT25Db25jbHVkZSk7XG4gICAgcmVjZWl2ZXIub24oJ2RyYWluJywgcmVjZWl2ZXJPbkRyYWluKTtcbiAgICByZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRXJyb3IpO1xuICAgIHJlY2VpdmVyLm9uKCdtZXNzYWdlJywgcmVjZWl2ZXJPbk1lc3NhZ2UpO1xuICAgIHJlY2VpdmVyLm9uKCdwaW5nJywgcmVjZWl2ZXJPblBpbmcpO1xuICAgIHJlY2VpdmVyLm9uKCdwb25nJywgcmVjZWl2ZXJPblBvbmcpO1xuXG4gICAgc2VuZGVyLm9uZXJyb3IgPSBzZW5kZXJPbkVycm9yO1xuXG4gICAgLy9cbiAgICAvLyBUaGVzZSBtZXRob2RzIG1heSBub3QgYmUgYXZhaWxhYmxlIGlmIGBzb2NrZXRgIGlzIGp1c3QgYSBgRHVwbGV4YC5cbiAgICAvL1xuICAgIGlmIChzb2NrZXQuc2V0VGltZW91dCkgc29ja2V0LnNldFRpbWVvdXQoMCk7XG4gICAgaWYgKHNvY2tldC5zZXROb0RlbGF5KSBzb2NrZXQuc2V0Tm9EZWxheSgpO1xuXG4gICAgaWYgKGhlYWQubGVuZ3RoID4gMCkgc29ja2V0LnVuc2hpZnQoaGVhZCk7XG5cbiAgICBzb2NrZXQub24oJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XG4gICAgc29ja2V0Lm9uKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgICBzb2NrZXQub24oJ2VuZCcsIHNvY2tldE9uRW5kKTtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0Lk9QRU47XG4gICAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCB0aGUgYCdjbG9zZSdgIGV2ZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW1pdENsb3NlKCkge1xuICAgIGlmICghdGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0uY2xlYW51cCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSBjbG9zaW5nIGhhbmRzaGFrZS5cbiAgICpcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tK1xuICAgKiAgICAgLSAtIC18d3MuY2xvc2UoKXwtLT58Y2xvc2UgZnJhbWV8LS0+fHdzLmNsb3NlKCl8LSAtIC1cbiAgICogICAgfCAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tKyAgICAgfFxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgICAgICAgfFxuICAgKiBDTE9TSU5HICB8d3MuY2xvc2UoKXw8LS18Y2xvc2UgZnJhbWV8PC0tKy0tLS0tKyAgICAgICBDTE9TSU5HXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICB8XG4gICAqICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLSsgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLT58ZmlufCAtIC0gLSAtXG4gICAqICAgIHwgICAgICAgICArLS0tKyAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLStcbiAgICogICAgIC0gLSAtIC0gLXxmaW58PC0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICogICAgICAgICAgICAgICstLS0rXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gU3RhdHVzIGNvZGUgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSByZWFzb24gd2h5IHRoZSBjb25uZWN0aW9uIGlzXG4gICAqICAgICBjbG9zaW5nXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcbiAgICAgIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0lORykge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCAmJlxuICAgICAgICAodGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8IHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZClcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5fc2VuZGVyLmNsb3NlKGNvZGUsIGRhdGEsICF0aGlzLl9pc1NlcnZlciwgKGVycikgPT4ge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgaGFuZGxlZCBieSB0aGUgYCdlcnJvcidgIGxpc3RlbmVyIG9uIHRoZSBzb2NrZXQuIFdlIG9ubHlcbiAgICAgIC8vIHdhbnQgdG8ga25vdyBpZiB0aGUgY2xvc2UgZnJhbWUgaGFzIGJlZW4gc2VudCBoZXJlLlxuICAgICAgLy9cbiAgICAgIGlmIChlcnIpIHJldHVybjtcblxuICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSB0cnVlO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fFxuICAgICAgICB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWRcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzZXRDbG9zZVRpbWVyKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBhdXNlKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5fc29ja2V0LnBhdXNlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcGluZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucGluZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwb25nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBvbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBvbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVzdW1lKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSB0aGlzLl9zb2NrZXQucmVzdW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeSBvclxuICAgKiAgICAgdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj10cnVlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2tdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gZGF0YSBpcyB3cml0dGVuIG91dFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIGJpbmFyeTogdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnLFxuICAgICAgbWFzazogIXRoaXMuX2lzU2VydmVyLFxuICAgICAgY29tcHJlc3M6IHRydWUsXG4gICAgICBmaW46IHRydWUsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGlmICghdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3NlbmRlci5zZW5kKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBvcHRzLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2libHkgY2xvc2UgdGhlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRlcm1pbmF0ZSgpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcbiAgICAgIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuW1xuICAnYmluYXJ5VHlwZScsXG4gICdidWZmZXJlZEFtb3VudCcsXG4gICdleHRlbnNpb25zJyxcbiAgJ2lzUGF1c2VkJyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3JlYWR5U3RhdGUnLFxuICAndXJsJ1xuXS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn0pO1xuXG4vL1xuLy8gQWRkIHRoZSBgb25vcGVuYCwgYG9uZXJyb3JgLCBgb25jbG9zZWAsIGFuZCBgb25tZXNzYWdlYCBhdHRyaWJ1dGVzLlxuLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjdGhlLXdlYnNvY2tldC1pbnRlcmZhY2Vcbi8vXG5bJ29wZW4nLCAnZXJyb3InLCAnY2xvc2UnLCAnbWVzc2FnZSddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgYG9uJHttZXRob2R9YCwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHJldHVybiBsaXN0ZW5lcltrTGlzdGVuZXJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNldChoYW5kbGVyKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihtZXRob2QsIGhhbmRsZXIsIHtcbiAgICAgICAgW2tGb3JPbkV2ZW50QXR0cmlidXRlXTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5XZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuV2ViU29ja2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIFdlYlNvY2tldCBjbGllbnQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgY2xpZW50IHRvIGluaXRpYWxpemVcbiAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICogQHBhcmFtIHtBcnJheX0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgYW55XG4gKiAgICAgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZCBtdWx0aXBsZVxuICogICAgIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b1Bvbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gKiAgICAgYXV0b21hdGljYWxseSBzZW5kIGEgcG9uZyBpbiByZXNwb25zZSB0byBhIHBpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmZpbmlzaFJlcXVlc3RdIEEgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIHVzZWQgdG9cbiAqICAgICBjdXN0b21pemUgdGhlIGhlYWRlcnMgb2YgZWFjaCBodHRwIHJlcXVlc3QgYmVmb3JlIGl0IGlzIHNlbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZm9sbG93UmVkaXJlY3RzPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byBmb2xsb3dcbiAqICAgICByZWRpcmVjdHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gKiAgICAgbWFza2luZyBrZXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oYW5kc2hha2VUaW1lb3V0XSBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlXG4gKiAgICAgaGFuZHNoYWtlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXG4gKiAgICAgc2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFJlZGlyZWN0cz0xMF0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlZGlyZWN0c1xuICogICAgIGFsbG93ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5vcmlnaW5dIFZhbHVlIG9mIHRoZSBgT3JpZ2luYCBvclxuICogICAgIGBTZWMtV2ViU29ja2V0LU9yaWdpbmAgaGVhZGVyXG4gKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IFtvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlPXRydWVdIEVuYWJsZS9kaXNhYmxlXG4gKiAgICAgcGVybWVzc2FnZS1kZWZsYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJvdG9jb2xWZXJzaW9uPTEzXSBWYWx1ZSBvZiB0aGVcbiAqICAgICBgU2VjLVdlYlNvY2tldC1WZXJzaW9uYCBoZWFkZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0cnVlLFxuICAgIGF1dG9Qb25nOiB0cnVlLFxuICAgIHByb3RvY29sVmVyc2lvbjogcHJvdG9jb2xWZXJzaW9uc1sxXSxcbiAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0cnVlLFxuICAgIGZvbGxvd1JlZGlyZWN0czogZmFsc2UsXG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcbiAgICAuLi5vcHRpb25zLFxuICAgIHNvY2tldFBhdGg6IHVuZGVmaW5lZCxcbiAgICBob3N0bmFtZTogdW5kZWZpbmVkLFxuICAgIHByb3RvY29sOiB1bmRlZmluZWQsXG4gICAgdGltZW91dDogdW5kZWZpbmVkLFxuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgaG9zdDogdW5kZWZpbmVkLFxuICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICBwb3J0OiB1bmRlZmluZWRcbiAgfTtcblxuICB3ZWJzb2NrZXQuX2F1dG9Qb25nID0gb3B0cy5hdXRvUG9uZztcblxuICBpZiAoIXByb3RvY29sVmVyc2lvbnMuaW5jbHVkZXMob3B0cy5wcm90b2NvbFZlcnNpb24pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICBgVW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbjogJHtvcHRzLnByb3RvY29sVmVyc2lvbn0gYCArXG4gICAgICAgIGAoc3VwcG9ydGVkIHZlcnNpb25zOiAke3Byb3RvY29sVmVyc2lvbnMuam9pbignLCAnKX0pYFxuICAgICk7XG4gIH1cblxuICBsZXQgcGFyc2VkVXJsO1xuXG4gIGlmIChhZGRyZXNzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgcGFyc2VkVXJsID0gYWRkcmVzcztcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkVXJsID0gbmV3IFVSTChhZGRyZXNzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgVVJMOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9ICd3czonO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICBwYXJzZWRVcmwucHJvdG9jb2wgPSAnd3NzOic7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3VybCA9IHBhcnNlZFVybC5ocmVmO1xuXG4gIGNvbnN0IGlzU2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3NzOic7XG4gIGNvbnN0IGlzSXBjVXJsID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3MrdW5peDonO1xuICBsZXQgaW52YWxpZFVybE1lc3NhZ2U7XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ3dzOicgJiYgIWlzU2VjdXJlICYmICFpc0lwY1VybCkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID1cbiAgICAgICdUaGUgVVJMXFwncyBwcm90b2NvbCBtdXN0IGJlIG9uZSBvZiBcIndzOlwiLCBcIndzczpcIiwgJyArXG4gICAgICAnXCJodHRwOlwiLCBcImh0dHBzXCIsIG9yIFwid3MrdW5peDpcIic7XG4gIH0gZWxzZSBpZiAoaXNJcGNVcmwgJiYgIXBhcnNlZFVybC5wYXRobmFtZSkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID0gXCJUaGUgVVJMJ3MgcGF0aG5hbWUgaXMgZW1wdHlcIjtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaGFzaCkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID0gJ1RoZSBVUkwgY29udGFpbnMgYSBmcmFnbWVudCBpZGVudGlmaWVyJztcbiAgfVxuXG4gIGlmIChpbnZhbGlkVXJsTWVzc2FnZSkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihpbnZhbGlkVXJsTWVzc2FnZSk7XG5cbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRQb3J0ID0gaXNTZWN1cmUgPyA0NDMgOiA4MDtcbiAgY29uc3Qga2V5ID0gcmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgY29uc3QgcmVxdWVzdCA9IGlzU2VjdXJlID8gaHR0cHMucmVxdWVzdCA6IGh0dHAucmVxdWVzdDtcbiAgY29uc3QgcHJvdG9jb2xTZXQgPSBuZXcgU2V0KCk7XG4gIGxldCBwZXJNZXNzYWdlRGVmbGF0ZTtcblxuICBvcHRzLmNyZWF0ZUNvbm5lY3Rpb24gPVxuICAgIG9wdHMuY3JlYXRlQ29ubmVjdGlvbiB8fCAoaXNTZWN1cmUgPyB0bHNDb25uZWN0IDogbmV0Q29ubmVjdCk7XG4gIG9wdHMuZGVmYXVsdFBvcnQgPSBvcHRzLmRlZmF1bHRQb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRzLnBvcnQgPSBwYXJzZWRVcmwucG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5ob3N0ID0gcGFyc2VkVXJsLmhvc3RuYW1lLnN0YXJ0c1dpdGgoJ1snKVxuICAgID8gcGFyc2VkVXJsLmhvc3RuYW1lLnNsaWNlKDEsIC0xKVxuICAgIDogcGFyc2VkVXJsLmhvc3RuYW1lO1xuICBvcHRzLmhlYWRlcnMgPSB7XG4gICAgLi4ub3B0cy5oZWFkZXJzLFxuICAgICdTZWMtV2ViU29ja2V0LVZlcnNpb24nOiBvcHRzLnByb3RvY29sVmVyc2lvbixcbiAgICAnU2VjLVdlYlNvY2tldC1LZXknOiBrZXksXG4gICAgQ29ubmVjdGlvbjogJ1VwZ3JhZGUnLFxuICAgIFVwZ3JhZGU6ICd3ZWJzb2NrZXQnXG4gIH07XG4gIG9wdHMucGF0aCA9IHBhcnNlZFVybC5wYXRobmFtZSArIHBhcnNlZFVybC5zZWFyY2g7XG4gIG9wdHMudGltZW91dCA9IG9wdHMuaGFuZHNoYWtlVGltZW91dDtcblxuICBpZiAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSAhPT0gdHJ1ZSA/IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgOiB7fSxcbiAgICAgIGZhbHNlLFxuICAgICAgb3B0cy5tYXhQYXlsb2FkXG4gICAgKTtcbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyddID0gZm9ybWF0KHtcbiAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogcGVyTWVzc2FnZURlZmxhdGUub2ZmZXIoKVxuICAgIH0pO1xuICB9XG4gIGlmIChwcm90b2NvbHMubGVuZ3RoKSB7XG4gICAgZm9yIChjb25zdCBwcm90b2NvbCBvZiBwcm90b2NvbHMpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHByb3RvY29sICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhc3VicHJvdG9jb2xSZWdleC50ZXN0KHByb3RvY29sKSB8fFxuICAgICAgICBwcm90b2NvbFNldC5oYXMocHJvdG9jb2wpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgICdBbiBpbnZhbGlkIG9yIGR1cGxpY2F0ZWQgc3VicHJvdG9jb2wgd2FzIHNwZWNpZmllZCdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcHJvdG9jb2xTZXQuYWRkKHByb3RvY29sKTtcbiAgICB9XG5cbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnXSA9IHByb3RvY29scy5qb2luKCcsJyk7XG4gIH1cbiAgaWYgKG9wdHMub3JpZ2luKSB7XG4gICAgaWYgKG9wdHMucHJvdG9jb2xWZXJzaW9uIDwgMTMpIHtcbiAgICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1PcmlnaW4nXSA9IG9wdHMub3JpZ2luO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzLmhlYWRlcnMuT3JpZ2luID0gb3B0cy5vcmlnaW47XG4gICAgfVxuICB9XG4gIGlmIChwYXJzZWRVcmwudXNlcm5hbWUgfHwgcGFyc2VkVXJsLnBhc3N3b3JkKSB7XG4gICAgb3B0cy5hdXRoID0gYCR7cGFyc2VkVXJsLnVzZXJuYW1lfToke3BhcnNlZFVybC5wYXNzd29yZH1gO1xuICB9XG5cbiAgaWYgKGlzSXBjVXJsKSB7XG4gICAgY29uc3QgcGFydHMgPSBvcHRzLnBhdGguc3BsaXQoJzonKTtcblxuICAgIG9wdHMuc29ja2V0UGF0aCA9IHBhcnRzWzBdO1xuICAgIG9wdHMucGF0aCA9IHBhcnRzWzFdO1xuICB9XG5cbiAgbGV0IHJlcTtcblxuICBpZiAob3B0cy5mb2xsb3dSZWRpcmVjdHMpIHtcbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxJcGMgPSBpc0lwY1VybDtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxTZWN1cmUgPSBpc1NlY3VyZTtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoID0gaXNJcGNVcmxcbiAgICAgICAgPyBvcHRzLnNvY2tldFBhdGhcbiAgICAgICAgOiBwYXJzZWRVcmwuaG9zdDtcblxuICAgICAgY29uc3QgaGVhZGVycyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5oZWFkZXJzO1xuXG4gICAgICAvL1xuICAgICAgLy8gU2hhbGxvdyBjb3B5IHRoZSB1c2VyIHByb3ZpZGVkIG9wdGlvbnMgc28gdGhhdCBoZWFkZXJzIGNhbiBiZSBjaGFuZ2VkXG4gICAgICAvLyB3aXRob3V0IG11dGF0aW5nIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAvL1xuICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgaGVhZGVyczoge30gfTtcblxuICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgICAgICBvcHRpb25zLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHdlYnNvY2tldC5saXN0ZW5lckNvdW50KCdyZWRpcmVjdCcpID09PSAwKSB7XG4gICAgICBjb25zdCBpc1NhbWVIb3N0ID0gaXNJcGNVcmxcbiAgICAgICAgPyB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjXG4gICAgICAgICAgPyBvcHRzLnNvY2tldFBhdGggPT09IHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoXG4gICAgICAgICAgOiBmYWxzZVxuICAgICAgICA6IHdlYnNvY2tldC5fb3JpZ2luYWxJcGNcbiAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgOiBwYXJzZWRVcmwuaG9zdCA9PT0gd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGg7XG5cbiAgICAgIGlmICghaXNTYW1lSG9zdCB8fCAod2Vic29ja2V0Ll9vcmlnaW5hbFNlY3VyZSAmJiAhaXNTZWN1cmUpKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIE1hdGNoIGN1cmwgNy43Ny4wIGJlaGF2aW9yIGFuZCBkcm9wIHRoZSBmb2xsb3dpbmcgaGVhZGVycy4gVGhlc2VcbiAgICAgICAgLy8gaGVhZGVycyBhcmUgYWxzbyBkcm9wcGVkIHdoZW4gZm9sbG93aW5nIGEgcmVkaXJlY3QgdG8gYSBzdWJkb21haW4uXG4gICAgICAgIC8vXG4gICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuYXV0aG9yaXphdGlvbjtcbiAgICAgICAgZGVsZXRlIG9wdHMuaGVhZGVycy5jb29raWU7XG5cbiAgICAgICAgaWYgKCFpc1NhbWVIb3N0KSBkZWxldGUgb3B0cy5oZWFkZXJzLmhvc3Q7XG5cbiAgICAgICAgb3B0cy5hdXRoID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gTWF0Y2ggY3VybCA3Ljc3LjAgYmVoYXZpb3IgYW5kIG1ha2UgdGhlIGZpcnN0IGBBdXRob3JpemF0aW9uYCBoZWFkZXIgd2luLlxuICAgIC8vIElmIHRoZSBgQXV0aG9yaXphdGlvbmAgaGVhZGVyIGlzIHNldCwgdGhlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGRvIGFzIGl0XG4gICAgLy8gd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gICAgLy9cbiAgICBpZiAob3B0cy5hdXRoICYmICFvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbikge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24gPVxuICAgICAgICAnQmFzaWMgJyArIEJ1ZmZlci5mcm9tKG9wdHMuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH1cblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gcmVxdWVzdChvcHRzKTtcblxuICAgIGlmICh3ZWJzb2NrZXQuX3JlZGlyZWN0cykge1xuICAgICAgLy9cbiAgICAgIC8vIFVubGlrZSB3aGF0IGlzIGRvbmUgZm9yIHRoZSBgJ3VwZ3JhZGUnYCBldmVudCwgbm8gZWFybHkgZXhpdCBpc1xuICAgICAgLy8gdHJpZ2dlcmVkIGhlcmUgaWYgdGhlIHVzZXIgY2FsbHMgYHdlYnNvY2tldC5jbG9zZSgpYCBvclxuICAgICAgLy8gYHdlYnNvY2tldC50ZXJtaW5hdGUoKWAgZnJvbSBhIGxpc3RlbmVyIG9mIHRoZSBgJ3JlZGlyZWN0J2AgZXZlbnQuIFRoaXNcbiAgICAgIC8vIGlzIGJlY2F1c2UgdGhlIHVzZXIgY2FuIGFsc28gY2FsbCBgcmVxdWVzdC5kZXN0cm95KClgIHdpdGggYW4gZXJyb3JcbiAgICAgIC8vIGJlZm9yZSBjYWxsaW5nIGB3ZWJzb2NrZXQuY2xvc2UoKWAgb3IgYHdlYnNvY2tldC50ZXJtaW5hdGUoKWAgYW5kIHRoaXNcbiAgICAgIC8vIHdvdWxkIHJlc3VsdCBpbiBhbiBlcnJvciBiZWluZyBlbWl0dGVkIG9uIHRoZSBgcmVxdWVzdGAgb2JqZWN0IHdpdGggbm9cbiAgICAgIC8vIGAnZXJyb3InYCBldmVudCBsaXN0ZW5lcnMgYXR0YWNoZWQuXG4gICAgICAvL1xuICAgICAgd2Vic29ja2V0LmVtaXQoJ3JlZGlyZWN0Jywgd2Vic29ja2V0LnVybCwgcmVxKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSByZXF1ZXN0KG9wdHMpO1xuICB9XG5cbiAgaWYgKG9wdHMudGltZW91dCkge1xuICAgIHJlcS5vbigndGltZW91dCcsICgpID0+IHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnT3BlbmluZyBoYW5kc2hha2UgaGFzIHRpbWVkIG91dCcpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVxLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICBpZiAocmVxID09PSBudWxsIHx8IHJlcVtrQWJvcnRlZF0pIHJldHVybjtcblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcbiAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG4gIH0pO1xuXG4gIHJlcS5vbigncmVzcG9uc2UnLCAocmVzKSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSByZXMuaGVhZGVycy5sb2NhdGlvbjtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XG5cbiAgICBpZiAoXG4gICAgICBsb2NhdGlvbiAmJlxuICAgICAgb3B0cy5mb2xsb3dSZWRpcmVjdHMgJiZcbiAgICAgIHN0YXR1c0NvZGUgPj0gMzAwICYmXG4gICAgICBzdGF0dXNDb2RlIDwgNDAwXG4gICAgKSB7XG4gICAgICBpZiAoKyt3ZWJzb2NrZXQuX3JlZGlyZWN0cyA+IG9wdHMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnTWF4aW11bSByZWRpcmVjdHMgZXhjZWVkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXEuYWJvcnQoKTtcblxuICAgICAgbGV0IGFkZHI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGFkZHIgPSBuZXcgVVJMKGxvY2F0aW9uLCBhZGRyZXNzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIFVSTDogJHtsb2NhdGlvbn1gKTtcbiAgICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHIsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICghd2Vic29ja2V0LmVtaXQoJ3VuZXhwZWN0ZWQtcmVzcG9uc2UnLCByZXEsIHJlcykpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKFxuICAgICAgICB3ZWJzb2NrZXQsXG4gICAgICAgIHJlcSxcbiAgICAgICAgYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlOiAke3Jlcy5zdGF0dXNDb2RlfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICByZXEub24oJ3VwZ3JhZGUnLCAocmVzLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICB3ZWJzb2NrZXQuZW1pdCgndXBncmFkZScsIHJlcyk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSB1c2VyIG1heSBoYXZlIGNsb3NlZCB0aGUgY29ubmVjdGlvbiBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlXG4gICAgLy8gYCd1cGdyYWRlJ2AgZXZlbnQuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG5cbiAgICBjb25zdCB1cGdyYWRlID0gcmVzLmhlYWRlcnMudXBncmFkZTtcblxuICAgIGlmICh1cGdyYWRlID09PSB1bmRlZmluZWQgfHwgdXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFVwZ3JhZGUgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGlmIChyZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSAhPT0gZGlnZXN0KSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyUHJvdCA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgbGV0IHByb3RFcnJvcjtcblxuICAgIGlmIChzZXJ2ZXJQcm90ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghcHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYSBzdWJwcm90b2NvbCBidXQgbm9uZSB3YXMgcmVxdWVzdGVkJztcbiAgICAgIH0gZWxzZSBpZiAoIXByb3RvY29sU2V0LmhhcyhzZXJ2ZXJQcm90KSkge1xuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYW4gaW52YWxpZCBzdWJwcm90b2NvbCc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm90b2NvbFNldC5zaXplKSB7XG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgbm8gc3VicHJvdG9jb2wnO1xuICAgIH1cblxuICAgIGlmIChwcm90RXJyb3IpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBwcm90RXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZXJ2ZXJQcm90KSB3ZWJzb2NrZXQuX3Byb3RvY29sID0gc2VydmVyUHJvdDtcblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG5cbiAgICBpZiAoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICdTZXJ2ZXIgc2VudCBhIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXIgYnV0IG5vIGV4dGVuc2lvbiAnICtcbiAgICAgICAgICAnd2FzIHJlcXVlc3RlZCc7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZXh0ZW5zaW9ucztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZXh0ZW5zaW9ucyA9IHBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4dGVuc2lvbk5hbWVzID0gT2JqZWN0LmtleXMoZXh0ZW5zaW9ucyk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgZXh0ZW5zaW9uTmFtZXMubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgIGV4dGVuc2lvbk5hbWVzWzBdICE9PSBQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdTZXJ2ZXIgaW5kaWNhdGVkIGFuIGV4dGVuc2lvbiB0aGF0IHdhcyBub3QgcmVxdWVzdGVkJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3ZWJzb2NrZXQuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPVxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQuc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogb3B0cy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzLFxuICAgICAgZ2VuZXJhdGVNYXNrOiBvcHRzLmdlbmVyYXRlTWFzayxcbiAgICAgIG1heFBheWxvYWQ6IG9wdHMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0cy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKG9wdHMuZmluaXNoUmVxdWVzdCkge1xuICAgIG9wdHMuZmluaXNoUmVxdWVzdChyZXEsIHdlYnNvY2tldCk7XG4gIH0gZWxzZSB7XG4gICAgcmVxLmVuZCgpO1xuICB9XG59XG5cbi8qKlxuICogRW1pdCB0aGUgYCdlcnJvcidgIGFuZCBgJ2Nsb3NlJ2AgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gVGhlIGVycm9yIHRvIGVtaXRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGFzc2lnbm1lbnQgaXMgcHJhY3RpY2FsbHkgdXNlbGVzcyBhbmQgaXMgZG9uZSBvbmx5IGZvclxuICAvLyBjb25zaXN0ZW5jeS5cbiAgLy9cbiAgd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYG5ldC5Tb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtuZXQuU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbmV0Q29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IG9wdGlvbnMuc29ja2V0UGF0aDtcbiAgcmV0dXJuIG5ldC5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGB0bHMuVExTU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7dGxzLlRMU1NvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRsc0Nvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCFvcHRpb25zLnNlcnZlcm5hbWUgJiYgb3B0aW9ucy5zZXJ2ZXJuYW1lICE9PSAnJykge1xuICAgIG9wdGlvbnMuc2VydmVybmFtZSA9IG5ldC5pc0lQKG9wdGlvbnMuaG9zdCkgPyAnJyA6IG9wdGlvbnMuaG9zdDtcbiAgfVxuXG4gIHJldHVybiB0bHMuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBBYm9ydCB0aGUgaGFuZHNoYWtlIGFuZCBlbWl0IGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsoaHR0cC5DbGllbnRSZXF1ZXN0fG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHN0cmVhbSBUaGUgcmVxdWVzdCB0b1xuICogICAgIGFib3J0IG9yIHRoZSBzb2NrZXQgdG8gZGVzdHJveVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc3RyZWFtLCBtZXNzYWdlKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZSk7XG5cbiAgaWYgKHN0cmVhbS5zZXRIZWFkZXIpIHtcbiAgICBzdHJlYW1ba0Fib3J0ZWRdID0gdHJ1ZTtcbiAgICBzdHJlYW0uYWJvcnQoKTtcblxuICAgIGlmIChzdHJlYW0uc29ja2V0ICYmICFzdHJlYW0uc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgLy9cbiAgICAgIC8vIE9uIE5vZGUuanMgPj0gMTQuMy4wIGByZXF1ZXN0LmFib3J0KClgIGRvZXMgbm90IGRlc3Ryb3kgdGhlIHNvY2tldCBpZlxuICAgICAgLy8gY2FsbGVkIGFmdGVyIHRoZSByZXF1ZXN0IGNvbXBsZXRlZC4gU2VlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTg2OS5cbiAgICAgIC8vXG4gICAgICBzdHJlYW0uc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlLCB3ZWJzb2NrZXQsIGVycik7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKTtcbiAgICBzdHJlYW0ub25jZSgnZXJyb3InLCB3ZWJzb2NrZXQuZW1pdC5iaW5kKHdlYnNvY2tldCwgJ2Vycm9yJykpO1xuICAgIHN0cmVhbS5vbmNlKCdjbG9zZScsIHdlYnNvY2tldC5lbWl0Q2xvc2UuYmluZCh3ZWJzb2NrZXQpKTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBjYXNlcyB3aGVyZSB0aGUgYHBpbmcoKWAsIGBwb25nKClgLCBvciBgc2VuZCgpYCBtZXRob2RzIGFyZSBjYWxsZWRcbiAqIHdoZW4gdGhlIGByZWFkeVN0YXRlYCBhdHRyaWJ1dGUgaXMgYENMT1NJTkdgIG9yIGBDTE9TRURgLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2VuZEFmdGVyQ2xvc2Uod2Vic29ja2V0LCBkYXRhLCBjYikge1xuICBpZiAoZGF0YSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGlzQmxvYihkYXRhKSA/IGRhdGEuc2l6ZSA6IHRvQnVmZmVyKGRhdGEpLmxlbmd0aDtcblxuICAgIC8vXG4gICAgLy8gVGhlIGBfYnVmZmVyZWRBbW91bnRgIHByb3BlcnR5IGlzIHVzZWQgb25seSB3aGVuIHRoZSBwZWVyIGlzIGEgY2xpZW50IGFuZFxuICAgIC8vIHRoZSBvcGVuaW5nIGhhbmRzaGFrZSBmYWlscy4gVW5kZXIgdGhlc2UgY2lyY3Vtc3RhbmNlcywgaW4gZmFjdCwgdGhlXG4gICAgLy8gYHNldFNvY2tldCgpYCBtZXRob2QgaXMgbm90IGNhbGxlZCwgc28gdGhlIGBfc29ja2V0YCBhbmQgYF9zZW5kZXJgXG4gICAgLy8gcHJvcGVydGllcyBhcmUgc2V0IHRvIGBudWxsYC5cbiAgICAvL1xuICAgIGlmICh3ZWJzb2NrZXQuX3NvY2tldCkgd2Vic29ja2V0Ll9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXMgKz0gbGVuZ3RoO1xuICAgIGVsc2Ugd2Vic29ja2V0Ll9idWZmZXJlZEFtb3VudCArPSBsZW5ndGg7XG4gIH1cblxuICBpZiAoY2IpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICBgV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlICR7d2Vic29ja2V0LnJlYWR5U3RhdGV9IGAgK1xuICAgICAgICBgKCR7cmVhZHlTdGF0ZXNbd2Vic29ja2V0LnJlYWR5U3RhdGVdfSlgXG4gICAgKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnY29uY2x1ZGUnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7QnVmZmVyfSByZWFzb24gVGhlIHJlYXNvbiBmb3IgY2xvc2luZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkNvbmNsdWRlKGNvZGUsIHJlYXNvbikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkID0gdHJ1ZTtcbiAgd2Vic29ja2V0Ll9jbG9zZU1lc3NhZ2UgPSByZWFzb247XG4gIHdlYnNvY2tldC5fY2xvc2VDb2RlID0gY29kZTtcblxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHdlYnNvY2tldC5fc29ja2V0KTtcblxuICBpZiAoY29kZSA9PT0gMTAwNSkgd2Vic29ja2V0LmNsb3NlKCk7XG4gIGVsc2Ugd2Vic29ja2V0LmNsb3NlKGNvZGUsIHJlYXNvbik7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZHJhaW4nYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRHJhaW4oKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgaWYgKCF3ZWJzb2NrZXQuaXNQYXVzZWQpIHdlYnNvY2tldC5fc29ja2V0LnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoUmFuZ2VFcnJvcnxFcnJvcil9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkVycm9yKGVycikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuXG4gICAgLy9cbiAgICAvLyBPbiBOb2RlLmpzIDwgMTQuMC4wIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBzeW5jaHJvbm91c2x5LiBTZWVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTk0MC5cbiAgICAvL1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgICB3ZWJzb2NrZXQuY2xvc2UoZXJyW2tTdGF0dXNDb2RlXSk7XG4gIH1cblxuICBpZiAoIXdlYnNvY2tldC5fZXJyb3JFbWl0dGVkKSB7XG4gICAgd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdmaW5pc2gnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRmluaXNoKCkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXRDbG9zZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ21lc3NhZ2UnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheUJ1ZmZlcnxCdWZmZXJbXSl9IGRhdGEgVGhlIG1lc3NhZ2VcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCaW5hcnkgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIG1lc3NhZ2UgaXMgYmluYXJ5IG9yIG5vdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdtZXNzYWdlJywgZGF0YSwgaXNCaW5hcnkpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BpbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcGluZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBpbmcoZGF0YSkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQuX2F1dG9Qb25nKSB3ZWJzb2NrZXQucG9uZyhkYXRhLCAhdGhpcy5faXNTZXJ2ZXIsIE5PT1ApO1xuICB3ZWJzb2NrZXQuZW1pdCgncGluZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BvbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcG9uZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBvbmcoZGF0YSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ3BvbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBSZXN1bWUgYSByZWFkYWJsZSBzdHJlYW1cbiAqXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gVGhlIHJlYWRhYmxlIHN0cmVhbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSkge1xuICBzdHJlYW0ucmVzdW1lKCk7XG59XG5cbi8qKlxuICogVGhlIGBTZW5kZXJgIGVycm9yIGV2ZW50IGhhbmRsZXIuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gVGhlIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZW5kZXJPbkVycm9yKGVycikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgc2V0Q2xvc2VUaW1lcih3ZWJzb2NrZXQpO1xuICB9XG5cbiAgLy9cbiAgLy8gYHNvY2tldC5lbmQoKWAgaXMgdXNlZCBpbnN0ZWFkIG9mIGBzb2NrZXQuZGVzdHJveSgpYCB0byBhbGxvdyB0aGUgb3RoZXJcbiAgLy8gcGVlciB0byBmaW5pc2ggc2VuZGluZyBxdWV1ZWQgZGF0YS4gVGhlcmUgaXMgbm8gbmVlZCB0byBzZXQgYSB0aW1lciBoZXJlXG4gIC8vIGJlY2F1c2UgYENMT1NJTkdgIG1lYW5zIHRoYXQgaXQgaXMgYWxyZWFkeSBzZXQgb3Igbm90IG5lZWRlZC5cbiAgLy9cbiAgdGhpcy5fc29ja2V0LmVuZCgpO1xuXG4gIGlmICghd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQpIHtcbiAgICB3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldCBhIHRpbWVyIHRvIGRlc3Ryb3kgdGhlIHVuZGVybHlpbmcgcmF3IHNvY2tldCBvZiBhIFdlYlNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldENsb3NlVGltZXIod2Vic29ja2V0KSB7XG4gIHdlYnNvY2tldC5fY2xvc2VUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgd2Vic29ja2V0Ll9zb2NrZXQuZGVzdHJveS5iaW5kKHdlYnNvY2tldC5fc29ja2V0KSxcbiAgICBjbG9zZVRpbWVvdXRcbiAgKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2Nsb3NlJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25DbG9zZSgpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZW5kJywgc29ja2V0T25FbmQpO1xuXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGxldCBjaHVuaztcblxuICAvL1xuICAvLyBUaGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGhhdmUgYmVlbiByZWNlaXZlZCBvciB0aGUgYCdlbmQnYCBldmVudCBlbWl0dGVkLFxuICAvLyBmb3IgZXhhbXBsZSwgaWYgdGhlIHNvY2tldCB3YXMgZGVzdHJveWVkIGR1ZSB0byBhbiBlcnJvci4gRW5zdXJlIHRoYXQgdGhlXG4gIC8vIGByZWNlaXZlcmAgc3RyZWFtIGlzIGNsb3NlZCBhZnRlciB3cml0aW5nIGFueSByZW1haW5pbmcgYnVmZmVyZWQgZGF0YSB0b1xuICAvLyBpdC4gSWYgdGhlIHJlYWRhYmxlIHNpZGUgb2YgdGhlIHNvY2tldCBpcyBpbiBmbG93aW5nIG1vZGUgdGhlbiB0aGVyZSBpcyBub1xuICAvLyBidWZmZXJlZCBkYXRhIGFzIGV2ZXJ5dGhpbmcgaGFzIGJlZW4gYWxyZWFkeSB3cml0dGVuIGFuZCBgcmVhZGFibGUucmVhZCgpYFxuICAvLyB3aWxsIHJldHVybiBgbnVsbGAuIElmIGluc3RlYWQsIHRoZSBzb2NrZXQgaXMgcGF1c2VkLCBhbnkgcG9zc2libGUgYnVmZmVyZWRcbiAgLy8gZGF0YSB3aWxsIGJlIHJlYWQgYXMgYSBzaW5nbGUgY2h1bmsuXG4gIC8vXG4gIGlmIChcbiAgICAhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkICYmXG4gICAgIXdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkICYmXG4gICAgIXdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkICYmXG4gICAgKGNodW5rID0gd2Vic29ja2V0Ll9zb2NrZXQucmVhZCgpKSAhPT0gbnVsbFxuICApIHtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLndyaXRlKGNodW5rKTtcbiAgfVxuXG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG5cbiAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcblxuICBjbGVhclRpbWVvdXQod2Vic29ja2V0Ll9jbG9zZVRpbWVyKTtcblxuICBpZiAoXG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCB8fFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkXG4gICkge1xuICAgIHdlYnNvY2tldC5lbWl0Q2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25GaW5pc2gpO1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIub24oJ2ZpbmlzaCcsIHJlY2VpdmVyT25GaW5pc2gpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25EYXRhKGNodW5rKSB7XG4gIGlmICghdGhpc1trV2ViU29ja2V0XS5fcmVjZWl2ZXIud3JpdGUoY2h1bmspKSB7XG4gICAgdGhpcy5wYXVzZSgpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdlbmQnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVuZCgpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcbiAgdGhpcy5lbmQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FcnJvcigpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuICB0aGlzLm9uKCdlcnJvcicsIE5PT1ApO1xuXG4gIGlmICh3ZWJzb2NrZXQpIHtcbiAgICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGhlYWRlciBpbnRvIGEgc2V0IG9mIHN1YnByb3RvY29sIG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge1NldH0gVGhlIHN1YnByb3RvY29sIG5hbWVzXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xuICBjb25zdCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGk7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGkgIT09IDAgJiZcbiAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuICAgICkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuXG4gICAgICBjb25zdCBwcm90b2NvbCA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcblxuICAgICAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xuICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgIT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuXG4gIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gIH1cblxuICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcbiAgcmV0dXJuIHByb3RvY29scztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHBhcnNlIH07XG4iLCIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5EdXBsZXgkXCIsIFwiY2F1Z2h0RXJyb3JzXCI6IFwibm9uZVwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgZXh0ZW5zaW9uID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHN1YnByb3RvY29sID0gcmVxdWlyZSgnLi9zdWJwcm90b2NvbCcpO1xuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcbmNvbnN0IHsgR1VJRCwga1dlYlNvY2tldCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga2V5UmVnZXggPSAvXlsrLzAtOUEtWmEtel17MjJ9PT0kLztcblxuY29uc3QgUlVOTklORyA9IDA7XG5jb25zdCBDTE9TSU5HID0gMTtcbmNvbnN0IENMT1NFRCA9IDI7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0IHNlcnZlci5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuY2xhc3MgV2ViU29ja2V0U2VydmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGBXZWJTb2NrZXRTZXJ2ZXJgIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9Qb25nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgYXV0b21hdGljYWxseSBzZW5kIGEgcG9uZyBpbiByZXNwb25zZSB0byBhIHBpbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJhY2tsb2c9NTExXSBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHF1ZXVlIG9mXG4gICAqICAgICBwZW5kaW5nIGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xpZW50VHJhY2tpbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICB0cmFjayBjbGllbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmhhbmRsZVByb3RvY29sc10gQSBob29rIHRvIGhhbmRsZSBwcm90b2NvbHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhvc3RdIFRoZSBob3N0bmFtZSB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcbiAgICogICAgIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub1NlcnZlcj1mYWxzZV0gRW5hYmxlIG5vIHNlcnZlciBtb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXRoXSBBY2NlcHQgb25seSBjb25uZWN0aW9ucyBtYXRjaGluZyB0aGlzIHBhdGhcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT1mYWxzZV0gRW5hYmxlL2Rpc2FibGVcbiAgICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9ydF0gVGhlIHBvcnQgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7KGh0dHAuU2VydmVyfGh0dHBzLlNlcnZlcil9IFtvcHRpb25zLnNlcnZlcl0gQSBwcmUtY3JlYXRlZCBIVFRQL1NcbiAgICogICAgIHNlcnZlciB0byB1c2VcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy52ZXJpZnlDbGllbnRdIEEgaG9vayB0byByZWplY3QgY29ubmVjdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuV2ViU29ja2V0PVdlYlNvY2tldF0gU3BlY2lmaWVzIHRoZSBgV2ViU29ja2V0YFxuICAgKiAgICAgY2xhc3MgdG8gdXNlLiBJdCBtdXN0IGJlIHRoZSBgV2ViU29ja2V0YCBjbGFzcyBvciBjbGFzcyB0aGF0IGV4dGVuZHMgaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBBIGxpc3RlbmVyIGZvciB0aGUgYGxpc3RlbmluZ2AgZXZlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0cnVlLFxuICAgICAgYXV0b1Bvbmc6IHRydWUsXG4gICAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogZmFsc2UsXG4gICAgICBwZXJNZXNzYWdlRGVmbGF0ZTogZmFsc2UsXG4gICAgICBoYW5kbGVQcm90b2NvbHM6IG51bGwsXG4gICAgICBjbGllbnRUcmFja2luZzogdHJ1ZSxcbiAgICAgIHZlcmlmeUNsaWVudDogbnVsbCxcbiAgICAgIG5vU2VydmVyOiBmYWxzZSxcbiAgICAgIGJhY2tsb2c6IG51bGwsIC8vIHVzZSBkZWZhdWx0ICg1MTEgYXMgaW1wbGVtZW50ZWQgaW4gbmV0LmpzKVxuICAgICAgc2VydmVyOiBudWxsLFxuICAgICAgaG9zdDogbnVsbCxcbiAgICAgIHBhdGg6IG51bGwsXG4gICAgICBwb3J0OiBudWxsLFxuICAgICAgV2ViU29ja2V0LFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoXG4gICAgICAob3B0aW9ucy5wb3J0ID09IG51bGwgJiYgIW9wdGlvbnMuc2VydmVyICYmICFvcHRpb25zLm5vU2VydmVyKSB8fFxuICAgICAgKG9wdGlvbnMucG9ydCAhPSBudWxsICYmIChvcHRpb25zLnNlcnZlciB8fCBvcHRpb25zLm5vU2VydmVyKSkgfHxcbiAgICAgIChvcHRpb25zLnNlcnZlciAmJiBvcHRpb25zLm5vU2VydmVyKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ09uZSBhbmQgb25seSBvbmUgb2YgdGhlIFwicG9ydFwiLCBcInNlcnZlclwiLCBvciBcIm5vU2VydmVyXCIgb3B0aW9ucyAnICtcbiAgICAgICAgICAnbXVzdCBiZSBzcGVjaWZpZWQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBvcnQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fc2VydmVyID0gaHR0cC5jcmVhdGVTZXJ2ZXIoKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBodHRwLlNUQVRVU19DT0RFU1s0MjZdO1xuXG4gICAgICAgIHJlcy53cml0ZUhlYWQoNDI2LCB7XG4gICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogYm9keS5sZW5ndGgsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLmVuZChib2R5KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2VydmVyLmxpc3RlbihcbiAgICAgICAgb3B0aW9ucy5wb3J0LFxuICAgICAgICBvcHRpb25zLmhvc3QsXG4gICAgICAgIG9wdGlvbnMuYmFja2xvZyxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNlcnZlcikge1xuICAgICAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgY29uc3QgZW1pdENvbm5lY3Rpb24gPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAnY29ubmVjdGlvbicpO1xuXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSBhZGRMaXN0ZW5lcnModGhpcy5fc2VydmVyLCB7XG4gICAgICAgIGxpc3RlbmluZzogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2xpc3RlbmluZycpLFxuICAgICAgICBlcnJvcjogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJyksXG4gICAgICAgIHVwZ3JhZGU6IChyZXEsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgZW1pdENvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9PT0gdHJ1ZSkgb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNsaWVudFRyYWNraW5nKSB7XG4gICAgICB0aGlzLmNsaWVudHMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX3N0YXRlID0gUlVOTklORztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBib3VuZCBhZGRyZXNzLCB0aGUgYWRkcmVzcyBmYW1pbHkgbmFtZSwgYW5kIHBvcnQgb2YgdGhlIHNlcnZlclxuICAgKiBhcyByZXBvcnRlZCBieSB0aGUgb3BlcmF0aW5nIHN5c3RlbSBpZiBsaXN0ZW5pbmcgb24gYW4gSVAgc29ja2V0LlxuICAgKiBJZiB0aGUgc2VydmVyIGlzIGxpc3RlbmluZyBvbiBhIHBpcGUgb3IgVU5JWCBkb21haW4gc29ja2V0LCB0aGUgbmFtZSBpc1xuICAgKiByZXR1cm5lZCBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7KE9iamVjdHxTdHJpbmd8bnVsbCl9IFRoZSBhZGRyZXNzIG9mIHRoZSBzZXJ2ZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkcmVzcygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgaXMgb3BlcmF0aW5nIGluIFwibm9TZXJ2ZXJcIiBtb2RlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9zZXJ2ZXIpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9zZXJ2ZXIuYWRkcmVzcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIHNlcnZlciBmcm9tIGFjY2VwdGluZyBuZXcgY29ubmVjdGlvbnMgYW5kIGVtaXQgdGhlIGAnY2xvc2UnYCBldmVudFxuICAgKiB3aGVuIGFsbCBleGlzdGluZyBjb25uZWN0aW9ucyBhcmUgY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIEEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY2IpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NFRCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgY2IobmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG5vdCBydW5uaW5nJykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjYikgdGhpcy5vbmNlKCdjbG9zZScsIGNiKTtcblxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQ0xPU0lORykgcmV0dXJuO1xuICAgIHRoaXMuX3N0YXRlID0gQ0xPU0lORztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMubm9TZXJ2ZXIgfHwgdGhpcy5vcHRpb25zLnNlcnZlcikge1xuICAgICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5fc2VydmVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgICBpZiAoIXRoaXMuY2xpZW50cy5zaXplKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Nob3VsZEVtaXRDbG9zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2VydmVyID0gdGhpcy5fc2VydmVyO1xuXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgSFRUUC9TIHNlcnZlciB3YXMgY3JlYXRlZCBpbnRlcm5hbGx5LiBDbG9zZSBpdCwgYW5kIHJlbHkgb24gaXRzXG4gICAgICAvLyBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAgICAvL1xuICAgICAgc2VydmVyLmNsb3NlKCgpID0+IHtcbiAgICAgICAgZW1pdENsb3NlKHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBpZiBhIGdpdmVuIHJlcXVlc3Qgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhpcyBzZXJ2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBSZXF1ZXN0IG9iamVjdCB0byBpbnNwZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcmVxdWVzdCBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNob3VsZEhhbmRsZShyZXEpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBhdGgpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcmVxLnVybC5pbmRleE9mKCc/Jyk7XG4gICAgICBjb25zdCBwYXRobmFtZSA9IGluZGV4ICE9PSAtMSA/IHJlcS51cmwuc2xpY2UoMCwgaW5kZXgpIDogcmVxLnVybDtcblxuICAgICAgaWYgKHBhdGhuYW1lICE9PSB0aGlzLm9wdGlvbnMucGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIEhUVFAgVXBncmFkZSByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBoYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIGNvbnN0IGtleSA9IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddO1xuICAgIGNvbnN0IHVwZ3JhZGUgPSByZXEuaGVhZGVycy51cGdyYWRlO1xuICAgIGNvbnN0IHZlcnNpb24gPSArcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtdmVyc2lvbiddO1xuXG4gICAgaWYgKHJlcS5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgSFRUUCBtZXRob2QnO1xuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDUsIG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh1cGdyYWRlID09PSB1bmRlZmluZWQgfHwgdXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFVwZ3JhZGUgaGVhZGVyJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwgIWtleVJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdNaXNzaW5nIG9yIGludmFsaWQgU2VjLVdlYlNvY2tldC1LZXkgaGVhZGVyJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiAhPT0gOCAmJiB2ZXJzaW9uICE9PSAxMykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdNaXNzaW5nIG9yIGludmFsaWQgU2VjLVdlYlNvY2tldC1WZXJzaW9uIGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNob3VsZEhhbmRsZShyZXEpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0UHJvdG9jb2wgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGxldCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAoc2VjV2ViU29ja2V0UHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvdG9jb2xzID0gc3VicHJvdG9jb2wucGFyc2Uoc2VjV2ViU29ja2V0UHJvdG9jb2wpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlICYmXG4gICAgICBzZWNXZWJTb2NrZXRFeHRlbnNpb25zICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgICB0aGlzLm9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgICAgIHRydWUsXG4gICAgICAgIHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkXG4gICAgICApO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvZmZlcnMgPSBleHRlbnNpb24ucGFyc2Uoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyk7XG5cbiAgICAgICAgaWYgKG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICdJbnZhbGlkIG9yIHVuYWNjZXB0YWJsZSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgY2xpZW50IHZlcmlmaWNhdGlvbiBoYW5kbGVyLlxuICAgIC8vXG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIG9yaWdpbjpcbiAgICAgICAgICByZXEuaGVhZGVyc1tgJHt2ZXJzaW9uID09PSA4ID8gJ3NlYy13ZWJzb2NrZXQtb3JpZ2luJyA6ICdvcmlnaW4nfWBdLFxuICAgICAgICBzZWN1cmU6ICEhKHJlcS5zb2NrZXQuYXV0aG9yaXplZCB8fCByZXEuc29ja2V0LmVuY3J5cHRlZCksXG4gICAgICAgIHJlcVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbywgKHZlcmlmaWVkLCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgaWYgKCF2ZXJpZmllZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSB8fCA0MDEsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKFxuICAgICAgICAgICAgZXh0ZW5zaW9ucyxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHByb3RvY29scyxcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgICBjYlxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvKSkgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAxKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShleHRlbnNpb25zLCBrZXksIHByb3RvY29scywgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlIHRoZSBjb25uZWN0aW9uIHRvIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIGFjY2VwdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgdmFsdWUgb2YgdGhlIGBTZWMtV2ViU29ja2V0LUtleWAgaGVhZGVyXG4gICAqIEBwYXJhbSB7U2V0fSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHdpdGggdGhlIHNhbWUgc29ja2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIC8vXG4gICAgLy8gRGVzdHJveSB0aGUgc29ja2V0IGlmIHRoZSBjbGllbnQgaGFzIGFscmVhZHkgc2VudCBhIEZJTiBwYWNrZXQuXG4gICAgLy9cbiAgICBpZiAoIXNvY2tldC5yZWFkYWJsZSB8fCAhc29ja2V0LndyaXRhYmxlKSByZXR1cm4gc29ja2V0LmRlc3Ryb3koKTtcblxuICAgIGlmIChzb2NrZXRba1dlYlNvY2tldF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3NlcnZlci5oYW5kbGVVcGdyYWRlKCkgd2FzIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lICcgK1xuICAgICAgICAgICdzb2NrZXQsIHBvc3NpYmx5IGR1ZSB0byBhIG1pc2NvbmZpZ3VyYXRpb24nXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGF0ZSA+IFJVTk5JTkcpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDUwMyk7XG5cbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGExJylcbiAgICAgIC51cGRhdGUoa2V5ICsgR1VJRClcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgY29uc3QgaGVhZGVycyA9IFtcbiAgICAgICdIVFRQLzEuMSAxMDEgU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgICAnVXBncmFkZTogd2Vic29ja2V0JyxcbiAgICAgICdDb25uZWN0aW9uOiBVcGdyYWRlJyxcbiAgICAgIGBTZWMtV2ViU29ja2V0LUFjY2VwdDogJHtkaWdlc3R9YFxuICAgIF07XG5cbiAgICBjb25zdCB3cyA9IG5ldyB0aGlzLm9wdGlvbnMuV2ViU29ja2V0KG51bGwsIHVuZGVmaW5lZCwgdGhpcy5vcHRpb25zKTtcblxuICAgIGlmIChwcm90b2NvbHMuc2l6ZSkge1xuICAgICAgLy9cbiAgICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBwcm90b2NvbCBzZWxlY3Rpb24gaGFuZGxlci5cbiAgICAgIC8vXG4gICAgICBjb25zdCBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHNcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzKHByb3RvY29scywgcmVxKVxuICAgICAgICA6IHByb3RvY29scy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG5cbiAgICAgIGlmIChwcm90b2NvbCkge1xuICAgICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2w6ICR7cHJvdG9jb2x9YCk7XG4gICAgICAgIHdzLl9wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLnBhcmFtcztcbiAgICAgIGNvbnN0IHZhbHVlID0gZXh0ZW5zaW9uLmZvcm1hdCh7XG4gICAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogW3BhcmFtc11cbiAgICAgIH0pO1xuICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnM6ICR7dmFsdWV9YCk7XG4gICAgICB3cy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBBbGxvdyBleHRlcm5hbCBtb2RpZmljYXRpb24vaW5zcGVjdGlvbiBvZiBoYW5kc2hha2UgaGVhZGVycy5cbiAgICAvL1xuICAgIHRoaXMuZW1pdCgnaGVhZGVycycsIGhlYWRlcnMsIHJlcSk7XG5cbiAgICBzb2NrZXQud3JpdGUoaGVhZGVycy5jb25jYXQoJ1xcclxcbicpLmpvaW4oJ1xcclxcbicpKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB3cy5zZXRTb2NrZXQoc29ja2V0LCBoZWFkLCB7XG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0aGlzLm9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcbiAgICAgIG1heFBheWxvYWQ6IHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiB0aGlzLm9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5jbGllbnRzKSB7XG4gICAgICB0aGlzLmNsaWVudHMuYWRkKHdzKTtcbiAgICAgIHdzLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnRzLmRlbGV0ZSh3cyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZEVtaXRDbG9zZSAmJiAhdGhpcy5jbGllbnRzLnNpemUpIHtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNiKHdzLCByZXEpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0U2VydmVyO1xuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lcnMgb24gYW4gYEV2ZW50RW1pdHRlcmAgdXNpbmcgYSBtYXAgb2YgPGV2ZW50LCBsaXN0ZW5lcj5cbiAqIHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBzZXJ2ZXIgVGhlIGV2ZW50IGVtaXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIEZ1bmN0aW9uPn0gbWFwIFRoZSBsaXN0ZW5lcnMgdG8gYWRkXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhZGRlZCBsaXN0ZW5lcnMgd2hlblxuICogICAgIGNhbGxlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKHNlcnZlciwgbWFwKSB7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkgc2VydmVyLm9uKGV2ZW50LCBtYXBbZXZlbnRdKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkge1xuICAgICAgc2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBtYXBbZXZlbnRdKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRW1pdCBhIGAnY2xvc2UnYCBldmVudCBvbiBhbiBgRXZlbnRFbWl0dGVyYC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc2VydmVyKSB7XG4gIHNlcnZlci5fc3RhdGUgPSBDTE9TRUQ7XG4gIHNlcnZlci5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBzb2NrZXQgZXJyb3JzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIHRoaXMuZGVzdHJveSgpO1xufVxuXG4vKipcbiAqIENsb3NlIHRoZSBjb25uZWN0aW9uIHdoZW4gcHJlY29uZGl0aW9ucyBhcmUgbm90IGZ1bGZpbGxlZC5cbiAqXG4gKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXSBBZGRpdGlvbmFsIEhUVFAgcmVzcG9uc2UgaGVhZGVyc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG4gIC8vXG4gIC8vIFRoZSBzb2NrZXQgaXMgd3JpdGFibGUgdW5sZXNzIHRoZSB1c2VyIGRlc3Ryb3llZCBvciBlbmRlZCBpdCBiZWZvcmUgY2FsbGluZ1xuICAvLyBgc2VydmVyLmhhbmRsZVVwZ3JhZGUoKWAgb3IgaW4gdGhlIGB2ZXJpZnlDbGllbnRgIGZ1bmN0aW9uLCB3aGljaCBpcyBhIHVzZXJcbiAgLy8gZXJyb3IuIEhhbmRsaW5nIHRoaXMgZG9lcyBub3QgbWFrZSBtdWNoIHNlbnNlIGFzIHRoZSB3b3JzdCB0aGF0IGNhbiBoYXBwZW5cbiAgLy8gaXMgdGhhdCBzb21lIG9mIHRoZSBkYXRhIHdyaXR0ZW4gYnkgdGhlIHVzZXIgbWlnaHQgYmUgZGlzY2FyZGVkIGR1ZSB0byB0aGVcbiAgLy8gY2FsbCB0byBgc29ja2V0LmVuZCgpYCBiZWxvdywgd2hpY2ggdHJpZ2dlcnMgYW4gYCdlcnJvcidgIGV2ZW50IHRoYXQgaW5cbiAgLy8gdHVybiBjYXVzZXMgdGhlIHNvY2tldCB0byBiZSBkZXN0cm95ZWQuXG4gIC8vXG4gIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IGh0dHAuU1RBVFVTX0NPREVTW2NvZGVdO1xuICBoZWFkZXJzID0ge1xuICAgIENvbm5lY3Rpb246ICdjbG9zZScsXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L2h0bWwnLFxuICAgICdDb250ZW50LUxlbmd0aCc6IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpLFxuICAgIC4uLmhlYWRlcnNcbiAgfTtcblxuICBzb2NrZXQub25jZSgnZmluaXNoJywgc29ja2V0LmRlc3Ryb3kpO1xuXG4gIHNvY2tldC5lbmQoXG4gICAgYEhUVFAvMS4xICR7Y29kZX0gJHtodHRwLlNUQVRVU19DT0RFU1tjb2RlXX1cXHJcXG5gICtcbiAgICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgICAgIC5tYXAoKGgpID0+IGAke2h9OiAke2hlYWRlcnNbaF19YClcbiAgICAgICAgLmpvaW4oJ1xcclxcbicpICtcbiAgICAgICdcXHJcXG5cXHJcXG4nICtcbiAgICAgIG1lc3NhZ2VcbiAgKTtcbn1cblxuLyoqXG4gKiBFbWl0IGEgYCd3c0NsaWVudEVycm9yJ2AgZXZlbnQgb24gYSBgV2ViU29ja2V0U2VydmVyYCBpZiB0aGVyZSBpcyBhdCBsZWFzdFxuICogb25lIGxpc3RlbmVyIGZvciBpdCwgb3RoZXJ3aXNlIGNhbGwgYGFib3J0SGFuZHNoYWtlKClgLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0U2VydmVyfSBzZXJ2ZXIgVGhlIFdlYlNvY2tldCBzZXJ2ZXJcbiAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIHNvY2tldCBvZiB0aGUgdXBncmFkZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHNlcnZlciwgcmVxLCBzb2NrZXQsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgaWYgKHNlcnZlci5saXN0ZW5lckNvdW50KCd3c0NsaWVudEVycm9yJykpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IpO1xuXG4gICAgc2VydmVyLmVtaXQoJ3dzQ2xpZW50RXJyb3InLCBlcnIsIHNvY2tldCwgcmVxKTtcbiAgfSBlbHNlIHtcbiAgICBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUsIG1lc3NhZ2UpO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtcbiAgQ2xvc2VFdmVudCBhcyBXU0Nsb3NlRXZlbnQsXG4gIEVycm9yRXZlbnQgYXMgV1NFcnJvckV2ZW50LFxuICBNZXNzYWdlRXZlbnQgYXMgV1NNZXNzYWdlRXZlbnQsXG4gIFdlYlNvY2tldCBhcyBXUyxcbn0gZnJvbSBcIndzXCI7XG5pbXBvcnQgeyBDb25uZWN0aW9uU2V0dGluZ3MgfSBmcm9tIFwiLi9pbnRlcmZhY2VzXCI7XG5cbmV4cG9ydCB0eXBlIFdlYlNvY2tldCA9IFdTO1xuZXhwb3J0IGNvbnN0IFdlYlNvY2tldCA9IFdTO1xuZXhwb3J0IHR5cGUgTWVzc2FnZUV2ZW50ID0gV1NNZXNzYWdlRXZlbnQ7XG5leHBvcnQgdHlwZSBDbG9zZUV2ZW50ID0gV1NDbG9zZUV2ZW50O1xuZXhwb3J0IHR5cGUgRXJyb3JFdmVudCA9IFdTRXJyb3JFdmVudDtcblxuZXhwb3J0IGNvbnN0IHNlbmRNZXNzYWdlID0gKFxuICBzb2NrZXQ6IFdlYlNvY2tldCxcbiAgbWVzc2FnZTogc3RyaW5nIHwgQXJyYXlCdWZmZXJMaWtlIHwgQXJyYXlCdWZmZXJWaWV3LFxuKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc29ja2V0LnNlbmQobWVzc2FnZSwgKGVycm9yPzogRXJyb3IpID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRXZWJzb2NrZXQoXG4gIHNldHRpbmdzOiBDb25uZWN0aW9uU2V0dGluZ3MsXG4pOiBQcm9taXNlPFdlYlNvY2tldD4ge1xuICBpZiAoc2V0dGluZ3MucG9saWN5ICE9IHVuZGVmaW5lZCkge1xuICAgIHNldHRpbmdzID0gYXdhaXQgc2V0dGluZ3MucG9saWN5KHNldHRpbmdzKTtcbiAgfVxuICByZXR1cm4gbmV3IFdlYlNvY2tldChzZXR0aW5ncy51cmksIHNldHRpbmdzLnByb3RvY29scywge1xuICAgIGhlYWRlcnM6IHNldHRpbmdzLmhlYWRlcnMsXG4gIH0pO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IENvbm5lY3Rpb25TZXR0aW5ncyB9IGZyb20gXCIuL2ludGVyZmFjZXNcIjtcbmltcG9ydCB7XG4gIFdlYlNvY2tldCxcbiAgRXJyb3JFdmVudCxcbiAgQ2xvc2VFdmVudCxcbiAgTWVzc2FnZUV2ZW50LFxuICBzZW5kTWVzc2FnZSxcbiAgZ2V0V2Vic29ja2V0LFxufSBmcm9tIFwiLi93ZWJzb2NrZXRcIjtcblxudHlwZSBSZXNvbHZlRm48VD4gPSAodmFsdWU6IEl0ZXJhdG9yUmVzdWx0PFQ+KSA9PiB2b2lkO1xudHlwZSBSZWplY3RGbjxFPiA9IChyZWFzb246IEUpID0+IHZvaWQ7XG5cbmV4cG9ydCB0eXBlIFZhbGlkYXRvclJlc3VsdDxUPiA9XG4gIHwgeyBzdWNjZXNzOiB0cnVlOyBtZXNzYWdlOiBUIH1cbiAgfCB7IHN1Y2Nlc3M6IGZhbHNlOyBlcnJvcjogRXJyb3IgfTtcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRpb25TdWNjZXNzID0gPFQ+KG1lc3NhZ2U6IFQpOiBWYWxpZGF0b3JSZXN1bHQ8VD4gPT4gKHtcbiAgc3VjY2VzczogdHJ1ZSxcbiAgbWVzc2FnZSxcbn0pO1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRpb25FcnJvciA9IDxUPihlcnJvcjogRXJyb3IpOiBWYWxpZGF0b3JSZXN1bHQ8VD4gPT4gKHtcbiAgc3VjY2VzczogZmFsc2UsXG4gIGVycm9yLFxufSk7XG5jb25zdCBpc1ZhbGlkYXRvclN1Y2Nlc3MgPSA8VD4oXG4gIHJlc3VsdDogVmFsaWRhdG9yUmVzdWx0PFQ+LFxuKTogcmVzdWx0IGlzIHsgc3VjY2VzczogdHJ1ZTsgbWVzc2FnZTogVCB9ID0+IHJlc3VsdC5zdWNjZXNzO1xuXG5leHBvcnQgdHlwZSBWYWxpZGF0ZVByb3RvY29sTWVzc2FnZTxUPiA9IChcbiAgbWVzc2FnZTogTWVzc2FnZUV2ZW50LFxuKSA9PiBWYWxpZGF0b3JSZXN1bHQ8VD47XG5leHBvcnQgdHlwZSBTZXJpYWxpemVNZXNzYWdlPFQ+ID0gKFxuICBtZXNzYWdlOiBULFxuKSA9PiBzdHJpbmcgfCBBcnJheUJ1ZmZlckxpa2UgfCBBcnJheUJ1ZmZlclZpZXc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZVByb3RvY29sSGFuZGxlcjxVLCBEPiB7XG4gIHZhbGlkYXRlOiBWYWxpZGF0ZVByb3RvY29sTWVzc2FnZTxEPjtcbiAgc2VyaWFsaXplOiBTZXJpYWxpemVNZXNzYWdlPFU+O1xufVxuXG5leHBvcnQgY2xhc3MgV2ViU29ja2V0Q2xpZW50PFUsIEQ+IGltcGxlbWVudHMgQXN5bmNJdGVyYWJsZTxEPiB7XG4gIHByaXZhdGUgc29ja2V0OiBXZWJTb2NrZXQ7XG4gIHByaXZhdGUgY29ubmVjdGVkUHJvbWlzZTogUHJvbWlzZTx2b2lkPjtcbiAgcHJpdmF0ZSBjbG9zZWRQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBwcml2YXRlIGVycm9yOiBFcnJvciB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBtZXNzYWdlUXVldWU6IERbXSA9IFtdO1xuICBwcml2YXRlIHZhbGlkYXRlOiBWYWxpZGF0ZVByb3RvY29sTWVzc2FnZTxEPjtcbiAgcHJpdmF0ZSBzZXJpYWxpemU6IFNlcmlhbGl6ZU1lc3NhZ2U8VT47XG5cbiAgcHJpdmF0ZSByZWNlaXZlclF1ZXVlOiBbUmVzb2x2ZUZuPEQ+LCBSZWplY3RGbjxFcnJvcj5dW10gPSBbXTtcbiAgcHJpdmF0ZSBkb25lOiBib29sZWFuID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgc2V0dGluZ3M6IENvbm5lY3Rpb25TZXR0aW5ncyxcbiAgICBoYW5kbGVyOiBNZXNzYWdlUHJvdG9jb2xIYW5kbGVyPFUsIEQ+LFxuICApIHtcbiAgICB0aGlzLnZhbGlkYXRlID0gaGFuZGxlci52YWxpZGF0ZTtcbiAgICB0aGlzLnNlcmlhbGl6ZSA9IGhhbmRsZXIuc2VyaWFsaXplO1xuICAgIHRoaXMuY29ubmVjdGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuc29ja2V0ID0gYXdhaXQgZ2V0V2Vic29ja2V0KHNldHRpbmdzKTtcbiAgICAgIHRoaXMuc29ja2V0Lm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5zb2NrZXQub25tZXNzYWdlID0gdGhpcy5nZXRNZXNzYWdlSGFuZGxlcigpO1xuICAgICAgICB0aGlzLmNsb3NlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuc29ja2V0Lm9uY2xvc2UgPSB0aGlzLmdldENsb3NlZEhhbmRsZXIocmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNvY2tldC5vbmVycm9yID0gdGhpcy5oYW5kbGVFcnJvcjtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5zb2NrZXQub25lcnJvciA9IChldmVudDogRXJyb3JFdmVudCkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGV2ZW50KTtcbiAgICAgICAgcmVqZWN0KHRoaXMuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlRXJyb3IoZXZlbnQ6IEVycm9yRXZlbnQpIHtcbiAgICB0aGlzLmVycm9yID0gZXZlbnQuZXJyb3IgfHwgbmV3IEVycm9yKCd1bmtub3duIGVycm9yJyk7XG4gICAgd2hpbGUgKHRoaXMucmVjZWl2ZXJRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBbXywgcmVqZWN0XSA9IHRoaXMucmVjZWl2ZXJRdWV1ZS5zaGlmdCgpITtcbiAgICAgIHJlamVjdCh0aGlzLmVycm9yISk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRDbG9zZWRIYW5kbGVyKFxuICAgIGNsb3NlUmVzb2x2ZTogKF86IHZvaWQpID0+IHZvaWQsXG4gICk6IChldmVudDogQ2xvc2VFdmVudCkgPT4gdm9pZCB7XG4gICAgcmV0dXJuIChldmVudDogQ2xvc2VFdmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmNvZGUgIT09IDEwMDAgJiYgdGhpcy5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGBXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQgd2l0aCBlcnJvcjogJHtldmVudC5yZWFzb259LCBjb2RlOiAke2V2ZW50LmNvZGV9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICB3aGlsZSAodGhpcy5yZWNlaXZlclF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgW3Jlc29sdmUsIHJlamVjdF0gPSB0aGlzLnJlY2VpdmVyUXVldWUuc2hpZnQoKSE7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KHRoaXMuZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjbG9zZVJlc29sdmUoKTtcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRNZXNzYWdlSGFuZGxlcigpOiAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4gdm9pZCB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBzZWxmLnZhbGlkYXRlKGV2ZW50KTtcbiAgICAgIGlmIChpc1ZhbGlkYXRvclN1Y2Nlc3MocmVzdWx0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IHJlc3VsdDtcbiAgICAgICAgaWYgKHNlbGYucmVjZWl2ZXJRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgW3Jlc29sdmUsIF9dID0gc2VsZi5yZWNlaXZlclF1ZXVlLnNoaWZ0KCkhO1xuICAgICAgICAgIHJlc29sdmUoeyB2YWx1ZTogbWVzc2FnZSwgZG9uZTogZmFsc2UgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5tZXNzYWdlUXVldWUucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5lcnJvciA9IHJlc3VsdC5lcnJvcjtcbiAgICAgICAgc2VsZi5zb2NrZXQuY2xvc2UoMTAwMCwgXCJVbmV4cGVjdGVkIG1lc3NhZ2UgcmVjZWl2ZWRcIik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTogQXN5bmNJdGVyYXRvcjxEPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6ICgpOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PEQ+PiA9PiB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubWVzc2FnZVF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5tZXNzYWdlUXVldWUuc2hpZnQoKSE7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbHVlOiBtZXNzYWdlLCBkb25lOiBmYWxzZSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZlclF1ZXVlLnB1c2goW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBhc3luYyBzZW5kKG1lc3NhZ2U6IFUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmNvbm5lY3RlZFByb21pc2U7XG4gICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB0aGlzLnNlcmlhbGl6ZShtZXNzYWdlKTtcbiAgICByZXR1cm4gc2VuZE1lc3NhZ2UodGhpcy5zb2NrZXQsIHNlcmlhbGl6ZWQpO1xuICB9XG5cbiAgYXN5bmMgY2xvc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5jb25uZWN0ZWRQcm9taXNlO1xuICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zb2NrZXQuY2xvc2UoKTtcbiAgICBhd2FpdCB0aGlzLmNsb3NlZFByb21pc2U7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5leHBvcnQgaW50ZXJmYWNlIEtleUNyZWRlbnRpYWwge1xuICBrZXk6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBY2Nlc3NUb2tlbiB7XG4gIHRva2VuOiBzdHJpbmc7XG4gIGV4cGlyZXNPblRpbWVzdGFtcDogbnVtYmVyO1xuICByZWZyZXNoQWZ0ZXJUaW1lc3RhbXA/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9rZW5DcmVkZW50aWFsIHtcbiAgZ2V0VG9rZW4oc2NvcGVzOiBzdHJpbmcgfCBzdHJpbmdbXSwgb3B0aW9ucz86IHVua25vd24pOiBQcm9taXNlPEFjY2Vzc1Rva2VuPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzS2V5Q3JlZGVudGlhbChcbiAgY3JlZGVudGlhbDogdW5rbm93bixcbik6IGNyZWRlbnRpYWwgaXMgS2V5Q3JlZGVudGlhbCB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGNyZWRlbnRpYWwgPT09IFwib2JqZWN0XCIgJiZcbiAgICBjcmVkZW50aWFsICE9PSBudWxsICYmXG4gICAgXCJrZXlcIiBpbiBjcmVkZW50aWFsICYmXG4gICAgdHlwZW9mIChjcmVkZW50aWFsIGFzIEtleUNyZWRlbnRpYWwpLmtleSA9PT0gXCJzdHJpbmdcIlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUb2tlbkNyZWRlbnRpYWwoXG4gIGNyZWRlbnRpYWw6IHVua25vd24sXG4pOiBjcmVkZW50aWFsIGlzIFRva2VuQ3JlZGVudGlhbCB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGNyZWRlbnRpYWwgPT09IFwib2JqZWN0XCIgJiZcbiAgICBjcmVkZW50aWFsICE9PSBudWxsICYmXG4gICAgXCJnZXRUb2tlblwiIGluIGNyZWRlbnRpYWwgJiZcbiAgICB0eXBlb2YgKGNyZWRlbnRpYWwgYXMgVG9rZW5DcmVkZW50aWFsKS5nZXRUb2tlbiA9PT0gXCJmdW5jdGlvblwiXG4gICk7XG59XG5cbmV4cG9ydCBjb25zdCBpc0NyZWRlbnRpYWwgPSAoXG4gIGNyZWRlbnRpYWw6IHVua25vd24sXG4pOiBjcmVkZW50aWFsIGlzIEtleUNyZWRlbnRpYWwgfCBUb2tlbkNyZWRlbnRpYWwgPT5cbiAgaXNLZXlDcmVkZW50aWFsKGNyZWRlbnRpYWwpIHx8IGlzVG9rZW5DcmVkZW50aWFsKGNyZWRlbnRpYWwpO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmV4cG9ydCB0eXBlIFdlYlNvY2tldFBvbGljeSA9IChcbiAgQ29ubmVjdGlvblNldHRpbmdzOiBDb25uZWN0aW9uU2V0dGluZ3MsXG4pID0+IFByb21pc2U8Q29ubmVjdGlvblNldHRpbmdzPjtcblxuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0aW9uU2V0dGluZ3Mge1xuICB1cmk6IFVSTDtcbiAgcHJvdG9jb2xzPzogc3RyaW5nW107XG4gIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICBwb2xpY3k/OiBXZWJTb2NrZXRQb2xpY3k7XG4gIHJlcXVlc3RJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSVE9wZW5BSU9wdGlvbnMge1xuICBtb2RlbDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJUQXp1cmVPcGVuQUlPcHRpb25zIHtcbiAgZGVwbG95bWVudDogc3RyaW5nO1xuICByZXF1ZXN0SWQ/OiBzdHJpbmc7XG4gIGFwaVZlcnNpb24/OiBzdHJpbmc7XG4gIHBhdGg/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXp1cmVBZ2VudENvbmZpZyB7XG4gIGFnZW50SWQ6IHN0cmluZztcbiAgcHJvamVjdE5hbWU/OiBzdHJpbmc7XG4gIGFnZW50Q29ubmVjdGlvblN0cmluZz86IHN0cmluZztcbiAgYWdlbnRBdXRoZW50aWNhdGlvbklkZW50aXR5Q2xpZW50SWQ/OiBzdHJpbmc7XG4gIGFnZW50QWNjZXNzVG9rZW4/OiBzdHJpbmc7XG4gIHRocmVhZElkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJUVm9pY2VBZ2VudE9wdGlvbnMge1xuICBtb2RlbE9yQWdlbnQ6IHN0cmluZyB8IEF6dXJlQWdlbnRDb25maWc7XG4gIHByb2ZpbGU/OiBzdHJpbmc7XG4gIHJlcXVlc3RJZD86IHN0cmluZztcbiAgYXBpVmVyc2lvbj86IHN0cmluZztcbiAgcGF0aD86IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IGlzUlRPcGVuQUlPcHRpb25zID0gKFxuICBvcHRpb25zOiB1bmtub3duLFxuKTogb3B0aW9ucyBpcyBSVE9wZW5BSU9wdGlvbnMgPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmXG4gICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgIFwibW9kZWxcIiBpbiBvcHRpb25zICYmXG4gICAgdHlwZW9mIChvcHRpb25zIGFzIFJUT3BlbkFJT3B0aW9ucykubW9kZWwgPT09IFwic3RyaW5nXCJcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBpc1JUQXp1cmVPcGVuQUlPcHRpb25zID0gKFxuICBvcHRpb25zOiB1bmtub3duLFxuKTogb3B0aW9ucyBpcyBSVEF6dXJlT3BlbkFJT3B0aW9ucyA9PiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiZcbiAgICBvcHRpb25zICE9PSBudWxsICYmXG4gICAgXCJkZXBsb3ltZW50XCIgaW4gb3B0aW9ucyAmJlxuICAgIHR5cGVvZiAob3B0aW9ucyBhcyBSVEF6dXJlT3BlbkFJT3B0aW9ucykuZGVwbG95bWVudCA9PT0gXCJzdHJpbmdcIlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzUlRWb2ljZUFnZW50T3B0aW9ucyA9IChcbiAgb3B0aW9uczogdW5rbm93bixcbik6IG9wdGlvbnMgaXMgUlRWb2ljZUFnZW50T3B0aW9ucyA9PiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiZcbiAgICBvcHRpb25zICE9PSBudWxsICYmXG4gICAgKFwibW9kZWxPckFnZW50XCIgaW4gb3B0aW9ucyAmJiAob3B0aW9ucyBhcyBSVFZvaWNlQWdlbnRPcHRpb25zKS5tb2RlbE9yQWdlbnQgIT09IHVuZGVmaW5lZClcbiAgKTtcbn0iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgaXNLZXlDcmVkZW50aWFsLCBLZXlDcmVkZW50aWFsLCBUb2tlbkNyZWRlbnRpYWwgfSBmcm9tIFwiLi9hdXRoXCI7XG5pbXBvcnQge1xuICBDb25uZWN0aW9uU2V0dGluZ3MsXG4gIFJUQXp1cmVPcGVuQUlPcHRpb25zLFxuICBSVE9wZW5BSU9wdGlvbnMsXG4gIFJUVm9pY2VBZ2VudE9wdGlvbnMsXG59IGZyb20gXCIuL2ludGVyZmFjZXNcIjtcblxuZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICByZXR1cm4gYG1zLXJ0Y2xpZW50L1BBQ0tBR0VfVkVSU0lPTmA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcGVuQUlTZXR0aW5ncyhcbiAgY3JlZGVudGlhbDogS2V5Q3JlZGVudGlhbCxcbiAgb3B0aW9uczogUlRPcGVuQUlPcHRpb25zLFxuKTogQ29ubmVjdGlvblNldHRpbmdzIHtcbiAgY29uc3QgdXJpID0gbmV3IFVSTChcIndzczovL2FwaS5vcGVuYWkuY29tL3YxL3JlYWx0aW1lXCIpO1xuICB1cmkuc2VhcmNoUGFyYW1zLnNldChcIm1vZGVsXCIsIG9wdGlvbnMubW9kZWwpO1xuICByZXR1cm4ge1xuICAgIHVyaSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7Y3JlZGVudGlhbC5rZXl9YCxcbiAgICAgIFwib3BlbmFpLWJldGFcIjogXCJyZWFsdGltZT12MVwiLFxuICAgICAgXCJVc2VyLUFnZW50XCI6IFwib3BlbmFpLW5vZGVcIixcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXp1cmVPcGVuQUlTZXR0aW5ncyhcbiAgdXJpOiBVUkwsXG4gIGNyZWRlbnRpYWw6IEtleUNyZWRlbnRpYWwgfCBUb2tlbkNyZWRlbnRpYWwsXG4gIG9wdGlvbnM6IFJUQXp1cmVPcGVuQUlPcHRpb25zLFxuKTogQ29ubmVjdGlvblNldHRpbmdzIHtcbiAgY29uc3QgcmVxdWVzdElkID0gb3B0aW9ucy5yZXF1ZXN0SWQgPz8gY3J5cHRvLnJhbmRvbVVVSUQoKTtcblxuICBjb25zdCBzY29wZXMgPSBbXCJodHRwczovL2NvZ25pdGl2ZXNlcnZpY2VzLmF6dXJlLmNvbS8uZGVmYXVsdFwiXTtcblxuICB1cmkuc2VhcmNoUGFyYW1zLnNldChcImFwaS12ZXJzaW9uXCIsIG9wdGlvbnMuYXBpVmVyc2lvbiA/PyBcIjIwMjQtMTAtMDEtcHJldmlld1wiKTtcbiAgdXJpLnNlYXJjaFBhcmFtcy5zZXQoXCJkZXBsb3ltZW50XCIsIG9wdGlvbnMuZGVwbG95bWVudCk7XG4gIHVyaS5wYXRobmFtZSA9IG9wdGlvbnMucGF0aCA/PyBcIm9wZW5haS9yZWFsdGltZVwiO1xuICByZXR1cm4ge1xuICAgIHVyaSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIlVzZXItQWdlbnRcIjogZ2V0VXNlckFnZW50KCksXG4gICAgICBcIngtbXMtY2xpZW50LXJlcXVlc3QtaWRcIjogcmVxdWVzdElkLFxuICAgIH0sXG4gICAgcG9saWN5OiBhc3luYyAoc2V0dGluZ3MpID0+IHtcbiAgICAgIGlmIChpc0tleUNyZWRlbnRpYWwoY3JlZGVudGlhbCkpIHtcbiAgICAgICAgc2V0dGluZ3MuaGVhZGVycyA9IHtcbiAgICAgICAgICAuLi5zZXR0aW5ncy5oZWFkZXJzLFxuICAgICAgICAgIFwiYXBpLWtleVwiOiBjcmVkZW50aWFsLmtleSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgY3JlZGVudGlhbC5nZXRUb2tlbihzY29wZXMpO1xuICAgICAgICBzZXR0aW5ncy5oZWFkZXJzID0ge1xuICAgICAgICAgIC4uLnNldHRpbmdzLmhlYWRlcnMsXG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VuLnRva2VufWAsXG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgIH0sXG4gIH07XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHZvaWNlQWdlbnRTZXR0aW5ncyhcbiAgdXJpOiBVUkwsXG4gIGNyZWRlbnRpYWw6IEtleUNyZWRlbnRpYWwgfCBUb2tlbkNyZWRlbnRpYWwsXG4gIG9wdGlvbnM6IFJUVm9pY2VBZ2VudE9wdGlvbnMsXG4pOiBDb25uZWN0aW9uU2V0dGluZ3Mge1xuICBjb25zdCByZXF1ZXN0SWQgPSBvcHRpb25zLnJlcXVlc3RJZCA/PyBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuXG4gIGNvbnN0IHNjb3BlcyA9IFtcImh0dHBzOi8vY29nbml0aXZlc2VydmljZXMuYXp1cmUuY29tLy5kZWZhdWx0XCJdO1xuXG4gIHVyaS5zZWFyY2hQYXJhbXMuc2V0KFwiYXBpLXZlcnNpb25cIiwgb3B0aW9ucy5hcGlWZXJzaW9uID8/IFwiMjAyNS0wNS0wMS1wcmV2aWV3XCIpO1xuICB1cmkuc2VhcmNoUGFyYW1zLnNldChcIngtbXMtY2xpZW50LXJlcXVlc3QtaWRcIiwgcmVxdWVzdElkISk7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5tb2RlbE9yQWdlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICB1cmkuc2VhcmNoUGFyYW1zLnNldChcIm1vZGVsXCIsIG9wdGlvbnMubW9kZWxPckFnZW50KTtcbiAgfSBlbHNlIHtcbiAgICB1cmkuc2VhcmNoUGFyYW1zLnNldChcImFnZW50X2lkXCIsIG9wdGlvbnMubW9kZWxPckFnZW50LmFnZW50SWQpO1xuICAgIGlmIChvcHRpb25zLm1vZGVsT3JBZ2VudC5wcm9qZWN0TmFtZSkge1xuICAgICAgdXJpLnNlYXJjaFBhcmFtcy5zZXQoXCJhZ2VudC1wcm9qZWN0LW5hbWVcIiwgb3B0aW9ucy5tb2RlbE9yQWdlbnQucHJvamVjdE5hbWUpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5tb2RlbE9yQWdlbnQuYWdlbnRDb25uZWN0aW9uU3RyaW5nKSB7XG4gICAgICB1cmkuc2VhcmNoUGFyYW1zLnNldChcbiAgICAgICAgXCJhZ2VudF9jb25uZWN0aW9uX3N0cmluZ1wiLFxuICAgICAgICBvcHRpb25zLm1vZGVsT3JBZ2VudC5hZ2VudENvbm5lY3Rpb25TdHJpbmcsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5tb2RlbE9yQWdlbnQuYWdlbnRBY2Nlc3NUb2tlbikge1xuICAgICAgdXJpLnNlYXJjaFBhcmFtcy5zZXQoXG4gICAgICAgIFwiYWdlbnRfYWNjZXNzX3Rva2VuXCIsXG4gICAgICAgIG9wdGlvbnMubW9kZWxPckFnZW50LmFnZW50QWNjZXNzVG9rZW4sXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5tb2RlbE9yQWdlbnQudGhyZWFkSWQpIHtcbiAgICAgIHVyaS5zZWFyY2hQYXJhbXMuc2V0KFwiYWdlbnRfdGhyZWFkX2lkXCIsIG9wdGlvbnMubW9kZWxPckFnZW50LnRocmVhZElkKTtcbiAgICB9XG4gIH1cbiAgdXJpLnBhdGhuYW1lID0gb3B0aW9ucy5wYXRoID8/IFwidm9pY2UtYWdlbnQvcmVhbHRpbWVcIjtcbiAgcmV0dXJuIHtcbiAgICB1cmksXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJVc2VyLUFnZW50XCI6IGdldFVzZXJBZ2VudCgpLFxuICAgICAgXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCI6IHJlcXVlc3RJZCxcbiAgICB9LFxuICAgIHBvbGljeTogYXN5bmMgKHNldHRpbmdzKSA9PiB7XG4gICAgICBpZiAoaXNLZXlDcmVkZW50aWFsKGNyZWRlbnRpYWwpKSB7XG4gICAgICAgIHNldHRpbmdzLmhlYWRlcnMgPSB7XG4gICAgICAgICAgLi4uc2V0dGluZ3MuaGVhZGVycyxcbiAgICAgICAgICBcImFwaS1rZXlcIjogY3JlZGVudGlhbC5rZXksXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IGNyZWRlbnRpYWwuZ2V0VG9rZW4oc2NvcGVzKTtcbiAgICAgICAgc2V0dGluZ3MuaGVhZGVycyA9IHtcbiAgICAgICAgICAuLi5zZXR0aW5ncy5oZWFkZXJzLFxuICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbi50b2tlbn1gLFxuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICB9LFxuICB9O1xufSIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG50eXBlIFJlY2VpdmVGdW5jdGlvbjxUPiA9ICgpID0+IFByb21pc2U8VCB8IG51bGw+O1xuXG50eXBlIFJlc29sdmVGbjxUPiA9ICh2YWx1ZTogVCB8IG51bGwpID0+IHZvaWQ7XG50eXBlIFJlamVjdEZuPEU+ID0gKHJlYXNvbjogRSkgPT4gdm9pZDtcblxudHlwZSBQcmVkaWNhdGU8VD4gPSAobWVzc2FnZTogVCkgPT4gYm9vbGVhbjtcblxuZXhwb3J0IGNsYXNzIE1lc3NhZ2VRdWV1ZTxUPiB7XG4gIHByaXZhdGUgbWVzc2FnZXM6IFRbXSA9IFtdO1xuICBwcm90ZWN0ZWQgd2FpdGluZ1JlY2VpdmVyczogW1xuICAgIFByZWRpY2F0ZTxUPixcbiAgICBbUmVzb2x2ZUZuPFQ+LCBSZWplY3RGbjxFcnJvcj5dLFxuICAgIEFib3J0Q29udHJvbGxlcixcbiAgXVtdID0gW107XG4gIHByaXZhdGUgaXNQb2xsaW5nOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgcG9sbFByb21pc2U6IFByb21pc2U8dm9pZD4gfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlY2VpdmVEZWxlZ2F0ZTogUmVjZWl2ZUZ1bmN0aW9uPFQ+KSB7fVxuXG4gIHByb3RlY3RlZCBwdXNoQmFjayhtZXNzYWdlOiBUKSB7XG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kQW5kUmVtb3ZlKHByZWRpY2F0ZTogUHJlZGljYXRlPFQ+KTogVCB8IG51bGwge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tZXNzYWdlcy5maW5kSW5kZXgocHJlZGljYXRlKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuc3BsaWNlKGluZGV4LCAxKVswXTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcG9sbFJlY2VpdmUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaXNQb2xsaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc1BvbGxpbmcgPSB0cnVlO1xuICAgIHRoaXMucG9sbFByb21pc2UgPSB0aGlzLmRvUG9sbFJlY2VpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5wb2xsUHJvbWlzZTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZG9Qb2xsUmVjZWl2ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKHRoaXMuaXNQb2xsaW5nKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLnJlY2VpdmVEZWxlZ2F0ZSgpO1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMubm90aWZ5RW5kT2ZTdHJlYW0oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vdGlmeVJlY2VpdmVyKG1lc3NhZ2UpO1xuICAgICAgICBpZiAodGhpcy53YWl0aW5nUmVjZWl2ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubm90aWZ5RXJyb3IoZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzUG9sbGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5wb2xsUHJvbWlzZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBub3RpZnlFcnJvcihlcnJvcjogRXJyb3IpOiB2b2lkIHtcbiAgICB3aGlsZSAodGhpcy53YWl0aW5nUmVjZWl2ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IFtfcHJlZGljYXRlLCBbX3Jlc29sdmUsIHJlamVjdF0sIF9jb250cm9sbGVyXSA9XG4gICAgICAgIHRoaXMud2FpdGluZ1JlY2VpdmVycy5zaGlmdCgpITtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBub3RpZnlFbmRPZlN0cmVhbSgpOiB2b2lkIHtcbiAgICB3aGlsZSAodGhpcy53YWl0aW5nUmVjZWl2ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IFtfcHJlZGljYXRlLCBbcmVzb2x2ZSwgX3JlamVjdF0sIF9jb250cm9sbGVyXSA9XG4gICAgICAgIHRoaXMud2FpdGluZ1JlY2VpdmVycy5zaGlmdCgpITtcbiAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG5vdGlmeVJlY2VpdmVyKG1lc3NhZ2U6IFQpOiB2b2lkIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMud2FpdGluZ1JlY2VpdmVycy5maW5kSW5kZXgoXG4gICAgICAoW3ByZWRpY2F0ZSwgW19yZXNvbHZlLCBfcmVqZWN0XSwgX2NvbnRyb2xsZXJdKSA9PiBwcmVkaWNhdGUobWVzc2FnZSksXG4gICAgKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aGlzLnB1c2hCYWNrKG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IFtfcHJlZGljYXRlLCBbcmVzb2x2ZSwgX3JlamVjdF0sIF9jb250cm9sbGVyXSA9XG4gICAgICB0aGlzLndhaXRpbmdSZWNlaXZlcnMuc3BsaWNlKGluZGV4LCAxKVswXTtcbiAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICB9XG5cbiAgcXVldWVkTWVzc2FnZUNvdW50KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMubGVuZ3RoO1xuICB9XG5cbiAgcmVjZWl2ZShwcmVkaWNhdGU6IFByZWRpY2F0ZTxUPiwgYWJvcnQ/OiBBYm9ydENvbnRyb2xsZXIpOiBQcm9taXNlPFQgfCBudWxsPiB7XG4gICAgY29uc3QgZm91bmRNZXNzYWdlID0gdGhpcy5maW5kQW5kUmVtb3ZlKHByZWRpY2F0ZSk7XG4gICAgaWYgKGZvdW5kTWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmb3VuZE1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxUIHwgbnVsbD4oYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy53YWl0aW5nUmVjZWl2ZXJzLnB1c2goW1xuICAgICAgICBwcmVkaWNhdGUsXG4gICAgICAgIFtyZXNvbHZlLCByZWplY3RdLFxuICAgICAgICBhYm9ydCB8fCBuZXcgQWJvcnRDb250cm9sbGVyKCksXG4gICAgICBdKTtcblxuICAgICAgYXdhaXQgdGhpcy5wb2xsUmVjZWl2ZSgpO1xuICAgIH0pO1xuICB9XG59XG5leHBvcnQgY2xhc3MgTWVzc2FnZVF1ZXVlV2l0aEVycm9yPFQ+IGV4dGVuZHMgTWVzc2FnZVF1ZXVlPFQ+IHtcbiAgcHJpdmF0ZSBlcnJvcj86IFQgPSB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcmVjZWl2ZURlbGVnYXRlOiBSZWNlaXZlRnVuY3Rpb248VD4sXG4gICAgcHJpdmF0ZSBlcnJvclByZWRpY2F0ZTogKG1lc3NhZ2U6IFQpID0+IGJvb2xlYW4sXG4gICkge1xuICAgIHN1cGVyKHJlY2VpdmVEZWxlZ2F0ZSk7XG4gIH1cblxuICBwcml2YXRlIG5vdGlmeUVycm9yTWVzc2FnZShtZXNzYWdlOiBUKTogdm9pZCB7XG4gICAgd2hpbGUgKHRoaXMud2FpdGluZ1JlY2VpdmVycy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBbXywgW3Jlc29sdmUsIF9yZWplY3RdXSA9IHRoaXMud2FpdGluZ1JlY2VpdmVycy5zaGlmdCgpITtcbiAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG5vdGlmeVJlY2VpdmVyKG1lc3NhZ2U6IFQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5lcnJvclByZWRpY2F0ZShtZXNzYWdlKSkge1xuICAgICAgdGhpcy5lcnJvciA9IG1lc3NhZ2U7XG4gICAgICB0aGlzLm5vdGlmeUVycm9yTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLndhaXRpbmdSZWNlaXZlcnMuZmluZEluZGV4KFxuICAgICAgKFtwcmVkaWNhdGUsIFtfcmVzb2x2ZSwgX3JlamVjdF0sIF9jb250cm9sbGVyXSkgPT4gcHJlZGljYXRlKG1lc3NhZ2UpLFxuICAgICk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhpcy5wdXNoQmFjayhtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBbX3ByZWRpY2F0ZSwgW3Jlc29sdmUsIF9yZWplY3RdLCBfY29udHJvbGxlcl0gPVxuICAgICAgdGhpcy53YWl0aW5nUmVjZWl2ZXJzLnNwbGljZShpbmRleCwgMSlbMF07XG4gICAgcmVzb2x2ZShtZXNzYWdlKTtcbiAgfVxuXG4gIGFzeW5jIHJlY2VpdmUocHJlZGljYXRlOiAobWVzc2FnZTogVCkgPT4gYm9vbGVhbik6IFByb21pc2U8VCB8IG51bGw+IHtcbiAgICBpZiAodGhpcy5lcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcnJvcjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHN1cGVyLnJlY2VpdmUoXG4gICAgICAobWVzc2FnZSkgPT4gcHJlZGljYXRlKG1lc3NhZ2UpIHx8IHRoaXMuZXJyb3JQcmVkaWNhdGUobWVzc2FnZSksXG4gICAgKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2hhcmVkRW5kUXVldWU8VD4ge1xuICBwcml2YXRlIHF1ZXVlOiBUW10gPSBbXTtcbiAgcHJpdmF0ZSBsb2NrOiBQcm9taXNlPHZvaWQ+ID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWNlaXZlRGVsZWdhdGU6ICgpID0+IFByb21pc2U8VD4sXG4gICAgcHJpdmF0ZSBlcnJvclByZWRpY2F0ZTogKG1lc3NhZ2U6IFQpID0+IGJvb2xlYW4sXG4gICAgcHJpdmF0ZSBlbmRQcmVkaWNhdGU6IChtZXNzYWdlOiBUKSA9PiBib29sZWFuLFxuICApIHt9XG5cbiAgYXN5bmMgcmVjZWl2ZShwcmVkaWNhdGU6IChtZXNzYWdlOiBUKSA9PiBib29sZWFuKTogUHJvbWlzZTxUPiB7XG4gICAgY29uc3QgcmVsZWFzZSA9IGF3YWl0IHRoaXMuYWNxdWlyZUxvY2soKTtcbiAgICB0cnkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLnF1ZXVlW2ldO1xuICAgICAgICBpZiAocHJlZGljYXRlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgdGhpcy5xdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5lbmRQcmVkaWNhdGUobWVzc2FnZSkpIHtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYXdhaXQgdGhpcy5yZWNlaXZlRGVsZWdhdGUoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1lc3NhZ2UgPT09IG51bGwgfHxcbiAgICAgICAgICB0aGlzLmVycm9yUHJlZGljYXRlKG1lc3NhZ2UpIHx8XG4gICAgICAgICAgcHJlZGljYXRlKG1lc3NhZ2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVuZFByZWRpY2F0ZShtZXNzYWdlKSkge1xuICAgICAgICAgIHRoaXMucXVldWUucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlbGVhc2UoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGFjcXVpcmVMb2NrKCk6IFByb21pc2U8KCkgPT4gdm9pZD4ge1xuICAgIGxldCByZWxlYXNlOiAoKSA9PiB2b2lkO1xuICAgIGNvbnN0IG5ld0xvY2sgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgcmVsZWFzZSA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgY29uc3Qgb2xkTG9jayA9IHRoaXMubG9jaztcbiAgICB0aGlzLmxvY2sgPSBuZXdMb2NrO1xuICAgIGF3YWl0IG9sZExvY2s7XG4gICAgcmV0dXJuIHJlbGVhc2UhO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmRvbVZhbHVlcyhhcnJheTogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xuICB9IGVsc2UgaWYgKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB3aW5kb3cuY3J5cHRvICYmXG4gICAgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXNcbiAgKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgYXZhaWxhYmxlLlwiKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJZChwcmVmaXg6IHN0cmluZywgbGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIGdldFJhbmRvbVZhbHVlcyhhcnJheSk7XG4gIGNvbnN0IGJhc2U2NCA9IGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5hcnJheSkpXG4gICAgLnJlcGxhY2UoL1xcKy9nLCBcIi1cIilcbiAgICAucmVwbGFjZSgvXFwvL2csIFwiX1wiKVxuICAgIC5yZXBsYWNlKC89L2csIFwiXCIpO1xuXG4gIHJldHVybiBgJHtwcmVmaXh9LSR7YmFzZTY0fWAuc2xpY2UoMCwgbGVuZ3RoKTtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBpc1NlcnZlck1lc3NhZ2VUeXBlIH0gZnJvbSBcIi4vbW9kZWwtdXRpbHNcIjtcbmltcG9ydCB7XG4gIElucHV0QXVkaW9CdWZmZXJTcGVlY2hTdG9wcGVkTWVzc2FnZSxcbiAgSXRlbSxcbiAgSXRlbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uQ29tcGxldGVkTWVzc2FnZSxcbiAgSXRlbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uRmFpbGVkTWVzc2FnZSxcbiAgTWVzc2FnZVJvbGUsXG4gIFJlYWx0aW1lRXJyb3IsXG4gIFJlc3BvbnNlLFxuICBSZXNwb25zZUF1ZGlvRGVsdGFNZXNzYWdlLFxuICBSZXNwb25zZUF1ZGlvRG9uZU1lc3NhZ2UsXG4gIFJlc3BvbnNlQXVkaW9UcmFuc2NyaXB0RGVsdGFNZXNzYWdlLFxuICBSZXNwb25zZUF1ZGlvVHJhbnNjcmlwdERvbmVNZXNzYWdlLFxuICBSZXNwb25zZUNvbnRlbnRQYXJ0QWRkZWRNZXNzYWdlLFxuICBSZXNwb25zZUNvbnRlbnRQYXJ0RG9uZU1lc3NhZ2UsXG4gIFJlc3BvbnNlQ3JlYXRlUGFyYW1zLFxuICBSZXNwb25zZUZ1bmN0aW9uQ2FsbEl0ZW0sXG4gIFJlc3BvbnNlSXRlbSxcbiAgUmVzcG9uc2VJdGVtQXVkaW9Db250ZW50UGFydCxcbiAgUmVzcG9uc2VJdGVtU3RhdHVzLFxuICBSZXNwb25zZUl0ZW1UZXh0Q29udGVudFBhcnQsXG4gIFJlc3BvbnNlTWVzc2FnZUl0ZW0sXG4gIFJlc3BvbnNlU3RhdHVzLFxuICBSZXNwb25zZVN0YXR1c0RldGFpbHMsXG4gIFNlcnZlck1lc3NhZ2VUeXBlLFxuICBTZXNzaW9uLFxuICBTZXNzaW9uVXBkYXRlUGFyYW1zLFxuICBVc2FnZSxcbiAgVXNlck1lc3NhZ2VUeXBlLFxufSBmcm9tIFwiLi9tb2RlbHNcIjtcbmltcG9ydCB7XG4gIHZhbGlkYXRpb25FcnJvcixcbiAgdmFsaWRhdGlvblN1Y2Nlc3MsXG4gIFdlYlNvY2tldENsaWVudCxcbn0gZnJvbSBcIi4vdXRpbC93ZWJzb2NrZXQtY2xpZW50XCI7XG5pbXBvcnQgeyBNZXNzYWdlRXZlbnQgfSBmcm9tIFwiLi91dGlsL3dlYnNvY2tldFwiO1xuaW1wb3J0IHtcbiAgaXNDcmVkZW50aWFsLFxuICBpc0tleUNyZWRlbnRpYWwsXG4gIEtleUNyZWRlbnRpYWwsXG4gIFRva2VuQ3JlZGVudGlhbCxcbn0gZnJvbSBcIi4vdXRpbC9hdXRoXCI7XG5pbXBvcnQge1xuICBDb25uZWN0aW9uU2V0dGluZ3MsXG4gIGlzUlRBenVyZU9wZW5BSU9wdGlvbnMsXG4gIGlzUlRPcGVuQUlPcHRpb25zLFxuICBpc1JUVm9pY2VBZ2VudE9wdGlvbnMsXG4gIFJUQXp1cmVPcGVuQUlPcHRpb25zLFxuICBSVE9wZW5BSU9wdGlvbnMsXG4gIFJUVm9pY2VBZ2VudE9wdGlvbnMsXG59IGZyb20gXCIuL3V0aWwvaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHtcbiAgYXp1cmVPcGVuQUlTZXR0aW5ncyxcbiAgb3BlbkFJU2V0dGluZ3MsXG4gIHZvaWNlQWdlbnRTZXR0aW5ncyxcbn0gZnJvbSBcIi4vdXRpbC9jb25uZWN0aW9uLXNldHRpbmdzXCI7XG5pbXBvcnQgeyBNZXNzYWdlUXVldWVXaXRoRXJyb3IsIFNoYXJlZEVuZFF1ZXVlIH0gZnJvbSBcIi4vdXRpbC9tZXNzYWdlX3F1ZXVlXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSBcIi4vdXRpbC9jcnlwdG9cIjtcblxuZXhwb3J0IGNsYXNzIExvd0xldmVsUlRDbGllbnQge1xuICBwdWJsaWMgcmVxdWVzdElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgY2xpZW50OiBXZWJTb2NrZXRDbGllbnQ8VXNlck1lc3NhZ2VUeXBlLCBTZXJ2ZXJNZXNzYWdlVHlwZT47XG5cbiAgcHJpdmF0ZSBnZXRXZWJzb2NrZXQoXG4gICAgc2V0dGluZ3M6IENvbm5lY3Rpb25TZXR0aW5ncyxcbiAgKTogV2ViU29ja2V0Q2xpZW50PFVzZXJNZXNzYWdlVHlwZSwgU2VydmVyTWVzc2FnZVR5cGU+IHtcbiAgICBjb25zdCBoYW5kbGVyID0ge1xuICAgICAgdmFsaWRhdGU6IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiB2YWxpZGF0aW9uRXJyb3I8U2VydmVyTWVzc2FnZVR5cGU+KFxuICAgICAgICAgICAgbmV3IEVycm9yKFwiSW52YWxpZCBtZXNzYWdlIHR5cGVcIiksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEgYXMgc3RyaW5nKTtcbiAgICAgICAgICBpZiAoaXNTZXJ2ZXJNZXNzYWdlVHlwZShkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRpb25TdWNjZXNzKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsaWRhdGlvbkVycm9yPFNlcnZlck1lc3NhZ2VUeXBlPihcbiAgICAgICAgICAgIG5ldyBFcnJvcihcIkludmFsaWQgbWVzc2FnZSB0eXBlXCIpLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbGlkYXRpb25FcnJvcjxTZXJ2ZXJNZXNzYWdlVHlwZT4oXG4gICAgICAgICAgICBuZXcgRXJyb3IoXCJJbnZhbGlkIEpTT04gbWVzc2FnZVwiKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2VyaWFsaXplOiAobWVzc2FnZTogVXNlck1lc3NhZ2VUeXBlKSA9PiBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBXZWJTb2NrZXRDbGllbnQ8VXNlck1lc3NhZ2VUeXBlLCBTZXJ2ZXJNZXNzYWdlVHlwZT4oXG4gICAgICBzZXR0aW5ncyxcbiAgICAgIGhhbmRsZXIsXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNyZWRlbnRpYWw6IEtleUNyZWRlbnRpYWwsIG9wdGlvbnM6IFJUT3BlbkFJT3B0aW9ucyk7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHVyaTogVVJMLFxuICAgIGNyZWRlbnRpYWw6IEtleUNyZWRlbnRpYWwgfCBUb2tlbkNyZWRlbnRpYWwsXG4gICAgb3B0aW9uczogUlRBenVyZU9wZW5BSU9wdGlvbnMgfCBSVFZvaWNlQWdlbnRPcHRpb25zLFxuICApO1xuICBjb25zdHJ1Y3RvcihcbiAgICB1cmlPckNyZWRlbnRpYWw6IFVSTCB8IEtleUNyZWRlbnRpYWwsXG4gICAgY3JlZGVudGlhbE9yT3B0aW9uczogS2V5Q3JlZGVudGlhbCB8IFRva2VuQ3JlZGVudGlhbCB8IFJUT3BlbkFJT3B0aW9ucyB8IFJUVm9pY2VBZ2VudE9wdGlvbnMsXG4gICAgb3B0aW9ucz86IFJUQXp1cmVPcGVuQUlPcHRpb25zIHwgUlRWb2ljZUFnZW50T3B0aW9ucyxcbiAgKSB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSAoKCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBpc0tleUNyZWRlbnRpYWwodXJpT3JDcmVkZW50aWFsKSAmJlxuICAgICAgICBpc1JUT3BlbkFJT3B0aW9ucyhjcmVkZW50aWFsT3JPcHRpb25zKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBvcGVuQUlTZXR0aW5ncyh1cmlPckNyZWRlbnRpYWwsIGNyZWRlbnRpYWxPck9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgaXNDcmVkZW50aWFsKGNyZWRlbnRpYWxPck9wdGlvbnMpICYmXG4gICAgICAgIGlzUlRBenVyZU9wZW5BSU9wdGlvbnMob3B0aW9ucylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gYXp1cmVPcGVuQUlTZXR0aW5ncyhcbiAgICAgICAgICB1cmlPckNyZWRlbnRpYWwgYXMgVVJMLFxuICAgICAgICAgIGNyZWRlbnRpYWxPck9wdGlvbnMsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGlzQ3JlZGVudGlhbChjcmVkZW50aWFsT3JPcHRpb25zKSAmJlxuICAgICAgICBpc1JUVm9pY2VBZ2VudE9wdGlvbnMob3B0aW9ucylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdm9pY2VBZ2VudFNldHRpbmdzKFxuICAgICAgICAgIHVyaU9yQ3JlZGVudGlhbCBhcyBVUkwsXG4gICAgICAgICAgY3JlZGVudGlhbE9yT3B0aW9ucyxcbiAgICAgICAgICBvcHRpb25zIGFzIFJUVm9pY2VBZ2VudE9wdGlvbnMsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBpbml0aWFsaXplIHRoZSBSZWFsdGltZSBjbGllbnRcIixcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIHRoaXMucmVxdWVzdElkID0gc2V0dGluZ3MucmVxdWVzdElkO1xuICAgIHRoaXMuY2xpZW50ID0gdGhpcy5nZXRXZWJzb2NrZXQoc2V0dGluZ3MpO1xuICB9XG5cbiAgYXN5bmMgKm1lc3NhZ2VzKCk6IEFzeW5jSXRlcmFibGU8U2VydmVyTWVzc2FnZVR5cGU+IHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IG1lc3NhZ2Ugb2YgdGhpcy5jbGllbnQpIHtcbiAgICAgIHlpZWxkIG1lc3NhZ2U7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc2VuZChtZXNzYWdlOiBVc2VyTWVzc2FnZVR5cGUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5zZW5kKG1lc3NhZ2UpO1xuICB9XG5cbiAgYXN5bmMgY2xvc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5jbGllbnQuY2xvc2UoKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUlRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlcnJvckRldGFpbHM6IFJlYWx0aW1lRXJyb3IpIHtcbiAgICBzdXBlcihlcnJvckRldGFpbHMubWVzc2FnZSk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFJURXJyb3IucHJvdG90eXBlKTtcbiAgfVxuXG4gIGdldCBjb2RlKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3JEZXRhaWxzLmNvZGU7XG4gIH1cblxuICBnZXQgcGFyYW0oKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5lcnJvckRldGFpbHMucGFyYW07XG4gIH1cblxuICBnZXQgZXZlbnRJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmVycm9yRGV0YWlscy5ldmVudF9pZDtcbiAgfVxufVxuXG50eXBlIE9wdGlvbmFsPFQ+ID0gVCB8IHVuZGVmaW5lZDtcblxuY2xhc3MgUlRJbnB1dEF1ZGlvSXRlbSB7XG4gIHB1YmxpYyB0eXBlOiBcImlucHV0X2F1ZGlvXCIgPSBcImlucHV0X2F1ZGlvXCI7XG4gIHB1YmxpYyBhdWRpb0VuZE1pbGxpczogT3B0aW9uYWw8bnVtYmVyPiA9IHVuZGVmaW5lZDtcbiAgcHVibGljIHRyYW5zY3JpcHRpb246IE9wdGlvbmFsPHN0cmluZz4gPSB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSB3YWl0UHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IGlkOiBzdHJpbmcsXG4gICAgcHVibGljIGF1ZGlvU3RhcnRNaWxsaXM6IE9wdGlvbmFsPG51bWJlcj4sXG4gICAgcHJpdmF0ZSBoYXNUcmFuc2NyaXB0aW9uOiBib29sZWFuLFxuICAgIHByaXZhdGUgcXVldWU6IE1lc3NhZ2VRdWV1ZVdpdGhFcnJvcjxTZXJ2ZXJNZXNzYWdlVHlwZT4sXG4gICkgeyB9XG5cbiAgc3RhdGljIGNyZWF0ZShcbiAgICBpZDogc3RyaW5nLFxuICAgIGF1ZGlvU3RhcnRNaWxsaXM6IE9wdGlvbmFsPG51bWJlcj4sXG4gICAgaGFzVHJhbnNjcmlwdGlvbjogYm9vbGVhbixcbiAgICBxdWV1ZTogTWVzc2FnZVF1ZXVlV2l0aEVycm9yPFNlcnZlck1lc3NhZ2VUeXBlPixcbiAgKTogUlRJbnB1dEF1ZGlvSXRlbSB7XG4gICAgcmV0dXJuIG5ldyBSVElucHV0QXVkaW9JdGVtKGlkLCBhdWRpb1N0YXJ0TWlsbGlzLCBoYXNUcmFuc2NyaXB0aW9uLCBxdWV1ZSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHdhaXQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgaXRlbUlkVmFsaWRNZXNzYWdlID0gKFxuICAgICAgbWVzc2FnZTogU2VydmVyTWVzc2FnZVR5cGUsXG4gICAgKTogbWVzc2FnZSBpc1xuICAgICAgfCBJbnB1dEF1ZGlvQnVmZmVyU3BlZWNoU3RvcHBlZE1lc3NhZ2VcbiAgICAgIHwgSXRlbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uQ29tcGxldGVkTWVzc2FnZVxuICAgICAgfCBJdGVtSW5wdXRBdWRpb1RyYW5zY3JpcHRpb25GYWlsZWRNZXNzYWdlID0+XG4gICAgICBbXG4gICAgICAgIFwiaW5wdXRfYXVkaW9fYnVmZmVyLnNwZWVjaF9zdG9wcGVkXCIsXG4gICAgICAgIFwiY29udmVyc2F0aW9uLml0ZW0uaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbi5jb21wbGV0ZWRcIixcbiAgICAgICAgXCJjb252ZXJzYXRpb24uaXRlbS5pbnB1dF9hdWRpb190cmFuc2NyaXB0aW9uLmZhaWxlZFwiLFxuICAgICAgXS5pbmNsdWRlcyhtZXNzYWdlLnR5cGUpO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLnF1ZXVlLnJlY2VpdmUoXG4gICAgICAgIChtKSA9PlxuICAgICAgICAgIChpdGVtSWRWYWxpZE1lc3NhZ2UobSkgJiYgbS5pdGVtX2lkID09IHRoaXMuaWQpIHx8XG4gICAgICAgICAgKG0udHlwZSA9PT0gXCJjb252ZXJzYXRpb24uaXRlbS5jcmVhdGVkXCIgJiYgbS5pdGVtLmlkID09IHRoaXMuaWQpLFxuICAgICAgKTtcbiAgICAgIGlmIChtZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJURXJyb3IobWVzc2FnZS5lcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJpbnB1dF9hdWRpb19idWZmZXIuc3BlZWNoX3N0b3BwZWRcIikge1xuICAgICAgICB0aGlzLmF1ZGlvRW5kTWlsbGlzID0gbWVzc2FnZS5hdWRpb19lbmRfbXM7XG4gICAgICAgIGlmICghdGhpcy5oYXNUcmFuc2NyaXB0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBtZXNzYWdlLnR5cGUgPT09IFwiY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlZFwiICYmXG4gICAgICAgICF0aGlzLmhhc1RyYW5zY3JpcHRpb25cbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBtZXNzYWdlLnR5cGUgPT09IFwiY29udmVyc2F0aW9uLml0ZW0uaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbi5jb21wbGV0ZWRcIlxuICAgICAgKSB7XG4gICAgICAgIHRoaXMudHJhbnNjcmlwdGlvbiA9IG1lc3NhZ2UudHJhbnNjcmlwdDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgbWVzc2FnZS50eXBlID09PSBcImNvbnZlcnNhdGlvbi5pdGVtLmlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24uZmFpbGVkXCJcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgUlRFcnJvcihtZXNzYWdlLmVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3YWl0Rm9yQ29tcGxldGlvbigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMud2FpdFByb21pc2UpIHtcbiAgICAgIHRoaXMud2FpdFByb21pc2UgPSB0aGlzLndhaXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FpdFByb21pc2U7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgeyBSVElucHV0QXVkaW9JdGVtIH07XG5cbi8qIFRPRE86IE1vdmUgdG8gUEFMIHNvIHdlIHVzZSBCdWZmZXIuZnJvbSBpbiBOb2RlICovXG5mdW5jdGlvbiBkZWNvZGVCYXNlNjQoYmFzZTY0OiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjQpO1xuICBjb25zdCBsZW5ndGggPSBiaW5hcnlTdHJpbmcubGVuZ3RoO1xuICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdWludDhBcnJheVtpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICB9XG5cbiAgcmV0dXJuIHVpbnQ4QXJyYXk7XG59XG5cbmNsYXNzIFJUQXVkaW9Db250ZW50IHtcbiAgcHVibGljIHR5cGU6IFwiYXVkaW9cIiA9IFwiYXVkaW9cIjtcblxuICBwdWJsaWMgaXRlbUlkOiBzdHJpbmc7XG4gIHB1YmxpYyBjb250ZW50SW5kZXg6IG51bWJlcjtcbiAgcHJpdmF0ZSBwYXJ0OiBSZXNwb25zZUl0ZW1BdWRpb0NvbnRlbnRQYXJ0O1xuICBwcml2YXRlIGNvbnRlbnRRdWV1ZTogU2hhcmVkRW5kUXVldWU8U2VydmVyTWVzc2FnZVR5cGUgfCBudWxsPjtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U6IFJlc3BvbnNlQ29udGVudFBhcnRBZGRlZE1lc3NhZ2UsXG4gICAgcHJpdmF0ZSBxdWV1ZTogTWVzc2FnZVF1ZXVlV2l0aEVycm9yPFNlcnZlck1lc3NhZ2VUeXBlPixcbiAgKSB7XG4gICAgdGhpcy5pdGVtSWQgPSBtZXNzYWdlLml0ZW1faWQ7XG4gICAgdGhpcy5jb250ZW50SW5kZXggPSBtZXNzYWdlLmNvbnRlbnRfaW5kZXg7XG4gICAgaWYgKG1lc3NhZ2UucGFydC50eXBlICE9PSBcImF1ZGlvXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgcGFydCB0eXBlXCIpO1xuICAgIH1cbiAgICB0aGlzLnBhcnQgPSBtZXNzYWdlLnBhcnQ7XG4gICAgdGhpcy5jb250ZW50UXVldWUgPSBuZXcgU2hhcmVkRW5kUXVldWUoXG4gICAgICAoKSA9PiB0aGlzLnJlY2VpdmVDb250ZW50KCksXG4gICAgICAobSkgPT4gbSAhPT0gbnVsbCAmJiBtLnR5cGUgPT09IFwiZXJyb3JcIixcbiAgICAgIChtKSA9PiBtICE9PSBudWxsICYmIG0udHlwZSA9PT0gXCJyZXNwb25zZS5jb250ZW50X3BhcnQuZG9uZVwiLFxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlKFxuICAgIG1lc3NhZ2U6IFJlc3BvbnNlQ29udGVudFBhcnRBZGRlZE1lc3NhZ2UsXG4gICAgcXVldWU6IE1lc3NhZ2VRdWV1ZVdpdGhFcnJvcjxTZXJ2ZXJNZXNzYWdlVHlwZT4sXG4gICk6IFJUQXVkaW9Db250ZW50IHtcbiAgICByZXR1cm4gbmV3IFJUQXVkaW9Db250ZW50KG1lc3NhZ2UsIHF1ZXVlKTtcbiAgfVxuXG4gIGdldCB0cmFuc2NyaXB0KCk6IE9wdGlvbmFsPHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLnBhcnQudHJhbnNjcmlwdDtcbiAgfVxuXG4gIHByaXZhdGUgcmVjZWl2ZUNvbnRlbnQoKTogUHJvbWlzZTxTZXJ2ZXJNZXNzYWdlVHlwZSB8IG51bGw+IHtcbiAgICBmdW5jdGlvbiBpc1ZhbGlkTWVzc2FnZShcbiAgICAgIG06IFNlcnZlck1lc3NhZ2VUeXBlLFxuICAgICk6IG0gaXNcbiAgICAgIHwgUmVzcG9uc2VBdWRpb0RlbHRhTWVzc2FnZVxuICAgICAgfCBSZXNwb25zZUF1ZGlvRG9uZU1lc3NhZ2VcbiAgICAgIHwgUmVzcG9uc2VBdWRpb1RyYW5zY3JpcHREZWx0YU1lc3NhZ2VcbiAgICAgIHwgUmVzcG9uc2VBdWRpb1RyYW5zY3JpcHREb25lTWVzc2FnZVxuICAgICAgfCBSZXNwb25zZUNvbnRlbnRQYXJ0RG9uZU1lc3NhZ2Uge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgXCJyZXNwb25zZS5hdWRpby5kZWx0YVwiLFxuICAgICAgICBcInJlc3BvbnNlLmF1ZGlvLmRvbmVcIixcbiAgICAgICAgXCJyZXNwb25zZS5hdWRpb190cmFuc2NyaXB0LmRlbHRhXCIsXG4gICAgICAgIFwicmVzcG9uc2UuYXVkaW9fdHJhbnNjcmlwdC5kb25lXCIsXG4gICAgICAgIFwicmVzcG9uc2UuY29udGVudF9wYXJ0LmRvbmVcIixcbiAgICAgIF0uaW5jbHVkZXMobS50eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucXVldWUucmVjZWl2ZShcbiAgICAgIChtKSA9PlxuICAgICAgICBpc1ZhbGlkTWVzc2FnZShtKSAmJlxuICAgICAgICBtLml0ZW1faWQgPT09IHRoaXMuaXRlbUlkICYmXG4gICAgICAgIG0uY29udGVudF9pbmRleCA9PT0gdGhpcy5jb250ZW50SW5kZXgsXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jICphdWRpb0NodW5rcygpOiBBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+IHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHRoaXMuY29udGVudFF1ZXVlLnJlY2VpdmUoXG4gICAgICAgIChtKSA9PlxuICAgICAgICAgIG0gIT09IG51bGwgJiZcbiAgICAgICAgICBbXCJyZXNwb25zZS5hdWRpby5kZWx0YVwiLCBcInJlc3BvbnNlLmF1ZGlvLmRvbmVcIl0uaW5jbHVkZXMobS50eXBlKSxcbiAgICAgICk7XG4gICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJURXJyb3IobWVzc2FnZS5lcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJyZXNwb25zZS5jb250ZW50X3BhcnQuZG9uZVwiKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnQudHlwZSAhPT0gXCJhdWRpb1wiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBwYXJ0IHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJ0ID0gbWVzc2FnZS5wYXJ0O1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcInJlc3BvbnNlLmF1ZGlvLmRlbHRhXCIpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gZGVjb2RlQmFzZTY0KG1lc3NhZ2UuZGVsdGEpO1xuICAgICAgICB5aWVsZCBidWZmZXI7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJyZXNwb25zZS5hdWRpby5kb25lXCIpIHtcbiAgICAgICAgLy8gV2UgYXJlIHNraXBwaW5nIHRoaXMgYXMgaXQncyBpbmZvcm1hdGlvbiBpcyBhbHJlYWR5IHByb3ZpZGVkIGJ5ICdyZXNwb25zZS5jb250ZW50X3BhcnQuZG9uZSdcbiAgICAgICAgLy8gYW5kIHRoYXQgaXMgYSBiZXR0ZXIgc2lnbmFsIHRvIGVuZCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jICp0cmFuc2NyaXB0Q2h1bmtzKCk6IEFzeW5jSXRlcmFibGU8c3RyaW5nPiB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLmNvbnRlbnRRdWV1ZS5yZWNlaXZlKFxuICAgICAgICAobSkgPT5cbiAgICAgICAgICBtICE9PSBudWxsICYmXG4gICAgICAgICAgW1xuICAgICAgICAgICAgXCJyZXNwb25zZS5hdWRpb190cmFuc2NyaXB0LmRlbHRhXCIsXG4gICAgICAgICAgICBcInJlc3BvbnNlLmF1ZGlvX3RyYW5zY3JpcHQuZG9uZVwiLFxuICAgICAgICAgIF0uaW5jbHVkZXMobS50eXBlKSxcbiAgICAgICk7XG4gICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJURXJyb3IobWVzc2FnZS5lcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJyZXNwb25zZS5jb250ZW50X3BhcnQuZG9uZVwiKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnQudHlwZSAhPT0gXCJhdWRpb1wiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBwYXJ0IHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJ0ID0gbWVzc2FnZS5wYXJ0O1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcInJlc3BvbnNlLmF1ZGlvX3RyYW5zY3JpcHQuZGVsdGFcIikge1xuICAgICAgICB5aWVsZCBtZXNzYWdlLmRlbHRhO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwicmVzcG9uc2UuYXVkaW9fdHJhbnNjcmlwdC5kb25lXCIpIHtcbiAgICAgICAgLy8gV2UgYXJlIHNraXBwaW5nIHRoaXMgYXMgaXQncyBpbmZvcm1hdGlvbiBpcyBhbHJlYWR5IHByb3ZpZGVkIGJ5ICdyZXNwb25zZS5jb250ZW50X3BhcnQuZG9uZSdcbiAgICAgICAgLy8gYW5kIHRoYXQgaXMgYSBiZXR0ZXIgc2lnbmFsIHRvIGVuZCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgdHlwZSB7IFJUQXVkaW9Db250ZW50IH07XG5cbmNsYXNzIFJUVGV4dENvbnRlbnQge1xuICBwdWJsaWMgdHlwZTogXCJ0ZXh0XCIgPSBcInRleHRcIjtcblxuICBwdWJsaWMgaXRlbUlkOiBzdHJpbmc7XG4gIHB1YmxpYyBjb250ZW50SW5kZXg6IG51bWJlcjtcbiAgcHJpdmF0ZSBwYXJ0OiBSZXNwb25zZUl0ZW1UZXh0Q29udGVudFBhcnQ7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlOiBSZXNwb25zZUNvbnRlbnRQYXJ0QWRkZWRNZXNzYWdlLFxuICAgIHByaXZhdGUgcXVldWU6IE1lc3NhZ2VRdWV1ZVdpdGhFcnJvcjxTZXJ2ZXJNZXNzYWdlVHlwZT4sXG4gICkge1xuICAgIHRoaXMuaXRlbUlkID0gbWVzc2FnZS5pdGVtX2lkO1xuICAgIHRoaXMuY29udGVudEluZGV4ID0gbWVzc2FnZS5jb250ZW50X2luZGV4O1xuICAgIGlmIChtZXNzYWdlLnBhcnQudHlwZSAhPT0gXCJ0ZXh0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgcGFydCB0eXBlXCIpO1xuICAgIH1cbiAgICB0aGlzLnBhcnQgPSBtZXNzYWdlLnBhcnQ7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlKFxuICAgIG1lc3NhZ2U6IFJlc3BvbnNlQ29udGVudFBhcnRBZGRlZE1lc3NhZ2UsXG4gICAgcXVldWU6IE1lc3NhZ2VRdWV1ZVdpdGhFcnJvcjxTZXJ2ZXJNZXNzYWdlVHlwZT4sXG4gICkge1xuICAgIHJldHVybiBuZXcgUlRUZXh0Q29udGVudChtZXNzYWdlLCBxdWV1ZSk7XG4gIH1cblxuICBnZXQgdGV4dCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnBhcnQudGV4dDtcbiAgfVxuXG4gIGFzeW5jICp0ZXh0Q2h1bmtzKCk6IEFzeW5jSXRlcmFibGU8c3RyaW5nPiB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLnF1ZXVlLnJlY2VpdmUoXG4gICAgICAgIChtKSA9PlxuICAgICAgICAgIChtLnR5cGUgPT09IFwicmVzcG9uc2UuY29udGVudF9wYXJ0LmRvbmVcIiB8fFxuICAgICAgICAgICAgbS50eXBlID09PSBcInJlc3BvbnNlLnRleHQuZGVsdGFcIiB8fFxuICAgICAgICAgICAgbS50eXBlID09PSBcInJlc3BvbnNlLnRleHQuZG9uZVwiKSAmJlxuICAgICAgICAgIG0uaXRlbV9pZCA9PT0gdGhpcy5pdGVtSWQgJiZcbiAgICAgICAgICBtLmNvbnRlbnRfaW5kZXggPT09IHRoaXMuY29udGVudEluZGV4LFxuICAgICAgKTtcbiAgICAgIGlmIChtZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICB0aHJvdyBuZXcgUlRFcnJvcihtZXNzYWdlLmVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcInJlc3BvbnNlLmNvbnRlbnRfcGFydC5kb25lXCIpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucGFydC50eXBlICE9PSBcInRleHRcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgcGFydCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFydCA9IG1lc3NhZ2UucGFydDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJyZXNwb25zZS50ZXh0LmRlbHRhXCIpIHtcbiAgICAgICAgeWllbGQgbWVzc2FnZS5kZWx0YTtcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcInJlc3BvbnNlLnRleHQuZG9uZVwiKSB7XG4gICAgICAgIC8vIFdlIGFyZSBza2lwcGluZyB0aGlzIGFzIGl0J3MgaW5mb3JtYXRpb24gaXMgYWxyZWFkeSBwcm92aWRlZCBieSAncmVzcG9uc2UuY29udGVudF9wYXJ0LmRvbmUnXG4gICAgICAgIC8vIGFuZCB0aGF0IGlzIGEgYmV0dGVyIHNpZ25hbCB0byBlbmQgdGhlIGl0ZXJhdGlvblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgeyBSVFRleHRDb250ZW50IH07XG5cbmV4cG9ydCB0eXBlIFJUTWVzc2FnZUNvbnRlbnQgPSBSVEF1ZGlvQ29udGVudCB8IFJUVGV4dENvbnRlbnQ7XG5cbmNsYXNzIFJUTWVzc2FnZUl0ZW0gaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPFJUTWVzc2FnZUNvbnRlbnQ+IHtcbiAgcHVibGljIHR5cGU6IFwibWVzc2FnZVwiID0gXCJtZXNzYWdlXCI7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcmVzcG9uc2VJZDogc3RyaW5nLFxuICAgIHByaXZhdGUgaXRlbTogUmVzcG9uc2VNZXNzYWdlSXRlbSxcbiAgICBwdWJsaWMgcHJldmlvdXNJdGVtSWQ6IE9wdGlvbmFsPHN0cmluZz4sXG4gICAgcHJpdmF0ZSBxdWV1ZTogTWVzc2FnZVF1ZXVlV2l0aEVycm9yPFNlcnZlck1lc3NhZ2VUeXBlPixcbiAgKSB7IH1cblxuICBzdGF0aWMgY3JlYXRlKFxuICAgIHJlc3BvbnNlSWQ6IHN0cmluZyxcbiAgICBpdGVtOiBSZXNwb25zZU1lc3NhZ2VJdGVtLFxuICAgIHByZXZpb3VzSXRlbUlkOiBPcHRpb25hbDxzdHJpbmc+LFxuICAgIHF1ZXVlOiBNZXNzYWdlUXVldWVXaXRoRXJyb3I8U2VydmVyTWVzc2FnZVR5cGU+LFxuICApOiBSVE1lc3NhZ2VJdGVtIHtcbiAgICByZXR1cm4gbmV3IFJUTWVzc2FnZUl0ZW0ocmVzcG9uc2VJZCwgaXRlbSwgcHJldmlvdXNJdGVtSWQsIHF1ZXVlKTtcbiAgfVxuXG4gIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLml0ZW0uaWQhO1xuICB9XG5cbiAgZ2V0IHJvbGUoKTogTWVzc2FnZVJvbGUge1xuICAgIHJldHVybiB0aGlzLml0ZW0ucm9sZTtcbiAgfVxuXG4gIGdldCBzdGF0dXMoKTogUmVzcG9uc2VJdGVtU3RhdHVzIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtLnN0YXR1cztcbiAgfVxuXG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYXdhaXQgdGhpcy5xdWV1ZS5yZWNlaXZlKFxuICAgICAgICAobSkgPT5cbiAgICAgICAgICAobS50eXBlID09PSBcInJlc3BvbnNlLmNvbnRlbnRfcGFydC5hZGRlZFwiICYmIG0uaXRlbV9pZCA9PT0gdGhpcy5pZCkgfHxcbiAgICAgICAgICAobS50eXBlID09PSBcInJlc3BvbnNlLm91dHB1dF9pdGVtLmRvbmVcIiAmJiBtLml0ZW0uaWQgPT09IHRoaXMuaWQpLFxuICAgICAgKTtcbiAgICAgIGlmIChtZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICB0aHJvdyBuZXcgUlRFcnJvcihtZXNzYWdlLmVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcInJlc3BvbnNlLm91dHB1dF9pdGVtLmRvbmVcIikge1xuICAgICAgICBpZiAobWVzc2FnZS5pdGVtLnR5cGUgPT09IFwibWVzc2FnZVwiKSB7XG4gICAgICAgICAgdGhpcy5pdGVtID0gbWVzc2FnZS5pdGVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgaXRlbSB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwicmVzcG9uc2UuY29udGVudF9wYXJ0LmFkZGVkXCIpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucGFydC50eXBlID09PSBcImF1ZGlvXCIpIHtcbiAgICAgICAgICB5aWVsZCBSVEF1ZGlvQ29udGVudC5jcmVhdGUobWVzc2FnZSwgdGhpcy5xdWV1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5wYXJ0LnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgeWllbGQgUlRUZXh0Q29udGVudC5jcmVhdGUobWVzc2FnZSwgdGhpcy5xdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHBhcnQgdHlwZTogJHttZXNzYWdlLnBhcnQudHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG1lc3NhZ2UgdHlwZTogJHttZXNzYWdlLnR5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB0eXBlIHsgUlRNZXNzYWdlSXRlbSB9O1xuXG5jbGFzcyBSVEZ1bmN0aW9uQ2FsbEl0ZW0gaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPHN0cmluZz4ge1xuICBwdWJsaWMgdHlwZTogXCJmdW5jdGlvbl9jYWxsXCIgPSBcImZ1bmN0aW9uX2NhbGxcIjtcbiAgcHJpdmF0ZSBhd2FpdGVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgaXRlcmF0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZXNwb25zZUlkOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSBpdGVtOiBSZXNwb25zZUZ1bmN0aW9uQ2FsbEl0ZW0sXG4gICAgcHVibGljIHByZXZpb3VzSXRlbUlkOiBPcHRpb25hbDxzdHJpbmc+LFxuICAgIHByaXZhdGUgcXVldWU6IE1lc3NhZ2VRdWV1ZVdpdGhFcnJvcjxTZXJ2ZXJNZXNzYWdlVHlwZT4sXG4gICkgeyB9XG5cbiAgc3RhdGljIGNyZWF0ZShcbiAgICByZXNwb25zZUlkOiBzdHJpbmcsXG4gICAgaXRlbTogUmVzcG9uc2VGdW5jdGlvbkNhbGxJdGVtLFxuICAgIHByZXZpb3VzSXRlbUlkOiBPcHRpb25hbDxzdHJpbmc+LFxuICAgIHF1ZXVlOiBNZXNzYWdlUXVldWVXaXRoRXJyb3I8U2VydmVyTWVzc2FnZVR5cGU+LFxuICApOiBSVEZ1bmN0aW9uQ2FsbEl0ZW0ge1xuICAgIHJldHVybiBuZXcgUlRGdW5jdGlvbkNhbGxJdGVtKHJlc3BvbnNlSWQsIGl0ZW0sIHByZXZpb3VzSXRlbUlkLCBxdWV1ZSk7XG4gIH1cblxuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtLmlkITtcbiAgfVxuXG4gIGdldCBmdW5jdGlvbk5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtLm5hbWU7XG4gIH1cblxuICBnZXQgY2FsbElkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbS5jYWxsX2lkO1xuICB9XG5cbiAgZ2V0IGFyZ3VtZW50cygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLml0ZW0uYXJndW1lbnRzO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyAqaW5uZXIoKTogQXN5bmNJdGVyYWJsZTxzdHJpbmc+IHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHRoaXMucXVldWUucmVjZWl2ZShcbiAgICAgICAgKG0pID0+XG4gICAgICAgICAgKChtLnR5cGUgPT0gXCJyZXNwb25zZS5mdW5jdGlvbl9jYWxsX2FyZ3VtZW50cy5kZWx0YVwiIHx8XG4gICAgICAgICAgICBtLnR5cGUgPT0gXCJyZXNwb25zZS5mdW5jdGlvbl9jYWxsX2FyZ3VtZW50cy5kb25lXCIpICYmXG4gICAgICAgICAgICBtLml0ZW1faWQgPT09IHRoaXMuaWQpIHx8XG4gICAgICAgICAgKG0udHlwZSA9PT0gXCJyZXNwb25zZS5vdXRwdXRfaXRlbS5kb25lXCIgJiYgbS5pdGVtLmlkID09PSB0aGlzLmlkKSxcbiAgICAgICk7XG4gICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJURXJyb3IobWVzc2FnZS5lcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJyZXNwb25zZS5vdXRwdXRfaXRlbS5kb25lXCIpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaXRlbS50eXBlID09PSBcImZ1bmN0aW9uX2NhbGxcIikge1xuICAgICAgICAgIHRoaXMuaXRlbSA9IG1lc3NhZ2UuaXRlbTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGl0ZW0gdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwicmVzcG9uc2UuZnVuY3Rpb25fY2FsbF9hcmd1bWVudHMuZGVsdGFcIikge1xuICAgICAgICB5aWVsZCBtZXNzYWdlLmRlbHRhO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwicmVzcG9uc2UuZnVuY3Rpb25fY2FsbF9hcmd1bWVudHMuZG9uZVwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG1lc3NhZ2UgdHlwZTogJHttZXNzYWdlLnR5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTogQXN5bmNJdGVyYXRvcjxzdHJpbmc+IHtcbiAgICBpZiAodGhpcy5hd2FpdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaXRlcmF0ZSBhZnRlciBhd2FpdGluZy5cIik7XG4gICAgfVxuICAgIHRoaXMuaXRlcmF0ZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLmlubmVyKCk7XG4gIH1cblxuICBhc3luYyB3YWl0Rm9yQ29tcGxldGlvbigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5pdGVyYXRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGF3YWl0IGFmdGVyIGl0ZXJhdGluZy5cIik7XG4gICAgfVxuICAgIHRoaXMuYXdhaXRlZCA9IHRydWU7XG4gICAgZm9yIGF3YWl0IChjb25zdCBfIG9mIHRoaXMuaW5uZXIoKSkge1xuICAgICAgLy8gY29uc3VtZSB0aGUgcmVtYWluaW5nIGl0ZW1zXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB0eXBlIHsgUlRGdW5jdGlvbkNhbGxJdGVtIH07XG5cbnR5cGUgUlRPdXRwdXRJdGVtID0gUlRNZXNzYWdlSXRlbSB8IFJURnVuY3Rpb25DYWxsSXRlbTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTWVzc2FnZUl0ZW0oaXRlbTogUlRPdXRwdXRJdGVtKTogaXRlbSBpcyBSVE1lc3NhZ2VJdGVtIHtcbiAgcmV0dXJuIGl0ZW0udHlwZSA9PT0gXCJtZXNzYWdlXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uQ2FsbEl0ZW0oXG4gIGl0ZW06IFJUT3V0cHV0SXRlbSxcbik6IGl0ZW0gaXMgUlRGdW5jdGlvbkNhbGxJdGVtIHtcbiAgcmV0dXJuIGl0ZW0udHlwZSA9PT0gXCJmdW5jdGlvbl9jYWxsXCI7XG59XG5cbmNsYXNzIFJUUmVzcG9uc2UgaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPFJUT3V0cHV0SXRlbT4ge1xuICBwdWJsaWMgdHlwZTogXCJyZXNwb25zZVwiID0gXCJyZXNwb25zZVwiO1xuICBwcml2YXRlIGRvbmU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVzcG9uc2U6IFJlc3BvbnNlLFxuICAgIHByaXZhdGUgcXVldWU6IE1lc3NhZ2VRdWV1ZVdpdGhFcnJvcjxTZXJ2ZXJNZXNzYWdlVHlwZT4sXG4gICAgcHJpdmF0ZSBjbGllbnQ6IExvd0xldmVsUlRDbGllbnQsXG4gICkgeyB9XG5cbiAgc3RhdGljIGNyZWF0ZShcbiAgICByZXNwb25zZTogUmVzcG9uc2UsXG4gICAgcXVldWU6IE1lc3NhZ2VRdWV1ZVdpdGhFcnJvcjxTZXJ2ZXJNZXNzYWdlVHlwZT4sXG4gICAgY2xpZW50OiBMb3dMZXZlbFJUQ2xpZW50LFxuICApOiBSVFJlc3BvbnNlIHtcbiAgICByZXR1cm4gbmV3IFJUUmVzcG9uc2UocmVzcG9uc2UsIHF1ZXVlLCBjbGllbnQpO1xuICB9XG5cbiAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2UuaWQ7XG4gIH1cblxuICBnZXQgc3RhdHVzKCk6IFJlc3BvbnNlU3RhdHVzIHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZS5zdGF0dXM7XG4gIH1cblxuICBnZXQgc3RhdHVzRGV0YWlscygpOiBPcHRpb25hbDxSZXNwb25zZVN0YXR1c0RldGFpbHM+IHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZS5zdGF0dXNfZGV0YWlscztcbiAgfVxuXG4gIGdldCBvdXRwdXQoKTogUmVzcG9uc2VJdGVtW10ge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLm91dHB1dDtcbiAgfVxuXG4gIGdldCB1c2FnZSgpOiBPcHRpb25hbDxVc2FnZT4ge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLnVzYWdlO1xuICB9XG5cbiAgYXN5bmMgY2FuY2VsKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuY2xpZW50LnNlbmQoe1xuICAgICAgdHlwZTogXCJyZXNwb25zZS5jYW5jZWxcIixcbiAgICB9KTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IF8gb2YgdGhpcykge1xuICAgIH1cbiAgICAvLyBjb25zdW1lIHRoZSByZW1haW5pbmcgaXRlbXNcbiAgfVxuXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTogQXN5bmNJdGVyYXRvcjxSVE91dHB1dEl0ZW0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogYXN5bmMgKCk6IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8UlRPdXRwdXRJdGVtPj4gPT4ge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLnF1ZXVlLnJlY2VpdmUoXG4gICAgICAgICAgKG0pID0+XG4gICAgICAgICAgICAobS50eXBlID09PSBcInJlc3BvbnNlLmRvbmVcIiAmJiBtLnJlc3BvbnNlLmlkID09PSB0aGlzLmlkKSB8fFxuICAgICAgICAgICAgKG0udHlwZSA9PT0gXCJyZXNwb25zZS5vdXRwdXRfaXRlbS5hZGRlZFwiICYmXG4gICAgICAgICAgICAgIG0ucmVzcG9uc2VfaWQgPT09IHRoaXMuaWQpLFxuICAgICAgICApO1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgIHRocm93IG5ldyBSVEVycm9yKG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJyZXNwb25zZS5kb25lXCIpIHtcbiAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBtZXNzYWdlLnJlc3BvbnNlO1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwicmVzcG9uc2Uub3V0cHV0X2l0ZW0uYWRkZWRcIikge1xuICAgICAgICAgIGNvbnN0IGNyZWF0ZWRfbWVzc2FnZSA9IGF3YWl0IHRoaXMucXVldWUucmVjZWl2ZShcbiAgICAgICAgICAgIChtKSA9PlxuICAgICAgICAgICAgICBtLnR5cGUgPT09IFwiY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlZFwiICYmXG4gICAgICAgICAgICAgIG0uaXRlbS5pZCA9PT0gbWVzc2FnZS5pdGVtLmlkLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGNyZWF0ZWRfbWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3JlYXRlZF9tZXNzYWdlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJURXJyb3IoY3JlYXRlZF9tZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyZWF0ZWRfbWVzc2FnZS50eXBlID09PSBcImNvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZWRcIikge1xuICAgICAgICAgICAgaWYgKGNyZWF0ZWRfbWVzc2FnZS5pdGVtLnR5cGUgPT09IFwibWVzc2FnZVwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VJdGVtID0gUlRNZXNzYWdlSXRlbS5jcmVhdGUoXG4gICAgICAgICAgICAgICAgdGhpcy5pZCxcbiAgICAgICAgICAgICAgICBjcmVhdGVkX21lc3NhZ2UuaXRlbSxcbiAgICAgICAgICAgICAgICBjcmVhdGVkX21lc3NhZ2UucHJldmlvdXNfaXRlbV9pZCxcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbWVzc2FnZUl0ZW0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNyZWF0ZWRfbWVzc2FnZS5pdGVtLnR5cGUgPT09IFwiZnVuY3Rpb25fY2FsbFwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbEl0ZW0gPSBSVEZ1bmN0aW9uQ2FsbEl0ZW0uY3JlYXRlKFxuICAgICAgICAgICAgICAgIHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgY3JlYXRlZF9tZXNzYWdlLml0ZW0sXG4gICAgICAgICAgICAgICAgY3JlYXRlZF9tZXNzYWdlLnByZXZpb3VzX2l0ZW1faWQsXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGZ1bmN0aW9uQ2FsbEl0ZW0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYFVuZXhwZWN0ZWQgaXRlbSB0eXBlICgke2NyZWF0ZWRfbWVzc2FnZS5pdGVtLnR5cGV9LmAsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBtZXNzYWdlIHR5cGU6ICR7Y3JlYXRlZF9tZXNzYWdlLnR5cGV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBtZXNzYWdlIHR5cGU6ICR7bWVzc2FnZS50eXBlfWApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgeyBSVFJlc3BvbnNlIH07XG5cbmV4cG9ydCBjbGFzcyBSVENsaWVudCB7XG4gIHByaXZhdGUgY2xpZW50OiBMb3dMZXZlbFJUQ2xpZW50O1xuICBwcml2YXRlIG1lc3NhZ2VRdWV1ZTogTWVzc2FnZVF1ZXVlV2l0aEVycm9yPFNlcnZlck1lc3NhZ2VUeXBlPjtcbiAgcHJpdmF0ZSBtZXNzYWdlc0l0ZXJhYmxlOiBBc3luY0l0ZXJhdG9yPFNlcnZlck1lc3NhZ2VUeXBlPjtcbiAgcHVibGljIHNlc3Npb246IFNlc3Npb24gfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBpbml0UHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBpdGVyYXRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihjcmVkZW50aWFsOiBLZXlDcmVkZW50aWFsLCBvcHRpb25zOiBSVE9wZW5BSU9wdGlvbnMpO1xuICBjb25zdHJ1Y3RvcihcbiAgICB1cmk6IFVSTCxcbiAgICBjcmVkZW50aWFsOiBLZXlDcmVkZW50aWFsIHwgVG9rZW5DcmVkZW50aWFsLFxuICAgIG9wdGlvbnM6IFJUQXp1cmVPcGVuQUlPcHRpb25zIHwgUlRWb2ljZUFnZW50T3B0aW9ucyxcbiAgKTtcbiAgY29uc3RydWN0b3IoXG4gICAgdXJpT3JDcmVkZW50aWFsOiBVUkwgfCBLZXlDcmVkZW50aWFsLFxuICAgIGNyZWRlbnRpYWxPck9wdGlvbnM6IEtleUNyZWRlbnRpYWwgfCBUb2tlbkNyZWRlbnRpYWwgfCBSVE9wZW5BSU9wdGlvbnMsXG4gICAgb3B0aW9ucz86IFJUQXp1cmVPcGVuQUlPcHRpb25zIHwgUlRWb2ljZUFnZW50T3B0aW9ucyxcbiAgKSB7XG4gICAgdGhpcy5jbGllbnQgPSAoKCkgPT4ge1xuICAgICAgaWYgKGlzS2V5Q3JlZGVudGlhbCh1cmlPckNyZWRlbnRpYWwpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG93TGV2ZWxSVENsaWVudChcbiAgICAgICAgICB1cmlPckNyZWRlbnRpYWwsXG4gICAgICAgICAgY3JlZGVudGlhbE9yT3B0aW9ucyBhcyBSVE9wZW5BSU9wdGlvbnMsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IExvd0xldmVsUlRDbGllbnQoXG4gICAgICAgICAgdXJpT3JDcmVkZW50aWFsIGFzIFVSTCxcbiAgICAgICAgICBjcmVkZW50aWFsT3JPcHRpb25zIGFzIEtleUNyZWRlbnRpYWwgfCBUb2tlbkNyZWRlbnRpYWwsXG4gICAgICAgICAgb3B0aW9ucyBhcyBSVEF6dXJlT3BlbkFJT3B0aW9ucyB8IFJUVm9pY2VBZ2VudE9wdGlvbnMsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgICB0aGlzLm1lc3NhZ2VzSXRlcmFibGUgPSB0aGlzLmNsaWVudC5tZXNzYWdlcygpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIHRoaXMubWVzc2FnZVF1ZXVlID0gbmV3IE1lc3NhZ2VRdWV1ZVdpdGhFcnJvcjxTZXJ2ZXJNZXNzYWdlVHlwZT4oXG4gICAgICAoKSA9PiB0aGlzLnJlY2VpdmVNZXNzYWdlcygpLFxuICAgICAgKG0pID0+IG0udHlwZSA9PT0gXCJlcnJvclwiLFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlY2VpdmVNZXNzYWdlcygpOiBQcm9taXNlPFNlcnZlck1lc3NhZ2VUeXBlIHwgbnVsbD4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMubWVzc2FnZXNJdGVyYWJsZS5uZXh0KCk7XG4gICAgcmV0dXJuIHJlc3VsdC5kb25lID8gbnVsbCA6IHJlc3VsdC52YWx1ZTtcbiAgfVxuXG4gIGdldCByZXF1ZXN0SWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdElkO1xuICB9XG5cbiAgaW5pdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5pbml0UHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5pbml0UHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zZXNzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHRoaXMubWVzc2FnZVF1ZXVlLnJlY2VpdmUoXG4gICAgICAgIChtKSA9PiBtLnR5cGUgPT09IFwic2Vzc2lvbi5jcmVhdGVkXCIsXG4gICAgICApO1xuICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGluaXRpYWxpemUgc2Vzc2lvblwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICB0aHJvdyBuZXcgUlRFcnJvcihtZXNzYWdlLmVycm9yKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwic2Vzc2lvbi5jcmVhdGVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtZXNzYWdlIHR5cGVcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNlc3Npb24gPSBtZXNzYWdlLnNlc3Npb247XG4gICAgfSkoKTtcbiAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZTtcbiAgfVxuXG4gIGFzeW5jIGNvbmZpZ3VyZShwYXJhbXM6IFNlc3Npb25VcGRhdGVQYXJhbXMpOiBQcm9taXNlPFNlc3Npb24+IHtcbiAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5zZW5kKHtcbiAgICAgIHR5cGU6IFwic2Vzc2lvbi51cGRhdGVcIixcbiAgICAgIHNlc3Npb246IHBhcmFtcyxcbiAgICB9KTtcbiAgICBjb25zdCBtZXNzYWdlID0gYXdhaXQgdGhpcy5tZXNzYWdlUXVldWUucmVjZWl2ZShcbiAgICAgIChtKSA9PiBtLnR5cGUgPT09IFwic2Vzc2lvbi51cGRhdGVkXCIsXG4gICAgKTtcbiAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHVwZGF0ZSBzZXNzaW9uXCIpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgIHRocm93IG5ldyBSVEVycm9yKG1lc3NhZ2UuZXJyb3IpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcInNlc3Npb24udXBkYXRlZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1lc3NhZ2UgdHlwZVwiKTtcbiAgICB9XG4gICAgdGhpcy5zZXNzaW9uID0gbWVzc2FnZS5zZXNzaW9uO1xuICAgIHJldHVybiB0aGlzLnNlc3Npb247XG4gIH1cblxuICBhc3luYyBzZW5kQXVkaW8oYXVkaW86IFVpbnQ4QXJyYXkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICBjb25zdCBiYXNlNjQgPSBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uYXVkaW8pKTtcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5zZW5kKHtcbiAgICAgIHR5cGU6IFwiaW5wdXRfYXVkaW9fYnVmZmVyLmFwcGVuZFwiLFxuICAgICAgYXVkaW86IGJhc2U2NCxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGNvbW1pdEF1ZGlvKCk6IFByb21pc2U8UlRJbnB1dEF1ZGlvSXRlbT4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIGF3YWl0IHRoaXMuY2xpZW50LnNlbmQoeyB0eXBlOiBcImlucHV0X2F1ZGlvX2J1ZmZlci5jb21taXRcIiB9KTtcbiAgICBjb25zdCBtZXNzYWdlID0gYXdhaXQgdGhpcy5tZXNzYWdlUXVldWUucmVjZWl2ZShcbiAgICAgIChtKSA9PiBtLnR5cGUgPT09IFwiaW5wdXRfYXVkaW9fYnVmZmVyLmNvbW1pdHRlZFwiLFxuICAgICk7XG4gICAgaWYgKG1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb21taXQgYXVkaW9cIik7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgdGhyb3cgbmV3IFJURXJyb3IobWVzc2FnZS5lcnJvcik7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiaW5wdXRfYXVkaW9fYnVmZmVyLmNvbW1pdHRlZFwiKSB7XG4gICAgICByZXR1cm4gUlRJbnB1dEF1ZGlvSXRlbS5jcmVhdGUoXG4gICAgICAgIG1lc3NhZ2UuaXRlbV9pZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB0aGlzLnNlc3Npb24/LmlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0aGlzLnNlc3Npb24/LmlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24gIT09IG51bGwsXG4gICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtZXNzYWdlIHR5cGVcIik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgY2xlYXJBdWRpbygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5zZW5kKHsgdHlwZTogXCJpbnB1dF9hdWRpb19idWZmZXIuY2xlYXJcIiB9KTtcbiAgICBjb25zdCBtZXNzYWdlID0gYXdhaXQgdGhpcy5tZXNzYWdlUXVldWUucmVjZWl2ZShcbiAgICAgIChtKSA9PiBtLnR5cGUgPT09IFwiaW5wdXRfYXVkaW9fYnVmZmVyLmNsZWFyZWRcIixcbiAgICApO1xuICAgIGlmIChtZXNzYWdlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY2xlYXIgYXVkaW9cIik7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgdGhyb3cgbmV3IFJURXJyb3IobWVzc2FnZS5lcnJvcik7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiaW5wdXRfYXVkaW9fYnVmZmVyLmNsZWFyZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtZXNzYWdlIHR5cGVcIik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgY29ubmVjdEF2YXRhcihjbGllbnRfc2RwOiBSVENTZXNzaW9uRGVzY3JpcHRpb24pOiBQcm9taXNlPFJUQ1Nlc3Npb25EZXNjcmlwdGlvbj4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIGNvbnN0IGJhc2U2NCA9IGJ0b2EoSlNPTi5zdHJpbmdpZnkoY2xpZW50X3NkcCkpO1xuICAgIGF3YWl0IHRoaXMuY2xpZW50LnNlbmQoe1xuICAgICAgdHlwZTogXCJzZXNzaW9uLmF2YXRhci5jb25uZWN0XCIsXG4gICAgICBjbGllbnRfc2RwOiBiYXNlNjQsXG4gICAgfSk7XG4gICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHRoaXMubWVzc2FnZVF1ZXVlLnJlY2VpdmUoXG4gICAgICAobSkgPT4gbS50eXBlID09PSBcInNlc3Npb24uYXZhdGFyLmNvbm5lY3RpbmdcIixcbiAgICApO1xuICAgIGlmIChtZXNzYWdlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY29ubmVjdCBhdmF0YXJcIik7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgdGhyb3cgbmV3IFJURXJyb3IobWVzc2FnZS5lcnJvcik7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwic2Vzc2lvbi5hdmF0YXIuY29ubmVjdGluZ1wiKSB7XG4gICAgICByZXR1cm4gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbihcbiAgICAgICAgSlNPTi5wYXJzZShhdG9iKG1lc3NhZ2Uuc2VydmVyX3NkcCkpIGFzIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1lc3NhZ2UgdHlwZVwiKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBzZW5kSXRlbShpdGVtOiBJdGVtLCBwcmV2aW91c0l0ZW1JZD86IHN0cmluZyk6IFByb21pc2U8UmVzcG9uc2VJdGVtPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgaXRlbS5pZCA9IGl0ZW0uaWQgfHwgZ2VuZXJhdGVJZChcIml0ZW1cIiwgMzIpO1xuICAgIGF3YWl0IHRoaXMuY2xpZW50LnNlbmQoe1xuICAgICAgdHlwZTogXCJjb252ZXJzYXRpb24uaXRlbS5jcmVhdGVcIixcbiAgICAgIHByZXZpb3VzX2l0ZW1faWQ6IHByZXZpb3VzSXRlbUlkLFxuICAgICAgaXRlbSxcbiAgICB9KTtcbiAgICBjb25zdCBtZXNzYWdlID0gYXdhaXQgdGhpcy5tZXNzYWdlUXVldWUucmVjZWl2ZShcbiAgICAgIChtKSA9PiBtLnR5cGUgPT09IFwiY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlZFwiICYmIG0uaXRlbS5pZCA9PT0gaXRlbS5pZCxcbiAgICApO1xuICAgIGlmIChtZXNzYWdlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGl0ZW1cIik7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgdGhyb3cgbmV3IFJURXJyb3IobWVzc2FnZS5lcnJvcik7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlZFwiKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZS5pdGVtO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1lc3NhZ2UgdHlwZVwiKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyByZW1vdmVJdGVtKGl0ZW1JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgYXdhaXQgdGhpcy5jbGllbnQuc2VuZCh7XG4gICAgICB0eXBlOiBcImNvbnZlcnNhdGlvbi5pdGVtLmRlbGV0ZVwiLFxuICAgICAgaXRlbV9pZDogaXRlbUlkLFxuICAgIH0pO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLm1lc3NhZ2VRdWV1ZS5yZWNlaXZlKFxuICAgICAgKG0pID0+IG0udHlwZSA9PT0gXCJjb252ZXJzYXRpb24uaXRlbS5kZWxldGVkXCIgJiYgbS5pdGVtX2lkID09PSBpdGVtSWQsXG4gICAgKTtcbiAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlbGV0ZSBpdGVtXCIpO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgIHRocm93IG5ldyBSVEVycm9yKG1lc3NhZ2UuZXJyb3IpO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcImNvbnZlcnNhdGlvbi5pdGVtLmRlbGV0ZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1lc3NhZ2UgdHlwZVwiKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZW5lcmF0ZVJlc3BvbnNlKHJlc3BvbnNlPzogUmVzcG9uc2VDcmVhdGVQYXJhbXMsIHdhaXRGb3JHZW5lcmF0ZWQ/OiBib29sZWFuKTogUHJvbWlzZTxSVFJlc3BvbnNlIHwgdW5kZWZpbmVkPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgYXdhaXQgdGhpcy5jbGllbnQuc2VuZCh7IHR5cGU6IFwicmVzcG9uc2UuY3JlYXRlXCIsIHJlc3BvbnNlIH0pO1xuICAgIGlmICghdGhpcy5pdGVyYXRpbmcgJiYgd2FpdEZvckdlbmVyYXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHRoaXMubWVzc2FnZVF1ZXVlLnJlY2VpdmUoXG4gICAgICAgIChtKSA9PiBtLnR5cGUgPT09IFwicmVzcG9uc2UuY3JlYXRlZFwiLFxuICAgICAgKTtcbiAgICAgIGlmIChtZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgcmVzcG9uc2VcIik7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIHRocm93IG5ldyBSVEVycm9yKG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwicmVzcG9uc2UuY3JlYXRlZFwiKSB7XG4gICAgICAgIHJldHVybiBSVFJlc3BvbnNlLmNyZWF0ZShcbiAgICAgICAgICBtZXNzYWdlLnJlc3BvbnNlLFxuICAgICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLFxuICAgICAgICAgIHRoaXMuY2xpZW50LFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtZXNzYWdlIHR5cGVcIik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBhc3luYyAqZXZlbnRzKCk6IEFzeW5jSXRlcmFibGU8UlRJbnB1dEF1ZGlvSXRlbSB8IFJUUmVzcG9uc2U+IHtcbiAgICAvLyBUT0RPOiBBZGQgdGhlIHVwZGF0ZWQgcXVvdGEgbWVzc2FnZSBhcyBhIGNvbnRyb2wgdHlwZSBvZiBldmVudC5cbiAgICB0cnkge1xuICAgICAgdGhpcy5pdGVyYXRpbmcgPSB0cnVlO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHRoaXMubWVzc2FnZVF1ZXVlLnJlY2VpdmUoXG4gICAgICAgICAgKG0pID0+XG4gICAgICAgICAgICBtLnR5cGUgPT09IFwiaW5wdXRfYXVkaW9fYnVmZmVyLnNwZWVjaF9zdGFydGVkXCIgfHxcbiAgICAgICAgICAgIG0udHlwZSA9PT0gXCJyZXNwb25zZS5jcmVhdGVkXCIsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUlRFcnJvcihtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiaW5wdXRfYXVkaW9fYnVmZmVyLnNwZWVjaF9zdGFydGVkXCIpIHtcbiAgICAgICAgICBjb25zdCBpbnB1dF9hdWRpb19pdGVtID0gUlRJbnB1dEF1ZGlvSXRlbS5jcmVhdGUoXG4gICAgICAgICAgICBtZXNzYWdlLml0ZW1faWQsXG4gICAgICAgICAgICBtZXNzYWdlLmF1ZGlvX3N0YXJ0X21zLFxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uPy5pbnB1dF9hdWRpb190cmFuc2NyaXB0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbj8uaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbiAhPT0gbnVsbCxcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLFxuICAgICAgICAgICk7XG4gICAgICAgICAgeWllbGQgaW5wdXRfYXVkaW9faXRlbTtcbiAgICAgICAgICBhd2FpdCBpbnB1dF9hdWRpb19pdGVtLndhaXRGb3JDb21wbGV0aW9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcInJlc3BvbnNlLmNyZWF0ZWRcIikge1xuICAgICAgICAgIHlpZWxkIFJUUmVzcG9uc2UuY3JlYXRlKFxuICAgICAgICAgICAgbWVzc2FnZS5yZXNwb25zZSxcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLFxuICAgICAgICAgICAgdGhpcy5jbGllbnQsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1lc3NhZ2UgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLml0ZXJhdGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNsb3NlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuY2xpZW50LmNsb3NlKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJyZXF1aXJlJCQwIiwiYnVmZmVyVXRpbE1vZHVsZSIsImJ1ZmZlclV0aWwiLCJyZXF1aXJlJCQxIiwicmVxdWlyZSQkMiIsInJlcXVpcmUkJDMiLCJ2YWxpZGF0aW9uTW9kdWxlIiwicmVxdWlyZSQkNCIsInJlcXVpcmUkJDUiLCJyZXF1aXJlJCQ4IiwicmVxdWlyZSQkOSIsInJlcXVpcmUkJDEwIiwicmVxdWlyZSQkMTEiLCJyZXF1aXJlJCQxMiIsInJlcXVpcmUkJDEzIiwicmVxdWlyZSQkMTQiLCJyZXF1aXJlJCQxNSIsInJlcXVpcmUkJDYiLCJyZXF1aXJlJCQ3Il0sImlnbm9yZUxpc3QiOlsxLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTRdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rt-client/dist/esm/index.js\n");

/***/ })

};
;